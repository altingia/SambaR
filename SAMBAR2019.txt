if(getRversion()<'3.5.0')
	{
	cat("WARNING: SambaR depends on the package 'car', which can only be installed on R versions 3.5.0 or higher.",sep="\n")
	cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
	if("car" %in% rownames(installed.packages()))
		{
		cat("Because the package 'car' is already installed in this R version on your computer, this won't cause problems for now.",sep="\n")
		cat("It is still worth considering installing a newer R version at some point.",sep="\n")
		}else{
		cat("The package 'car' is not yet installed in this R version on your computer.",sep="\n")
		cat("Therefore, you need to install a newer version of R (3.5.0 or newer) and run SambaR on this newer version.",sep="\n")
		}
	}

# SAMBAR: Snp DatA Management and Basic Analyses in R 
# Author: Menno de Jong, Durham University 
# Potential journal for publication:
# BMC Source code Biology and Medicine
# Example paper: 'popRange: a highly flexible spatially and temporally explicit Wright-Fisher simulator'
# Another example paper: PEGAS

#Data from: Genomic signatures of population bottleneck and recovery in Northwest Atlantic pinnipeds
greyseals<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Otherpeople/seals/greyseal")
	importdata(inputprefix="greyseals",sumstatsfile=FALSE,depthfile=FALSE)
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity()
	backupdata("greyseals")
	}

harborseals<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Otherpeople/seals/harborseal")
	importdata(inputprefix="harborseals",sumstatsfile=FALSE,depthfile=FALSE)
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity()
	backupdata("harborseals")
	selectionanalyses(export="pdf",do_meta=TRUE,add_bayescan=FALSE)
	inds$type	<- ifelse(inds$pop=="NUS2015",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,add_bayescan=FALSE,phenolabels=c("2015","previous"))
	}	

#head -2 NLUK.ped | cut -f1-6 > sampleinfo.txt
#grep 'Wytham_UK' sampleinfo.txt | head -30 | cut -f1,2
#grep 'Oosterhout' sampleinfo.txt | head -30 | cut -f1,2
#grep 'Hoge_Veluwe' sampleinfo.txt | head -30 | cut -f1,2
#C:\Users\Tatiana\Menno\Programs\plink\plink --file NLUK –-cow –-chr-set 95 --keep selectedindividuals.txt --thin-count 80000 --recode --make-bed --out NLUK.80000snps.90samples
tits<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Otherpeople/greattits/")
	importdata(inputprefix="NLUK.80000snps.90samples",sumstatsfile=FALSE,depthfile=FALSE)
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity()
	selectionanalyses(export="pdf",do_meta=TRUE,do_pheno=FALSE,do_outflank=TRUE)
	inds$type	<- ifelse(inds$pop=="Wytham",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,add_bayescan=FALSE,phenolabels=c("UK","mainland"))
	backupdata("tits")
	}

bot<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Otherpeople/flounders/")
	if(pops13)
		{
		popcols		<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","deepskyblue","greenyellow","indianred1","gray20","lightblue","black")
		importdata(inputprefix="flounders",sumstatsfile=FALSE,depthfile=FALSE,colourvector=popcols)
		inds$type	<- ifelse(inds$pop=="Gullmaren"|inds$pop=="Kattegat"|inds$pop=="Barseback"|inds$pop=="Dabki"|inds$pop=="Gdynia"|inds$pop=="Bornholm"|inds$pop=="Latvian",TRUE,FALSE)
		filterdata()
		selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_fsthet=FALSE,add_bayescan=FALSE,phenolabels=c("pelagic","demersal"))	
		}else{
		importdata(inputprefix="flounders",sumstatsfile=FALSE,depthfile=FALSE)
		filterdata()
		findstructure()
		inds$type	<- ifelse(inds$pop=="demersal",TRUE,FALSE)
		selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_fsthet=FALSE,add_bayescan=FALSE,phenolabels=c("demersal","pelagic"))	
		}
	}
	
bankvole<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Otherpeople/bankvole/")
	importdata(inputprefix="bankvole",sumstatsfile=FALSE,depthfile=FALSE)
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity()
	}

#C:\Users\Tatiana\Menno\Programs\plink\plink --file channelfox –-cow –-allow-extra-chr --make-bed --recode A --out channelfox
channelfox<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Otherpeople/channelfox/")
	importdata(inputprefix="channelfox",sumstatsfile=FALSE,depthfile=FALSE)
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity()
	inds$type	<- ifelse(inds$pop=="grey",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_outflank=FALSE)
	backupdata("channelfox")
	}

polar<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Otherpeople/PolarBear/")
	importdata(inputprefix="polarbear",sumstatsfile=FALSE,depthfile=FALSE)
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	}

daniel<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Otherpeople/Daniel/")
	importdata(inputprefix="ecotypes",sumstatsfile=TRUE,depthfile=FALSE,geofile="ecotypes_geofile.txt")
	filterdata(indmiss=0.1,snpmiss=0.1)
	findstructure(Kmax=5,do_pi=FALSE)
	}
	
rus<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	# setwd("C:/Users/Tatiana/Menno/Otherpeople/Rus/5pops2K")
	# importdata(inputprefix="5pops2Ksnps",sumstatsfile=FALSE,depthfile=FALSE)
	setwd("C:/Users/Tatiana/Menno/Otherpeople/Rus/4pops")
	importdata(inputprefix="4pops",sumstatsfile=FALSE,depthfile=FALSE)
	filterdata(indmiss=0.99,snpmiss=0.99)
	findstructure()
	calcdistance()
	calcdiversity()
	selectionanalyses(export="pdf",do_meta=TRUE,do_outflank=TRUE)
	}	
	
#C:\Users\Tatiana\Menno\Programs\plink\plink --file 9pops –-cow –-allow-extra-chr --make-bed --recode A --out 9pops
yinhla<-function(dospecies=FALSE)
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Otherpeople/Yinhla")
	importdata(inputprefix="9pops",sumstatsfile=FALSE,depthfile=FALSE)
	if(dospecies)
		{
		inds$pop3				<- ifelse(inds$pop2=="Watertunnel"|inds$pop2=="Trypot","Gazella","Tropicalis")
		inds$pop2				<- as.factor(inds$pop3)
		inds$pop				<- as.factor(inds$pop3)
		inds$popcol				<- ifelse(inds$pop3=="Gazella","blue","darkgreen")
		mysambar$populations	<- c("Gazella","Tropicalis")
		mysambar$mycolours		<- c("blue","darkgreen")
		}
	filterdata(indmiss=0.99,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity()
	inds$filter	<<- inds$filter&inds$pop!="Watertunnel"&inds$pop!="Trypot"
	inds$type	<<- ifelse(inds$pop=="Longbeach"|inds$pop=="SealBeach",TRUE,FALSE)	
	selectionanalyses(export="pdf",do_meta=TRUE,do_outflank=TRUE)					
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_outflank=FALSE)	# outflank returns error
	selectionanalyses(export="pdf",do_meta=FALSE,do_pairwise=TRUE,do_outflank=TRUE)	# outflank returns error
	backupdata("yinhla.9pops")
	}

#C:\Users\Tatiana\Menno\Programs\plink\plink --file 7pops.nohybrids –-cow –-allow-extra-chr --make-bed --recode A --out 7pops.nohybrids
yin2<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Otherpeople/Yinhla/Tropicalis")
	importdata(inputprefix="7pops.nohybrids",sumstatsfile=FALSE,depthfile=FALSE)
	filterdata(indmiss=0.99,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity()
	inds$type	<- ifelse(inds$pop=="Longbeach"|inds$pop=="SealBeach",TRUE,FALSE)	
	#selectionanalyses(export="pdf",do_meta=TRUE,do_outflank=FALSE)					# outflank returns error
	#selectionanalyses(export="pdf",do_meta=FALSE,do_pairwise=TRUE,do_outflank=FALSE)	# this crashed
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_outflank=FALSE)	# outflank returns error
	backupdata("yinhla.7pops")
	}
	
vania<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Vania")
	importdata(inputprefix="NOsnps",sumstatsfile=FALSE,depthfile=FALSE,vcfsamplefile="popfile2.txt")
	filterdata(indmiss=0.9,snpmiss=0.9,silent=FALSE)
	}

# To do all at once for the reindeer data, type:
# C:\Users\Tatiana\Menno\Programs\plink\plink --file rein.cowasref –-cow –-allow-extra-chr --make-bed --recode A --out rein.cowasref
doreindeer<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	setwd("C:/Users/Tatiana/Menno/ReindeerCombined/ReinasRef/Multiplesnpsperread/Stacksrefmap")
	#getpackages(myrepos='http://cran.us.r-project.org')
	importdata(inputprefix="reinasref.multiplesnps",sumstatsfile=TRUE,depthfile=TRUE)
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity(nrsites=9627819)
	# calcdiversity(nrsites=3969066)		# cow as ref
	inds$type<<-ifelse(inds$pop=="Norway",FALSE,TRUE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,add_bayescan=TRUE,phenolabels=c("founder","source"),bayescan_mapfile="bayescaninput.map")
	multiplotscaffold(my_bed="putativegenes.within200kb.genenames.bed",background_pop="Norway",doexport=TRUE,x_range=NULL,y_loc=c(0.4,0.65))
	}


	
# roe deer:
# C:\Users\Tatiana\Menno\Programs\plink\plink --file roe.roeasref.q20 –-cow –-allow-extra-chr --make-bed --recode A --out roe.roeasref.q20
doroe<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Roe/roe.roeasref/q20")
	importdata(inputprefix="roe.roeasref.q20",sumstatsfile=TRUE,depthfile=TRUE,geofile="geocoordfile.txt",colourvector=c("darkgreen","blue","darkred","orange","darkorchid4","#654321","yellow","gray20"))
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity(nrsites=8196980)
	inds$type<-ifelse(inds$pop=="Germany",FALSE,TRUE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_fsthet=TRUE,add_bayescan=FALSE,phenolabels=c("UK","Germany"))	# diversifying selection
	inds$type<-ifelse(inds$pop=="Ayrshire",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_fsthet=TRUE,add_bayescan=FALSE,phenolabels=c("native UK","mainland"))	# diversifying selection
	selectionanalyses(export="pdf",do_meta=TRUE,do_fsthet=TRUE)																	# balancing selection
	backupdata("roemain")
	}

#C:\Users\Tatiana\Menno\Programs\plink\plink --file roe.redasref.q20 –-cow –-allow-extra-chr --make-bed --recode A --out roe.redasref.q20	
dored<-function()
	{
	source("I:/PhD/General/SAMBAR/SAMBAR2019.txt")
	#getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Roe/roe.redasref/q20")
	importdata(inputprefix="roe.redasref.q20",sumstatsfile=TRUE,depthfile=FALSE,colourvector=c("darkgreen","blue","darkred","orange","darkorchid4","#654321","yellow","gray20"))
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity()
	backupdata("roered")
	}
	
# roe france:
dofrance<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/RoeFrance/Refmap_roe/q20/")
	importdata(inputprefix="france.roeasref.q20",sumstatsfile=TRUE,depthfile=FALSE,colourvector=c("orange","darkgreen","blue","darkred","darkorchid4","#654321","yellow","gray20"))
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity(nrsites=5607250)
	backupdata("roefrance")
	}

# these commands need to be separately, to store output in global environment:
#setwd(roefrance$inputdatadir)
#findoverlap(roemain,roefrance,mycolours=c("orange","darkgreen","blue","darkred"))
combine_roe<-function(getpifromsharedsnps=FALSE)
	{
	setwd(roefrance$inputdatadir)
	findoverlap(roemain,roefrance,mycolours=c("orange","darkgreen","blue","darkred"))
	getdata("mysambarcombined")
	filterdata(indmiss=0.25,snpmiss=0.1)
	inds$latitude<-ifelse(inds$pop=="Aurignac",43.2174,(ifelse(inds$pop=="EastAnglia",52.1898,(ifelse(inds$pop=="Ayrshire",55.3650,48.6616)))))
	inds$longitude<-ifelse(inds$pop=="Aurignac",0.8817,(ifelse(inds$pop=="EastAnglia",0.5803,(ifelse(inds$pop=="Ayrshire",-4.6690,9.3501)))))
	findstructure()
	calcdistance()
	if(!getpifromsharedsnps)
		{
		inds$pi				<<- c(roefrance$inds$pi[order(roefrance$inds$name)],roemain$inds$pi[order(roemain$inds$name)])	
		inds$hetero			<<- c(roefrance$inds$hetero[order(roefrance$inds$name)],roemain$inds$hetero[order(roemain$inds$name)])
		inds$hetero_all		<<- c(roefrance$inds$hetero_all[order(roefrance$inds$name)],roemain$inds$hetero_all[order(roemain$inds$name)])
		inds$hetero_all2	<<- c(roefrance$inds$hetero_all2[order(roefrance$inds$name)],roemain$inds$hetero_all2[order(roemain$inds$name)])
		}
	numberofsnps		<-c(roefrance$inds$nsegsites4[order(roefrance$inds$name)],roemain$inds$nsegsites4[order(roemain$inds$name)])
	calcdiversity(nrsites=c(5607250,8196980,8196980,8196980),nrsnps=numberofsnps,nrsegsites=c(29396,33236,25439,46110))
	run_plotstairway(mu_rate="2.5*10^-8",Gtime="20",x_range=c(100,400000),exporttype="pdf",my_suffix="filtered_1.1e8_5year.final.summary",add_glacials=TRUE)
	nonshared_plots()
	backupdata("mysambarcombined")
	#snps[,c("name","chr","pos","uniqpos","minorcount","majorcount","miss","misscount","nonmissallelecount","hefilter","distfilter","filter")]
	}

#C:\Users\Tatiana\Menno\Programs\plink\plink --file spermwhale_3popr70p3.Bcluster –-cow –-allow-extra-chr --make-bed --recode A --out spermwhale_3popr70p3.Bcluster	
# Biagio:
dospermwhale<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	getpackages(myrepos='http://cran.us.r-project.org')
	#setwd("C:/Users/Tatiana/Menno/Biagio/3pop")
	#importdata(inputprefix="spermwhale_3popr70p3",geofile="geofile.txt",sumstatsfile=FALSE,depthfile=TRUE,vcfsamplefile="populationsfile_10pops.txt")
	#importdata(inputprefix="spermwhale_3popr70p3",geofile="geofile.txt",sumstatsfile=FALSE,depthfile=TRUE,vcfsamplefile="populationsfile_3pops.txt")
	setwd("C:/Users/Tatiana/Menno/Biagio/Bcluster")
	importdata(inputprefix="spermwhale_3popr70p3.Bcluster",geofile="geofile.txt",sumstatsfile=FALSE,depthfile=TRUE)
	filterdata(indmiss=0.5,snpmiss=0.1)
	addsampleinfo()
	#subset_pop(include_pops=c("Azores","Canarian","Madeira","NorthSpain"))
	findstructure()
	calcdistance()
	calcdiversity(nrsites=25350544)
	backupdata("spermwhale")
	selectionanalyses(export="pdf",do_meta=TRUE,do_fsthet=FALSE,do_outflank=TRUE)
	inds$type	<- ifelse(inds$pop=="Mediterranean",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_fsthet=FALSE,do_outflank=TRUE)
	inds$type	<- ifelse(inds$pop=="Bcluster",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_fsthet=FALSE,do_outflank=TRUE)
	inds$type	<- ifelse(inds$pop=="Atlantic",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_fsthet=FALSE,do_outflank=TRUE)
	}

# Erandi:
dobirds<-function()
	{
	source("G:/PhD/General/SAMBAR/SAMBAR2019.txt")
	#getpackages(myrepos='http://cran.us.r-project.org')
	setwd("C:/Users/Tatiana/Menno/Erandi")
	#importdata(inputprefix="mindepth3",sumstatsfile=FALSE,depthfile=TRUE,vcfsamplefile="delimited.txt")
	importdata(inputprefix="populations.snps",sumstatsfile=TRUE,depthfile=FALSE)
	filterdata(indmiss=0.5,snpmiss=0.1)
	findstructure()
	calcdistance()
	calcdiversity()
	selectionanalyses(export="pdf",do_meta=TRUE,do_fsthet=FALSE,do_outflank=FALSE)
	inds$type<<-ifelse(inds$pop=="SJ18",FALSE,TRUE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_fsthet=FALSE,do_outflank=FALSE)
	inds$type<<-ifelse(inds$pop=="SPM",FALSE,TRUE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_fsthet=FALSE,do_outflank=FALSE)
	inds$type<<-ifelse(inds$pop=="M16",FALSE,TRUE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,do_fsthet=FALSE,do_outflank=FALSE)
	}

dodummy<-function()
	{
	getdata("roemain")
	#dummydata(nind=40,nsnp=25,q=0.15,popname="pop1",popcol="blue",mygeno=rep(c(rep(0,39),1),25),major=1,minor=4)
	#dummydata(nind=40,nsnp=25,q=0.15,popname="pop1",popcol="blue",mygeno=rep(1,(40*25)),major=1,minor=4)
	#dummydata(nind=40,nsnp=25,q=0.15,popname="pop1",popcol="blue",mygeno=rep(c(rep(0,20),rep(2,20)),25),major=1,minor=4)
	dummydata(nind=50,nsnp=1000,q=0.15,popname="pop1",popcol="blue",major=1,minor=4,colourvector=c("darkgreen","blue","darkred","orange","darkorchid4","#654321","yellow","gray20"))
	filterdata(indmiss=0.25,snpmiss=0.1,dofiltermaf=FALSE,dohefilter=FALSE)
	findstructure()
	calcdistance()
	calcdiversity()
	}

dosubsets<-function()
	{
	getdata("roemain")
	subsampledata(nrinds=NULL,nrsnps=5000,exportprefix=NULL,remove_stats=TRUE,popcolours=c("darkgreen","blue","darkred","orange","darkorchid4","#654321","yellow","gray20"))
	getdata('mysambarsubset')
	filterdata()
	findstructure()
	calcdiversity(nrsites=8196980)
	}
	
#setwd("C:/Users/Tatiana/Menno/Erandi/oldinput")
	
# Size of R objects in ascending order:
# sort( sapply(ls(),function(x){object.size(get(x))})) 
# Combined size:
# print(object.size(x=lapply(ls(), get)), units="Mb")

getcitations<-function()
	{
	mysoftwares			<- c("stats","pegas","fsthet","mapplots","rworldmap","ade4","bibtex","curl","colorspace","ape","scales","vegan","adegenet","StAMPP","scatterplot3d","plot3D","zoo","devtools","vioplot","gplots","RColorBrewer","migest","plyr","circlize","pcadapt","grid","gridGraphics","gridExtra","MASS","poppr","qvalue","gdsfmt","SNPRelate","LEA","OutFLANK")
	mysoftwares			<- mysoftwares[order(mysoftwares)]
	setwd(mysambar$sambardir)
	write.bib(mysoftwares, file = "SambaR_Rpackages.bib", append = FALSE, verbose = TRUE)
	cat("A file called 'SambaR_Rpackages.bib' has been exported to the SambaR directory.",sep="\n")
	cat("This file can be loaded into a referencing software, such as Zotero or Endnote, although it might need some manual editing.",sep="\n")
	}

getversions<-function()
	{
	mysoftwares			<- c("stats","pegas","fsthet","mapplots","rworldmap","bibtex","ade4","curl","colorspace","ape","scales","vegan","adegenet","StAMPP","scatterplot3d","plot3D","zoo","devtools","vioplot","gplots","RColorBrewer","migest","plyr","circlize","pcadapt","grid","gridGraphics","gridExtra","MASS","poppr","qvalue","gdsfmt","SNPRelate","LEA","OutFLANK")
	mysoftwares			<- mysoftwares[order(mysoftwares)]
	myversions			<- vector()
	for (j in c(1:length(mysoftwares)))
		{	
		mypackage		<- mysoftwares[j] 
		myversions[j]	<- packageDescription(mypackage)$Version
		}
	mysoftwares			<- c("R",mysoftwares)
	myversions			<- c(getRversion(),myversions)
	mydf				<- data.frame(package=mysoftwares,version=myversions)	
	mydf$combined		<- paste(mydf$package,mydf$version,sep="-")
	myversions			<<- mydf
	cat("All R package versions stored in an dataframe called 'myversions'.",sep="\n")
	}	

exportmethods<-function(ind_miss=0.25,snp_miss=0.1,minmac=2,hefilter=TRUE,minimumspacing=500)
	{
	myrversion		<- myversions$combined[myversions$package=="R"]
	myadegenet		<- myversions$combined[myversions$package=="adegenet"]
	myrworldmap		<- myversions$combined[myversions$package=="rworldmap"]
	mymapplots		<- myversions$combined[myversions$package=="mapplots"]
	myade4			<- myversions$combined[myversions$package=="ade4"]
	myape			<- myversions$combined[myversions$package=="ape"]
	mystampp		<- myversions$combined[myversions$package=="StAMPP"]
	mypoppr			<- myversions$combined[myversions$package=="poppr"]
	mysnprelate		<- myversions$combined[myversions$package=="SNPRelate"]
	mystats			<- myversions$combined[myversions$package=="stats"]
	mymass			<- myversions$combined[myversions$package=="MASS"]
	mylea			<- myversions$combined[myversions$package=="LEA"]
	mypegas			<- myversions$combined[myversions$package=="pegas"]
	mycirclize		<- myversions$combined[myversions$package=="circlize"]
	myfsthet		<- myversions$combined[myversions$package=="fsthet"]
	myoutflank		<- myversions$combined[myversions$package=="OutFLANK"]
	mypcadapt		<- myversions$combined[myversions$package=="pcadapt"]
	myzoo			<- myversions$combined[myversions$package=="zoo"]
	setwd(mysambar$sambardir)
	ntotalinds		<- nrow(inds)
	nretainedinds	<- nrow(inds[inds$filter,])
	ntotalsnps		<- nrow(snps)
	nretainedsnps	<- nrow(snps[snps$filter2,])
	nthinnedsnps	<- nrow(snps[snps$filter,])
	fileConn	<- file("SambaR_methods.txt")
	writeLines(c("This file contains a template for your methods section. Remove the lines which are not applicable to your study.",
	"Full citations can be found in the 'SambaR_Rpackages.bib' file.",
	"",
	"DATA PREPARATION",
	"PGD-Spider (Lischer and Excoffier, 2012) or vcftools (Danecek et al., 2011) was used to convert the SNP data into PED and MAP format.",
	"The vcftools (Danecek et al., 2011) flags --depth and --site-depth were used to calculate read depth per individual and per SNP.",
	"Binary files (BED, RAW and BIM) were generated from PED and MAP files using PLINK (Purcell et al., 2017, i.e. using the flags --make-bed and --recode A).",
	"DATA MANAGEMENT",
	paste("SNP data management and analyses were performed in ",myrversion," (R Core Team, 2019) using wrapper functions of the R package SambaR.",sep=""),
	paste("The data was imported into R and stored in a genlight object using the function 'read.PLINK' of the R package ",myadegenet," (Jombart, 2008; Jombart and Ahmed, 2011).",sep=""), 
	paste("The data was filtered using the function 'filterdata' of the R package SambaR, with indmiss=",ind_miss,", snpmiss=",snp_miss,", min_mac=",minmac,", dohefilter=",hefilter," and minimum_spacing=",minimumspacing,".",sep=""),
	paste("After filtering ",nretainedinds," out of ",ntotalinds," individuals were retained.",sep=""),
	paste("After filtering ",nretainedsnps," out of ",ntotalsnps," SNPs were retained. This filtered dataset was used for selection analyses.",sep=""),
	paste("After filtering and thinning ",nthinnedsnps," out of ",ntotalsnps," SNPs were retained. This filtered and thinned dataset was used for structure analyses.",sep=""),
	"PLOTTING",
	paste("Geographical maps were generated with the function 'getMap' of the R package ",myrworldmap," (South, 2011). Piecharts were added using the function 'add.pie' of the R package ",mymapplots," (Gerritsen, 2018).",sep=""),
	"STRUCTURE ANALYSES",
	paste("Correspondence analyses (CA) were performed using the function 'dudi.coa' of the R package ",myade4," (Dray and Dufour, 2007; Bougeard and Dray, 2018). Data was imputed per individual (i.e. row) using the command 'myrow[is.na(myrow)]<-sample(as.vector(myrow[!is.na(myrow)]),length(myrow[is.na(myrow)]),replace=TRUE)'.",sep=""),
	paste("Principal coordinate analyses (PCoA) were performed using the function 'pcoa' of the R package ",myape," (Paradis and Schliep, 2018) on distance matrices containing 3 different measures of genetic distance:",sep=""),
	paste("- Nei's genetic distance, calculated with the function 'stamppNeisD' of the R package ",mystampp," (Pembleton et al., 2013).",sep=""),
	paste("- Hamming's genetic distance, calculated with the function 'bitwise.dist' of the R package ",mypoppr," (Kamvar et al., 2014).",sep=""),
	"- pi (pairwise sequence dissimilarity), calculated with the function 'calcpi' of the R package SambaR.", 
	paste("Principal component analyses (PCA) were performed using the function 'snpgdsPCA' of the R package ",mysnprelate," (Zheng et al., 2012).",sep=""),
	paste("DAPC analyses were performed using the function 'dapc' of the R package ",myadegenet," (Jombart, 2008; Jombart and Ahmed, 2011). The number of PCs was set based on the a-score, or, if the a-score suggested a value lower than 10, to a third of the number of individuals. The number of clusters was set to the number of predefined populations, and the number of discriminant functions to 3.",sep=""), 
	paste("Multi dimensional scaling (MDS) was performed using the function 'cmdscale' (metric MDS) of the R package ",mystats," (R Core Team, 2019) and the function 'isoMDS' (non-metric MDS) of the R package ",mymass," (Venables and Ripley, 2002), on a Euclidean distance matrix generated with the function 'dist' of the R package ",mystats," (R Core Team, 2019).",sep=""),
	"Bayesian population assignment probabilities were calculated and plotted using the functions 'assign2pop' and 'plotassign2pop' of the R package SambaR.",
	paste("Admixture coefficients were calculated with the functions 'obj.snmf' and 'Q' of the R package ",mylea," (Frichot and Francois, 2014). Alpha was set to 10, tolerance to 0.00001, and number of iterations to 200.",sep=""), 
	"Ancestry coefficients were calculated with the software Admixture-1.3 (Alexander et al., 2009) and plotted using SambaR.",
	paste("Genotype networks were generated with function 'haploNet' of the R package ",mypegas," (Paradis, 2010).",sep=""),
	"GENETIC DISTANCE ANALYSES",
	paste("Nei's genetic distance was calculated with the function 'stamppNeisD' of the R package ",mystampp," (Pembleton et al., 2013).",sep=""),
	"Wright's Fst and Weir & Cockerham Fst (Weir and Cockerham, 1984) estimates were calculated with the functions 'locusWrightFst', 'locusWCFst' and 'multilocusWeirFst' of the R package SambaR.",
	"Relatedness between samples was calculated using the softwares PLINK and/or GCTA and plotted using SambaR functions.", 
	"GENETIC DIVERSITY ANALYSES",
	"Linkage disequilibrium (LD) estimates were calculated using PLINK (-genome --r2 --ld-window-kb 1000000 --ld-window -r2 0).", 
	"HWE, (2D) folded site frequency spectra (SFS), Tajima's D and genome wide heterozygosity analyses were executed using the function 'calcdiversity' of the R package SambaR.",
	"More specifically, population specific SFS vectors were generated with the function 'getfoldedsfs' of the R package SambaR, which bins SNPs in classes based on their number of copies of the minor allele, and which subsequently calculated the size of each bin (i.e. number of SNPs within each bin).", 
	"Genome wide He (genomeHe) was calculated for each sample using the formula: genome He = (He_seg * N_seg)/N_total, in which:",
	"N_seg: 	the number of sites segregating within the population to which the investigated individual belonged.",
	"He_seg: 	the proportion of heterozygous sites within the investigated individual for those segregating sites.", 
	"N_total:	the combined length of all sequenced sites (polymorphic as well as monomorphic) which passed the filter settings.",  
	"SELECTION ANALYSES",
	paste("Selection analyses were performed using the R packages ",myfsthet," (Flanagan and Jones, 2018), ", myoutflank," (Whitlock and Lotterhos, 2015), ",mypcadapt," (Luu et al., 2016) and the 'gwdsfisher' function of SambaR.",sep=""), 
	paste("Association analyses (GWAS) were performed using the function 'gwdsfisher' of the R package SambaR.",sep=""),
	paste("Sliding window Fst analyses were performed using the function 'rollapply' of the R package ",myzoo,".",sep=""),
	"DEMOGRAPHY ANALYSES",
	"Historical Ne estimates were inferred from the folded SFS vectors with the software stairway_plot_v2 (Liu and Fu, 2015). The mutation rate was set to ... and, the generation time to ...",
	paste("Migration rates were estimated using BayesAss3-SNPs (Mussmann et al., 2019). The number of iterations was set to 1000000, burn-in to 100000 and delta values to 0.1. Output matrices were converted into gene flow plots with the function 'plotmigration' of the R package SambaR, with use of the R package ",mycirclize,".",sep=""), 
	""),fileConn)
	close(fileConn)
	}
		
getpackages<-function(myrepos='http://cran.us.r-project.org',noupdates=TRUE)
	{
	if(getRversion()<'3.5.0')
		{
		if("car" %in% rownames(installed.packages()))
			{
			cat("WARNING: SambaR depends on the package 'car', which can only be installed on R versions 3.5.0 or higher.",sep="\n")
			cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
			cat("Because the package 'car' is already installed in this R version on your computer, this won't cause problems for now.",sep="\n")
			cat("It is still worth considering installing a newer R version at some point.",sep="\n")
			}else{
			cat("ERROR: SambaR depends on the package 'car', which can only be installed on R versions 3.5.0 or higher.",sep="\n")
			cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
			cat("The package 'car' is not yet installed in this R version on your computer.",sep="\n")
			cat("Therefore, you need to install a newer version of R (3.5.0 or newer) and run SambaR on this newer version.",sep="\n")
			return(cat("Dependencies of SambaR have NOT been loaded.",sep="\n"))
			}
		}
	# from CRAN:
	myvector	<- rep(NA,11)
	mysoftwares	<- c("bibtex","curl","colorspace","ape","scales","vegan","adegenet","StAMPP","scatterplot3d","plot3D","zoo","devtools","vioplot","gplots","RColorBrewer","migest","plyr","circlize","pcadapt","grid","gridGraphics","gridExtra","MASS","poppr")
	for (i in c(1:length(mysoftwares)))
		{
		myvector[i]	<- !(mysoftwares[i] %in% rownames(installed.packages()))
		}
	if(!any(myvector))
		{
		cat("All required CRAN packages already installed.",sep="\n")
		}	
	if("car" %in% rownames(installed.packages()) == FALSE) {install.packages('car',repos=myrepos)}								# basic package
	if("curl" %in% rownames(installed.packages()) == FALSE) {install.packages('curl',repos=myrepos)}							# basic package
	if("colorspace" %in% rownames(installed.packages()) == FALSE) {install.packages("colorspace",repos=myrepos)}
	if("ape" %in% rownames(installed.packages()) == FALSE) {install.packages("ape",repos=myrepos)}								# to create PCoA plot, NJ-tree, among other functions
	if("scales" %in% rownames(installed.packages()) == FALSE) {install.packages("scales",repos=myrepos)}						# needed to install adegenet
	if("vegan" %in% rownames(installed.packages()) == FALSE) {install.packages("vegan",repos=myrepos,dep=TRUE)}					# needed to install adegenet
	if("adegenet" %in% rownames(installed.packages()) == FALSE) {install.packages("adegenet",repos=myrepos,dep=TRUE)}			# to save/manipulate data in genlight format
	if("StAMPP" %in% rownames(installed.packages()) == FALSE) {install.packages("StAMPP",repos=myrepos)}						# for AMOVA and Nei's D
	if("scatterplot3d" %in% rownames(installed.packages()) == FALSE) {install.packages("scatterplot3d",repos=myrepos,dep=TRUE)}	# to create DAPCplot
	if("plot3D" %in% rownames(installed.packages()) == FALSE) {install.packages("plot3D",repos=myrepos,dep=TRUE)}				# to create DAPCplot
	if("zoo" %in% rownames(installed.packages()) == FALSE) {install.packages("zoo",repos=myrepos)}								# to do sliding window analyses
	if("devtools" %in% rownames(installed.packages()) == FALSE) {install.packages("devtools",repos=myrepos)}					# to run OUTFLANK (selection analysis)
	if("vioplot" %in% rownames(installed.packages()) == FALSE) {install.packages("vioplot",repos=myrepos)}						# to create violin plots	
	if("gplots" %in% rownames(installed.packages()) == FALSE) {install.packages("gplots",repos=myrepos)}						# to create heatmap
	if("RColorBrewer" %in% rownames(installed.packages()) == FALSE) {install.packages("RColorBrewer",repos=myrepos)}			# to create heatmap
	if("migest" %in% rownames(installed.packages()) == FALSE) {install.packages("migest",repos=myrepos)}						# to create circosplots
	if("plyr" %in% rownames(installed.packages()) == FALSE) {install.packages("plyr",repos=myrepos)}							# to create circosplots
	if("circlize" %in% rownames(installed.packages()) == FALSE) {install.packages("circlize",repos=myrepos)}					# to create circosplots	
	if("pcadapt" %in% rownames(installed.packages()) == FALSE) {install.packages("pcadapt",repos=myrepos)}						# for selection analysis with pcadapt
	if("grid" %in% rownames(installed.packages()) == FALSE) {install.packages("grid",repos=myrepos)}							# to make multi-tile heatmaps
	if("gridGraphics" %in% rownames(installed.packages()) == FALSE) {install.packages("gridGraphics",repos=myrepos)}			# to make multi-tile heatmaps
	if("gridExtra" %in% rownames(installed.packages()) == FALSE) {install.packages("gridExtra",repos=myrepos)}					# to make multi-tile heatmaps
	if("MASS" %in% rownames(installed.packages()) == FALSE) {install.packages("MASS",repos=myrepos)}							# non-metric MDS (multi-dimensional scaling)
	if("poppr" %in% rownames(installed.packages()) == FALSE) {install.packages("poppr",repos=myrepos)}							# Hamming's genetic distance
	if("FactoMineR" %in% rownames(installed.packages()) == FALSE) {install.packages("FactoMineR",repos=myrepos)}				# correspondence analysis
	if("factoextra" %in% rownames(installed.packages()) == FALSE) {install.packages("factoextra",repos=myrepos)}				# correspondence analysis
	if("rworldmap" %in% rownames(installed.packages()) == FALSE) {install.packages('rworldmap',repos=myrepos)}					# geographical maps (getMap function) 
	if("mapplots" %in% rownames(installed.packages()) == FALSE) {install.packages('mapplots',repos=myrepos)}					# geographical maps (addpie function) 
	if("VennDiagram" %in% rownames(installed.packages()) == FALSE) {install.packages('VennDiagram',repos=myrepos)}				# venn diagram
	if("fsthet" %in% rownames(installed.packages()) == FALSE) {install.packages('fsthet',repos=myrepos)}						# selection analysis
	if("PopGenome" %in% rownames(installed.packages()) == FALSE) {install.packages('PopGenome',repos=myrepos)}					# selection analysis
	if("bibtex" %in% rownames(installed.packages()) == FALSE) {install.packages('bibtex',repos=myrepos)}						# selection analysis
	#if("Demerelate" %in% rownames(installed.packages()) == FALSE) {install.packages('Demerelate',repos=myrepos)}				# relatedness estimates (does not work for me coz does not give the matrix I want) 
	#if("synbreed" %in% rownames(installed.packages()) == FALSE) {install.packages('synbreed',repos=myrepos)}					# relatedness estimates (does not work for me coz cannot get package BGLR) 
	#if("GENESIS" %in% rownames(installed.packages()) == FALSE) {install.packages('GENESIS',repos=myrepos)}					# relatedness estimates
	# from Bioconductor:
	myvector	<- rep(NA,4)
	mysoftwares	<- c("qvalue","OutFLANK","gdsfmt","SNPRelate","LEA")
	for (i in c(1:length(mysoftwares)))
		{
		myvector[i]	<- !(mysoftwares[i] %in% rownames(installed.packages()))
		}
	if(any(myvector))
		{
		#source("http://bioconductor.org/biocLite.R")																			# to download bioconductor packages  
		#if("qvalue" %in% rownames(installed.packages()) == FALSE) 	{biocLite("qvalue",suppressUpdates=noupdates)}				# for selection analysis OUTFLANK  
		#if("gdsfmt" %in% rownames(installed.packages()) == FALSE) 	{biocLite("gdsfmt",suppressUpdates=noupdates)}				# for PCA analysis SNPRelate
		if(getRversion()>='3.5.0')									
			{
			if(!requireNamespace("BiocManager", quietly = TRUE))		{install.packages("BiocManager",repos=myrepos)}
			if("SNPRelate" %in% rownames(installed.packages()) == FALSE){BiocManager::install("SNPRelate",suppressUpdates=noupdates)}	# for PCA analysis SNPRelate
			if("LEA" %in% rownames(installed.packages()) == FALSE)		{BiocManager::install("LEA",suppressUpdates=noupdates)}			# for PCA analysis LEA as well as structure analysis
			if("qvalue" %in% rownames(installed.packages()) == FALSE) 	{BiocManager::install("qvalue",suppressUpdates=noupdates)}		# for selection analysis OUTFLANK  
			if("gdsfmt" %in% rownames(installed.packages()) == FALSE) 	{BiocManager::install("gdsfmt",suppressUpdates=noupdates)}
			#if("DNAcopy" %in% rownames(installed.packages()) == FALSE) 	{BiocManager::install("DNAcopy",suppressUpdates=noupdates)}	# for Genesis
			#if("GENESIS" %in% rownames(installed.packages()) == FALSE) 	{BiocManager::install("GENESIS",suppressUpdates=noupdates)}	# for relatedness
			}else{
			source("http://bioconductor.org/biocLite.R")
			if("qvalue" %in% rownames(installed.packages()) == FALSE) 	{biocLite("qvalue",suppressUpdates=noupdates)}					# for selection analysis OUTFLANK  
			if("gdsfmt" %in% rownames(installed.packages()) == FALSE) 	{biocLite("gdsfmt",suppressUpdates=noupdates)}					# for PCA analysis SNPRelate
			if("SNPRelate" %in% rownames(installed.packages()) == FALSE){biocLite("SNPRelate",suppressUpdates=noupdates)}				# for PCA analysis SNPRelate
			if("LEA" %in% rownames(installed.packages()) == FALSE) 		{biocLite("LEA")}												# for PCA analysis LEA as well as structure analysis
			#if("DNAcopy" %in% rownames(installed.packages()) == FALSE) {biocLite("DNAcopy")}											# for Genesis
			#if("GENESIS" %in% rownames(installed.packages()) == FALSE) {biocLite("GENESIS")}		# for relatedness (PCrelate function)
			}
		}else{
		cat("All required Bioconductor packages already installed.",sep="\n")
		}
	# from github:
	mysoftwares	<- c("OutFLANK")
	for (i in c(1:length(mysoftwares)))
		{
		myvector[i]	<- !(mysoftwares[i] %in% rownames(installed.packages()))
		}
	if(any(myvector))
		{
		library(devtools)
		if("OutFLANK" %in% rownames(installed.packages()) == FALSE) {install_github("whitlock/OutFLANK")}							# for selection analysis OUTFLANK 
		#if("CubSFS" %in% rownames(installed.packages()) == FALSE) {install_github("blwaltoft/CubSFS")}								# this doesn't work, should be installed from source.
		}else{
		cat("All required github packages already installed.",sep="\n")
		}
	# load libraries:
	library(car)
	library(curl)
	library(colorspace)
	library(ape)
	library(adegenet)
	library(StAMPP)
	library(parallel)
	library(scatterplot3d)																										# DAPC
	library(plot3D)																												# DAPC
	library(zoo)
	library(devtools) 
	library(vioplot)
	library(gplots)
	library(RColorBrewer)
	library(migest)																												# circosplot
	library(plyr)																												# circosplot
	library(circlize)																											# circosplot
	library(SNPRelate)
	library(LEA)	
	library(qvalue)
	library(OutFLANK) 
	library(pcadapt)
	library(grid)
	library(gridGraphics)
	library(gridExtra)
	library(MASS)
	library(poppr)
	library(car)
	library(FactoMineR)
	library(factoextra)
	library(rworldmap)
	library(mapplots)
	library(VennDiagram)
	library(fsthet)
	library(PopGenome)
	library(bibtex)
	#library(Demerelate)
	#library(synbreed)
	#library(DNAcopy)
	#library(GENESIS)
	cat("All packages loaded.",sep="\n")
	getversions()
	}
	
# import biallelic data from PLINK raw format:
importdata<-function(inputprefix,sumstatsfile=FALSE,vcfsamplefile=NULL,geofile=NULL,depthfile=FALSE,poolsfile=NULL,namechars=10,colourvector=NULL,popcol_by_alphabetical_order_popname=TRUE,silent=TRUE)
	{
	cat("Importing data from the directory:",sep="\n")
	cat(getwd(),sep="\n")
	if(!"adegenet"%in%(.packages()))
		{
		return(cat("ERROR: 'adegenet' package has not been installed and/or loaded yet. Did you run the getpackages() function?",sep="\n"))
		}
	if(!file.exists(paste(inputprefix,"raw",sep=".")))
		{
		cat(paste("ERROR: SambaR couldn't find a file called '",inputprefix,".raw' in the working directory.",sep=""),sep="\n")
		cat("Did you set the right working directory using the setwd() function?",sep="\n")
		cat("And did you run PLINK to convert PED/MAP to RAW/BIM files?",sep="\n") 
		return(cat("See manual for further details.",sep="\n"))
		}
	if(!file.exists(paste(inputprefix,"bim",sep=".")))
		{
		cat(paste("ERROR: SambaR couldn't find a file called '",inputprefix,".bim' in the working directory.",sep=""),sep="\n")
		cat("Did you set the right working directory using the setwd() function?",sep="\n")
		cat("And did you run PLINK to convert PED/MAP to RAW/BIM files?",sep="\n") 
		return(cat("See manual for further details.",sep="\n"))
		}
	if(sumstatsfile)
		{
		if(!file.exists("sumstats.tsv"))
			{
			cat("ERROR: SambaR couldn't find a file called 'sumstats.tsv' in the working directory.",sep="\n")
			return(cat("Either set the flag sumstatsfile to FALSE or make sure the file 'sumstats.tsv' is present (see manual for further details).",sep="\n"))
			}
		}
	if(!is.null(vcfsamplefile))
		{
		if(!file.exists(vcfsamplefile))
			{
			cat(paste("ERROR: SambaR couldn't find a file called",vcfsamplefile,"in the working directory.",sep=" "),sep="\n")
			return(cat("Either set the flag vcfsamplefile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
			}
		}
	if(!is.null(geofile))
		{
		if(!file.exists(geofile))
			{
			cat(paste("ERROR: SambaR couldn't find a file called",geofile,"in the working directory.",sep=" "),sep="\n")
			return(cat("Either set the flag geofile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
			}
		}
	if(!is.null(poolsfile))
		{
		if(!file.exists(poolsfile))
			{
			cat(paste("ERROR: SambaR couldn't find a file called",poolsfile,"in the working directory.",sep=" "),sep="\n")
			return(cat("Either set the flag poolsfile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
			}
		}
	if(depthfile)
		{
		if(!file.exists("out.idepth"))
			{
			cat("ERROR: SambaR couldn't find a file called 'out.idepth' in the working directory.",sep="\n")
			return(cat("Either set the flag depthfile to FALSE or make sure the file 'out.idepth' is present. See manual for more details.",sep="\n"))
			}
		if(!file.exists("out.ldepth.mean"))
			{
			cat("ERROR: SambaR couldn't find a file called 'out.ldepth.mean' in the working directory.",sep="\n")
			return(cat("Either set the flag depthfile to FALSE or make sure the file 'out.ldepth.mean' is present. See manual for more details.",sep="\n"))
			}
		}
	#
	# define colours:
	if(is.null(colourvector))
		{
		colourvector	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","deepskyblue","greenyellow","indianred1","gray20")
		}
	mysambarcolours		<- colourvector
	#
	# create genlight:
	mygenlight 			<<- read.PLINK((paste(inputprefix,"raw",sep=".",collapse = NULL)),parallel=FALSE)
	if(any(grepl("_",pop(mygenlight))))
		{
		return(cat("ERROR: SambaR does not accept population names which contain an underscore.\nPlease edit population names and try again.",sep="\n"))	
		}
	#
	# create snps dataframe:
	cat("Creating snps dataframe...",sep="\n")
	snps 				<<- read.table((paste(inputprefix,"bim",sep=".",collapse = NULL)))
	colnames(snps) 		<<- c("chr","name","morgan","pos","minor","major")
	snps$genlightname	<<- colnames(as.matrix(mygenlight))
	if(any(snps$minor=="0"))
		{
		monofilter	<- snps$minor=="0"
		nmono		<- length(monofilter[monofilter])
		nloci		<- nrow(snps)
		cat(paste("WARNING: ",nmono," non-polymorphic loci (out of ",nloci," loci) present in inputfile. SambaR will ignore them.",sep=""),sep="\n")
		monolist	<- snps$name[monofilter]
		write.table(monolist,"nonpolymorphicloci.txt",row.names=FALSE,col.names=FALSE,quote=FALSE)
		cat("A file called 'nonpolymorphicloci.txt' has been written to the working directory.",sep="\n")
		}
	if(!sumstatsfile&!any(snps$chr!=0))	# if no info in first column
		{
		if(any(snps$pos!=0))			# if info in the fourth column	
			{
			cat("ERROR: The input bim file has zero's only in the first column (contig) but non-zero's in the fourth column (position).",sep="\n")	
			cat("Either both columns should contain zero's (i.e. denovo snpcalling) or both columns should contain non-zero's (i.e. refmap snpcalling).",sep="\n")
			cat("As mentioned in the SambaR manual, if you convert from vcf to PED/MAP format, the first column of your map file will likely contain zero's only.",sep="\n") 
			cat("To solve that problem, you can execute the following command on the Linux command line (and afterwards convert again to raw/bim):",sep="\n")
			cat("cut -f2 yourfile.map | cut -f1 -d ':' > mycontigs.txt && cut -f2,3,4 yourfile.map > mymap.txt && paste mycontigs.txt mymap.txt > yourfile.map && rm mycontigs.txt mymap.txt",sep="\n")   
			cat("Alternatively, if the map file does have non-zero's in the the first column, then something went wrong during the conversion from ped/map to raw/bim (see SambaR manual).",sep="\n")
			cat("If so, try redoing the conversion (using PLINK, see Sambar manual), or edit the first and fourth column in the input bim file yourself (e.g. in Excel).",sep="\n")
			}else{
			cat("WARNING: No positional information found in first and fourth column of bim file (i.e. zero's only).",sep="\n")
			cat("If you generated your SNP data with a denovo pipeline, this is correct.",sep="\n")
			cat("If you generated your SNP data with a refmap pipeline, then why is this information lacking?",sep="\n")
			}
		}
	myposmax	<- max(snps$pos)
	if(!sumstatsfile&any(snps$chr!=0)&myposmax<500)
		{
		cat(paste("WARNING: According to information in map-file, the snps are positioned at maximum",myposmax,"bp.",sep=" "),sep="\n")
		cat("Hence, SambaR will assume that the information in the second column of your mapfile refers to read positions rather than contig/chromosome positions.",sep="\n")	
		}
	snps$nr 					<<- 1:nrow(snps)
	snps$minor[snps$minor==0]	<<- NA	# In case data is non-polymorphic
	if(is.integer(snps$minor))
		{
		snps$minor2										<<- NA
		snps$minor2[snps$minor==1&!is.na(snps$minor)]	<<- "A"
		snps$minor2[snps$minor==2&!is.na(snps$minor)]	<<- "C"
		snps$minor2[snps$minor==3&!is.na(snps$minor)]	<<- "G"
		snps$minor2[snps$minor==4&!is.na(snps$minor)]	<<- "T"
		}else{		# if in bim-file data is encoded as A,C,G,T rather than 1,2,3,4.
		snps$minor2					<<- snps$minor
		snps$minor					<<- NA
		snps$minor[snps$minor2=="A"&!is.na(snps$minor2)]<<- 1
		snps$minor[snps$minor2=="C"&!is.na(snps$minor2)]<<- 2
		snps$minor[snps$minor2=="G"&!is.na(snps$minor2)]<<- 3
		snps$minor[snps$minor2=="T"&!is.na(snps$minor2)]<<- 4
		}
	if(is.integer(snps$major))
		{
		snps$major2										<<- NA
		snps$major2[snps$major==1&!is.na(snps$major)]	<<- "A"
		snps$major2[snps$major==2&!is.na(snps$major)]	<<- "C"
		snps$major2[snps$major==3&!is.na(snps$major)]	<<- "G"
		snps$major2[snps$major==4&!is.na(snps$major)]	<<- "T"
		}else{		# if in bim-file data is encoded as A,C,G,T rather than 1,2,3,4.
		snps$major2										<<- snps$major
		snps$major										<<- NA
		snps$major[snps$major2=="A"&!is.na(snps$major2)]<<- 1
		snps$major[snps$major2=="C"&!is.na(snps$major2)]<<- 2
		snps$major[snps$major2=="G"&!is.na(snps$major2)]<<- 3
		snps$major[snps$major2=="T"&!is.na(snps$major2)]<<- 4
		}
	snps$poly			<<- ifelse(is.na(snps$minor),FALSE,TRUE)
	#
	# create inds dataframe:
	cat("Creating inds dataframe...",sep="\n")
	inds      			<<- as.data.frame(cbind(nr=1:nInd(mygenlight),name=indNames(mygenlight),pop=pop(mygenlight)))
	inds$nr 			<<- 1:nrow(inds)
	inds$pop  			<<- pop(mygenlight)
	inds$pop2			<<- inds$pop		# 08_11_2018: redundant column. Can go once every function calls inds$pop rather than inds$pop2 
	#	
	# in case there are duplicated sample names, we changes names to Ind1, Ind2, etc.
	if(length(unique(inds$name))<nrow(inds))
		{
		cat("Warning: duplicate sample names found. Sambar changes sample names to Ind1, Ind2, etc.",sep="\n")
		inds$name		<<- paste("Ind",c(1:nrow(inds)),sep="")
		indNames(mygenlight)<<- inds$name
		}
	# reorder inds dataframe:
	inds$sample_nr		<<- c(1:nrow(inds))				# this info is needed ro reorder data in mygenlight (in case not yet ordered by samplename)
	inds				<<- inds[order(inds$name),]
	# reorder mygenlight data (in case just not yet ordered by samplename):
	mymatrix			<- as.matrix(mygenlight)
	mymatrix			<- mymatrix[inds$sample_nr,]
	mygenlight			<<- as.genlight(mymatrix)
	pop(mygenlight)		<<- inds$pop
	inds$sample_nr		<<- NULL
	inds$nr				<<- NULL
	inds$nr				<<- c(1:nrow(inds))
	rownames(inds)		<<- inds$nr
	#
	# if ped file is generated from vcf file, population assignment is extracted from additional input file (vcfsamplefile):
	if(!is.null(vcfsamplefile))
		{
		cat("Extracting information from vcf sample file...",sep="\n")
		vcfinput		<- read.table(vcfsamplefile,header=FALSE)
		colnames(vcfinput)<- c("name","pop")
		# reorder vcf-file:
		vcfinput		<- vcfinput[order(vcfinput$name),]
		# now extract information:
		if(any(!as.vector(vcfinput$name)==as.vector(inds$name)))
			{
			return(cat("ERROR: Sample names in vcfinput file do not correspond with names in inds dataset.",sep="\n"))
			}
		inds$pop		<<- vcfinput$pop
		inds$pop2		<<- inds$pop		# 08_11_2018: this column can go once every function calls inds$pop rather than inds$pop2 
		# assign population labels to genlight object:
		mygenlight@pop	<<- as.factor(inds$pop)
		}
	# in case number of populations equals number of samples, we set number of populations to 1:
	nuniqpop		<- length(unique(inds$pop))
	if(nuniqpop==nrow(inds))
		{
		cat("Warning: number of populations equals number of samples.",sep="\n") 
		cat(paste("Number of populations:",nuniqpop,sep=" "),sep="\n")
		cat(paste("Number of individuals:",nrow(inds),sep=" "),sep="\n")
		cat("Did you maybe switch the first two columns of the PED-file?",sep="\n")
		cat("Or did you generate the PED/MAP file from a vcf file and forget to provide the name of the sample file to the vcfsamplefile flag?",sep="\n")
		cat("Because Sambar does not accept that all samples belong to different populations, Sambar will assign all samples to 1 population.",sep="\n")
		inds$pop  		<<- "Pop1"
		pop(mygenlight)	<<- inds$pop
		inds$pop2		<<- inds$pop
		}
	# assign population colours:
	cat("Assigning population colours...",sep="\n")
	populations			<- as.vector(unique(pop(mygenlight)))
	ncolours			<- length(mysambarcolours)
	npops				<- length(populations)
	if(ncolours<npops)
		{
		cat(paste("ERROR: Currently more populations (",npops,") defined than popcolours (",ncolours,").",sep=""),sep="\n")
		return(cat("Provide a (longer) vector with colours to the colourvector argument.",sep="\n"))
		}
	colvector			<- mysambarcolours[1:length(populations)] 
	if(popcol_by_alphabetical_order_popname)
		{
		# assign colours in alphabetical order of population names (e.g.: Apop gets colour1, Bpop gets colour2, etc)
		populations			<- popNames(mygenlight) 
		inds$popcol			<<- colvector[as.factor(inds$pop)]	
		}else{
		# assign colours in order of occurence of populations in datasets. (e.g. Apop, Cpop, Bpop would result in Cpop being assigned colour2)
		populations			<- as.vector(unique(pop(mygenlight)))	
		inds$popcol			<<- NA
		for (i in (1:(length(populations))))
			{
			for (j in (1:nrow(inds)))
				{
				if (inds$pop[j]==populations[i])
					{
					inds$popcol[j] <<- colvector[i]
					}
				}
			}
		}
	symbolvector	<- c(15,16,17,18,0,1,2,6,3,4,5,8)
	inds$symboltype	<<- symbolvector[as.factor(inds$pop)]
	# optionally add additional information to snps dataframe:
	if(sumstatsfile)
		{
		# positional information can be derived either from map file or from sumstats file.
		cat("Extracting information from STACKS sumstats file...",sep="\n")
		#chrom			<- read.table("sumstats.tsv",skip=(length(populations)+1),header=FALSE)
		chrom			<- read.table("sumstats.tsv",comment.char="#",header=FALSE)		# this way users can import sumstats file even if using a different number of populations then when running STACKS
		if(length(unique(chrom[,1]))==1)		# if old sumstats version which lists batch number in first column
			{
			chrom			<- chrom[,c(2:5)]
			}else{
			chrom			<- chrom[,c(1:4)]
			}
		colnames(chrom)	<- c("Stack_ID","Chromosome","ChromBasepair","StackBasepair")
		chrom$name		<- paste(chrom$Stack_ID,chrom$StackBasepair,sep="_")
		chrom			<- unique(chrom)			# filter out redundant information (multiple lines per site, one for each population)
		chrom			<<- chrom
		if(nrow(chrom)!=nrow(snps))
			{
			cat("WARNING: Number of loci in sumstatsfile does not agree with number of loci in PED/MAP file.",sep="\n")
			cat(paste("Number of snps in PED/MAP file: ",nrow(snps),".",sep=""),sep="\n")
			cat(paste("Number of loci in sumstats file: ",nrow(chrom),".",sep=""),sep="\n")
			if(nrow(chrom)!=nrow(snps))
				{
				cat("SambaR will ignore loci in the sumstatsfile which are not present in the PED/MAP file.",sep="\n")
				ignoredloci	<- chrom$name[which(!chrom$name%in%snps$name)]
				write.table(ignoredloci,"sumstatsfile.ignoredloci.txt",row.names=FALSE,col.names=FALSE,quote=FALSE)
				cat("The names of these loci are exported to a file called 'sumstatsfile.ignoredloci.txt'.",sep="\n")
				}
			for (i in c(1:nrow(snps)))		# Not the fastest option. Maybe use merge instead?
				{
				mylocus			<- snps$name[i]
				snps$chr[i]		<<- chrom$Chromosome[chrom$name==mylocus]
				snps$pos[i]		<<- chrom$ChromBasepair[chrom$name==mylocus]
				snps$stackID[i]	<<- chrom$Stack_ID[chrom$name==mylocus]
				snps$stackbp[i]	<<- chrom$StackBasepair[chrom$name==mylocus]
				}
			}else{
			snpstemp	<- snps[order(snps$name),]
			chrom		<- chrom[order(chrom$name),]
			# Second reorder the data in the genlight object:
			mymatrix		<- as.matrix(mygenlight[,order(snps$name)])
			mygenlight		<<- as.genlight(mymatrix)	
			mygenlight@pop	<<- as.factor(inds$pop)
			snps			<<- snpstemp
			if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
				{	
				return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
				}	
			if(any(chrom$name!=snps$name))
				{
				return(cat("ERROR: SNP names in snps dataframe do not correspond with SNP names in sumstats file.",sep="\n"))
				}else{
				snps_test		<<- snps
				chrom_test		<<- chrom
				snps$chr		<<- chrom$Chromosome
				snps$pos		<<- chrom$ChromBasepair
				snps$stackID	<<- chrom$Stack_ID
				snps$stackbp	<<- chrom$StackBasepair
				snps_test2		<<- snps
				}
			}
		snps$readpos	<<- as.numeric(sub(".*_", "",snps$name))			# Note: this function assumes that name of snp indicates position of SNP on stacks data. This is not always true.
		}else{
		snps$readpos	<<- NA
		}
	if(any(snps$pos!=0)&any(snps$pos>=500)) 
		{
		## REFMAP:
		snps$name2		<<- paste(snps$chr,snps$pos,sep="_")
		# Are snps located on chromosomes or on unplaced contigs?
		chr(mygenlight) <<- snps$chr
		snps$placed		<<- !(grepl("\\.",snps$chr))	# This is assuming that the names of unplaced contigs contain a dot, wheras chromosomes do not
		snps$autosomal	<<- (!(grepl("\\.",snps$chr)))&snps$chr!="X"
		### Reorder the snps to the order they occur in the genome:
		# First reorder the snps dataframe:
		snpstemp		<- snps
		snps			<<- snpstemp[order(snpstemp$chr,snpstemp$pos),]
		# Second reorder the data in the genlight object:
		mymatrix		<- as.matrix(mygenlight[,order(snpstemp$chr,snpstemp$pos)])
		mygenlight		<<- as.genlight(mymatrix)
		### Spacing between snps:
		new_chr			<- (as.vector(snps$chr))!=c(as.vector(snps$chr[2:length(snps$chr)]),as.factor("dummy"))
		new_chr			<- c(TRUE,new_chr[1:(length(new_chr)-1)])
		mydist			<- c(as.vector(snps$pos[2:length(snps$pos)]),NA)-snps$pos
		mydist			<- c(NA,mydist[1:(length(mydist)-1)])
		mydist[new_chr]	<- NA
		snps$dist		<<- as.numeric(mydist)
		snps$dist2		<<- !(is.na(snps$dist))
		# Are snps on same position? (STACKS sometimes outputs two snps which are in fact on same position within genome)
		snps$samepos	<<- (duplicated(snps$name2,fromLast=FALSE))|(duplicated(snps$name2,fromLast=TRUE))
		snps$uniqpos	<<- !(snps$samepos)
		}else{
		# output from DENOVO pipeline, or from PyRAD pipeline (which returns read pos rather than chromosome/contig pos):
		snps$uniqpos	<<- TRUE
		snps$samepos	<<- FALSE
		# reorder the snps dataframe:
		snpstemp		<- snps
		snps			<<- snpstemp[order(snpstemp$name),]		# if denovo, we order on name, rather than on position.
		# Second reorder the data in the genlight object:
		mymatrix		<- as.matrix(mygenlight[,order(snpstemp$name)])
		mygenlight		<<- as.genlight(mymatrix)
		}
	# optionally add additional information to snps and inds dataframe about read depth:
	if(depthfile)
		{
		cat("Extracting read depth information...",sep="\n")
		snps$chr		<<- tolower(as.character(snps$chr))
		depth1			<- read.table("out.idepth",header=TRUE)
		depth2			<- read.table("out.ldepth.mean",header=TRUE)
		depth1			<- depth1[order(depth1$INDV),]
		depth2			<- depth2[order(as.factor(depth2$CHROM),as.numeric(depth2$POS)),]
		if((nrow(inds)!=nrow(depth1))|(any(inds$name!=depth1$INDV)))
			{
			cat("ERROR: Some individuals listed in PED file are not listed in out.idepth file.",sep="\n")
			cat("Sample names need to be identical (including upper/lower case).",sep="\n")
			return(cat("Make sure that sample names correspond or set depthfile to FALSE."))
			}
		inds$meandepth	<<- depth1$MEAN_DEPTH
		if(nrow(snps)==nrow(depth2))
			{
			if(!silent){cat("nsnps == nrow(depth2)",sep="\n")}
			snps$meandepth	<<- depth2$MEAN_DEPTH
			if(!silent){cat("Added depth info.",sep="\n")}
			}else{
			cat(paste("WARNING: The number of snps in out.ldepth.mean file (",nrow(depth2),") is not the same as number of snps in ped file (",nrow(snps),").",sep=""),"\n")
			cat("This can arise from glitches in the SNP calling pipeline or file conversion.",sep="\n")
			cat("SambaR will ignore sites in out.ldepth.mean file which are not present in ped file.",sep="\n")
			snps$chr_pos	<<- paste(snps$chr,snps$pos,sep="_")
			snpstemp		<- snps[snps$uniqpos,]
			snpsdup			<- snps[snps$samepos,]
			nsnpsdup		<- length(unique(snpsdup$chr_pos))
			if(nsnpsdup>0)
				{
				snpsdup$MEAN_DEPTH 	<- NA
				snpsdup$VAR_DEPTH 	<- NA	
				snpsdup$dup			<- TRUE
				cat(paste("Found",nsnpsdup,"duplicated snp(s) in snps dataset. Marked as TRUE in snps$samepos column.",sep=" "),sep="\n")
				}
			depth2$CHROM	<- tolower(as.character(depth2$CHROM))
			depth2$POS		<- as.character(depth2$POS)
			depth2$chr_pos	<- paste(depth2$CHROM,depth2$POS,sep="_")
			temp			<- depth2[order(depth2$chr_pos),]
			temp$dup		<- (duplicated(temp$chr_pos,fromLast=FALSE))|(duplicated(temp$chr_pos,fromLast=TRUE))
			ndup			<- length(unique(temp$chr_pos[temp$dup]))
			if(ndup>0)
				{
				cat(paste("Found",ndup,"duplicated snp(s) in out.ldepth.mean file. SambaR will ignore this/these site(s).",sep=" "),sep="\n")
				}
			depth2			<- temp[order(as.factor(temp$CHROM),as.numeric(temp$POS)),]
			depth2temp		<- depth2[!depth2$dup,]
			combitemp		<- merge(x=snpstemp, y=depth2temp, by="chr_pos", all=TRUE)
			combitemp2		<- combitemp[!is.na(combitemp$chr),]
			combitemp2$CHROM<- NULL
			combitemp2$POS	<- NULL
			if(nsnpsdup>0)
				{
				combitemp3		<- rbind(combitemp2,snpsdup)
				}else{
				combitemp3		<- combitemp2
				}
			snps			<<- combitemp3[order(combitemp3$chr,combitemp3$pos),]
			colnames(snps)[which(colnames(snps)=="MEAN_DEPTH")]	<<- "meandepth" 
			}
		if(!silent){cat("Adding depth info.",sep="\n")}
		temp			<- snps$meandepth[snps$meandepth<quantile(snps$meandepth,0.995,na.rm=TRUE)]
		mythreshold		<- qnorm((1-0.05/length(snps$meandepth)), mean = mean(temp,na.rm=TRUE), sd = sd(temp,na.rm=TRUE), lower.tail = TRUE, log.p = FALSE)
		mythreshold		<<- mythreshold
		snps$depthfilter<<- snps$meandepth<mythreshold
		if(!silent){cat("Added depth filter.",sep="\n")}
		}else{
		snps$depthfilter<<- TRUE
		}	
	if(!silent){cat("End of sumstatsfile section.",sep="\n")}
	# optionally add longitude and latitude information to inds dataframe:
	if(!is.null(geofile))
		{
		if(!file.exists(geofile))
			{
			cat(paste("ERROR: could not find file:",geofile,sep=" ",sep="\n"))
			return(cat("Check the name of the file and whether you stored it in the right directory.",sep="\n"))
			}
		cat("Adding geographical coordinates to inds dataframe...",sep="\n")
		mygeo			<- read.table(geofile,header=TRUE)
		if(any(!(c("sample","longitude","latitude")%in%colnames(mygeo))))
			{
			return(cat("ERROR: geofile should contain columns named 'sample', 'longitude' and 'latitude'.",sep="\n"))
			}
		mygeo			<- mygeo[order(mygeo$sample),]
		if(any(!as.vector(mygeo$sample)==as.vector(inds$name)))
			{
			cat("WARNING: Sample names in geofile do not correspond with names in inds dataset. SambaR will not add geographical coordinates.",sep="\n")
			mygeo			<<- mygeo
			cat("To view the sample names in geofile, type: 'mygeo$sample'.",sep="\n")
			cat("To view the sample names in inds dataset, type: 'inds$name'.",sep="\n")
			}else{
			inds$longitude	<<- mygeo$longitude
			inds$latitude	<<- mygeo$latitude
			}
		}
	# optionally add pool information to inds dataframe:
	if(!is.null(poolsfile))
		{
		if(!silent){cat("Adding pool information.",sep="\n")}
		mypools	<- read.table(poolsfile,header=TRUE)
		mypools	<- mypools[order(mypools$sample),]
		if(any(!mypools$sample==inds$name))
			{
			cat("WARNING: Sample names in poolsinfo file do not correspond with names in inds dataset. SambaR will not add pool info.",sep="\n")
			}else{
			inds$pool	<<- mypools$pool
			}
		}
	# a short name:
	inds$name2			<<- NA
	if(grepl(".",as.vector(inds$name[1])))
		{
		for (i in c(1:nrow(inds)))
			{
			inds$name2[i]	<<- strsplit(as.vector(inds$name[i]), "[.]")[[1]][1]
			}
		}else{
		inds$name2			<<- substr(inds$name,start=1,stop=namechars)
		}
		# set plot font:
	#
	if(sumstatsfile)
		{
		if(!silent){cat("selection unique rows",sep="\n")}
		# 18042019: For some reason the output is incorrect if I include this line in sumstatsfile section.
		# Is snps on same stack (sequencing read) as previous snp?
		snps$sameread	<<- (duplicated(snps$stackID,fromLast=FALSE))
		}
	### create SambaR directories:
	cat("Creating output directories...",sep="\n")
	inputdatadir		<- getwd()
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambar		<<- list()
	mysambar[[1]]	<<- populations
	mysambar[[5]]	<<- inputdatadir
	mysambar[[6]]	<<- sambardir
	mysambar[[7]]	<<- QCdir
	mysambar[[8]]	<<- structuredir
	mysambar[[9]]	<<- divergencedir
	mysambar[[10]]	<<- diversitydir
	mysambar[[11]]	<<- demographydir
	mysambar[[12]]	<<- selectiondir
	mysambar[[13]]	<<- inputfilesdir
	mysambar[[14]]	<<- "sans"
	if(popcol_by_alphabetical_order_popname)
		{
		mysambar[[17]]	<<- mysambarcolours[order(populations)]
		}else{
		mysambar[[17]]	<<- mysambarcolours
		}
	mysambar[[18]]	<<- geomapsdir
	names(mysambar)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	# check:
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: row names of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	# cat("Removing snps which are on the same position...")
	posfilter		<- snps$samepos
	if(any(posfilter))
		{
		removedloci		<- snps[posfilter,c("name","chr","pos","readpos")]		# this loci will give problems down the line when merging datasets.
		write.table(removedloci,"removedloci.txt",row.names=FALSE,col.names=TRUE,quote=FALSE)	
		snps			<<- snps[!posfilter,]
		mymatrix		<- as.matrix(mygenlight)
		mymatrix		<- mymatrix[,!posfilter]
		mygenlight		<<- as.genlight(mymatrix)
		cat(paste("Removed",nrow(removedloci),"snps which share the same position in the genome. The names of these loci are listed in a file called removedloci.txt.",sep=" "),sep="\n")
		}
	#
	# export information for individuals:
	setwd(mysambar$sambardir)
	cat("Exporting sample information...",sep="\n")
	indstable	<- inds[,c("name","nr","pop","popcol")]
	write.table(indstable,"SambaR_samples.txt",row.names=FALSE,sep="\t",quote=FALSE)
	#
	cat("Exporting citations of the R packages...",sep="\n")
	getcitations()
	cat("DATA SUCCESFULLY IMPORTED.",sep="\n")
	cat("The data is stored in 'mygenlight'. For an overview, type on the command line: 'mygenlight'.",sep="\n") 
	cat("You can observe a subset of the data by typing: as.matrix(mygenlight[1:10,1:10]).",sep="\n")
	cat("Locus information is and will be stored in an object called 'snps'. You can observe the first ten lines by typing: head(snps,10). Or type: fix(snps).",sep="\n")
	cat("Sample information is and will be stored in an object called 'inds'. You can observe the first ten lines by typing: head(inds,10). Or type: fix(inds).",sep="\n")
	cat("Sample information (including population colours and sample numbers) is also exported to a file called 'SambaR_samples.txt', which you can find in your SambaR directory.",sep="\n")
	}

addgeofile<-function(geofile=NULL)
	{
	if(is.null(geofile))
		{
		return(cat("Error: provide input to geofile flag.",sep="\n"))
		}else{
		cat("Looking for input file in the following directory:",sep="\n")
		cat(mysambar$inputdatadir,sep="\n")
		setwd(mysambar$inputdatadir)
		cat("Adding geographical coordinates to inds dataframe...",sep="\n")
		mygeo			<- read.table(geofile,header=TRUE)
		if(any(!(c("sample","longitude","latitude")%in%colnames(mygeo))))
			{
			return(cat("ERROR: geofile should contain columns named 'sample', 'longitude' and 'latitude'.",sep="\n"))
			}
		mygeo			<- mygeo[order(mygeo$sample),]
		inds$longitude	<<- mygeo$longitude
		inds$latitude	<<- mygeo$latitude
		}
	}

addsampleinfo<-function(samplefile="sample_info.txt",filteronly=TRUE)
	{
	if(is.null(samplefile))
		{
		return(cat("Error: provide input to samplefile flag.",sep="\n"))
		}else{
		cat("Looking for input file in the following directory:",sep="\n")
		cat(mysambar$inputdatadir,sep="\n")
		setwd(mysambar$inputdatadir)
		myinfo			<<- read.table(samplefile,header=TRUE)
		if(!"name"%in%colnames(myinfo))
			{
			return(cat("ERROR: sample info file should contain a column named 'name'.",sep="\n"))
			}
		myinfo		<- myinfo[order(myinfo$name),]
		if(filteronly)
			{
			indsretained<- inds[inds$filter,]
			}else{
			indsretained<- inds
			}
		indsretained<- indsretained[order(indsretained$name),]
		if(nrow(myinfo)!=nrow(indsretained))
			{
			if(filteronly)
				{
				return(cat("ERROR: number of samples in sample info does not correspond with number of retained individuals in inds dataframe.",sep="\n"))	
				}else{
				return(cat("ERROR: number of samples in sample info does not correspond with number of individuals in inds dataframe.",sep="\n"))	
				}
			}
		if(any(!as.character(myinfo$name)==as.character(indsretained$name)[indsretained$filter]))
			{
			return(cat("ERROR: sample names in sample info file do not correspond with inds$name column.",sep="\n"))	
			}
		if(length(present_in_inds[!present_in_inds])==1)
			{
			return(cat("Column names within sample info file already present in inds data frame.",sep="\n"))	
			}
		indstemp	<- indstemp[,!present_in_inds]
		indstemp	<- merge(inds,myinfo,all=TRUE,by="name")
		indstemp	<- indstemp[order(indstemp$name),]
		if(any(!row.names(as.matrix(mygenlight))==as.vector(indstemp$name)))
			{
			return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
			}
		inds		<<- indstemp
		cat("Information added to the inds dataframe.",sep="\n")
		}
	}	
		
# function to add a second population structure (columns 'inds$subpop' and 'inds$subpopcol'):	
addpop<-function(samplefile=NULL,mycolours=c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1"))
	{
	if(is.null(samplefile))
		{
		return(cat("ERROR: Provide an input file to samplefile flag."),sep="\n")
		}
	# cat("Extracting information from sample file...",sep="\n")
	popinput			<- read.table(samplefile,header=FALSE)
	colnames(popinput)	<- c("name","pop")
	# reorder vcf-file:
	popinput			<- popinput[order(popinput$name),]
	# now extract information:
	inds$subpop			<<- popinput$pop
	#
	# add colours:
	mypops				<- as.vector(unique(inds$subpop))
	colvector			<- mycolours[1:length(mypops)] 
	inds$subpopcol		<<- colvector[as.factor(inds$subpop)]
	# add to mysambar list:
	mysambar$subpop		<<- mypops[order(mypops)]
	mysambar$subpopcol	<<- mycolours
	cat("Columns 'subpop' and 'subpopcol' added to inds dataframe.",sep="\n")
	cat("Vectors 'subpop' and 'subpopcol' added to mysambar list.",sep="\n")
	}

# function to redefine population assignment:	
replacepop<-function(samplefile=NULL,mycolours=c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1"))
	{
	if(is.null(samplefile))
		{
		return(cat("ERROR: Provide an input file to samplefile flag."),sep="\n")
		}
	setwd(mysambar$inputdatadir)
	if(!file.exists(vcfsamplefile))
		{
		cat(paste("ERROR: SambaR couldn't find a file called",vcfsamplefile,"in the directory:",sep=" "),sep="\n")
		cat(getwd(),sep="\n")
		return(cat("Either set the flag vcfsamplefile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
		}
	# cat("Extracting information from sample file...",sep="\n")
	popinput			<- read.table(samplefile,header=FALSE)
	colnames(popinput)	<- c("name","pop")
	# reorder vcf-file:
	popinput			<- popinput[order(popinput$name),]
	if(any(!as.vector(popinput$name)==as.vector(inds$name)))
		{
		return(cat("ERROR: Sample names in vcfinput file do not correspond with names in inds dataset.",sep="\n"))
		}
	mypops			<- as.vector(unique(popinput$pop))
	mypops			<- mypops[order(mypops)]
	if(length(mypops)>length(mycolours))
		{
		return(cat("ERROR: Number of populations exceeds number of colours. Provide a vector with colour names to the 'mycolours' argument.",sep="\n"))
		}
	# now extract information:
	inds$pop		<<- popinput$pop
	inds$pop2		<<- inds$pop
	#
	# add colours:
	inds$popcol		<- mycolours[1:length(mypops)] 
	inds$popcol		<<- colvector[as.factor(inds$pop2)]
	# add to mysambar list:
	mysambar$populations<<- mypops[order(mypops)]
	mysambar$mycolours	<<- mycolours
	# add to genlight:
	mygenlight@pop		<<- as.factor(inds$pop)
	cat("Population assignment has been succesfully updated.",sep="\n")
	}

################ MULTI-ALLELIC DATA #################	
	
# import multiallelic data from structure format (using adegenet):
importmultidata<-function(structurefile="allsamples.stru",colourvector=c("red","green","blue","orange"))
	{
	mydata				<- read.table(structurefile)
	colnames(mydata)	<- c("name","pop")
	if(any(grepl("_",mydata$pop)))
		{
		return(cat("SambaR does not accept population names which contain an underscore.\nPlease edit population names and try again.",sep="\n"))	
		}
	nloc				<- (ncol(mydata)-2)/2
	nind				<- nrow(mydata)
	# create genlight object:
	mygenind			<- read.structure(structurefile,n.ind=nind,n.loc=nloc,onerowperind=TRUE,col.lab=1,col.pop=2,col.others=0,row.marknames=0)
	mygenind			<<- mygenind
	mymatrix			<- as.matrix(mygenind@tab)
	mygenlight			<<- as.genlight(mymatrix)
	mygenlight@pop		<<- as.factor(mydata$pop)
	# create populations vector:
	populations			<<- as.vector(unique(mydata$pop))
	# create inds dataframe:
	inds 				<<- mydata[,c("name","pop")]
	inds$pop2			<<- inds$pop
	temp				<- as.factor(inds$pop)
	inds$popcol			<<- colourvector[temp]
	inds				<<- inds
	# create snps dataframe:
	snps				<<- as.data.frame(cbind(mygenlight@loc.names,mygenind@loc.fac,as.vector(unlist(mygenind@all.names))))
	colnames(snps)		<<- c("name","locus","allele")
	snps$nalleles		<<- as.vector(rep(mygenind@loc.n.all,mygenind@loc.n.all))
	nmissing			<- apply(mymatrix,2,function(x) length(x[is.na(x)])) # number of NA per allele
	snps$allelecount	<<- round(colSums(mymatrix))
	snps$nonmiss		<<- 2*nind-2*nmissing
	snps$allelefreq		<<- round(colSums(mymatrix)/(2*nind-2*nmissing),4)
	# calculate allelefreq per population:
	for (i in c(1:length(populations)))
		{
		mypop			<- populations[i]
		mypopmatrix		<- mymatrix[inds$pop2==mypop,]
		npopind			<- nrow(mypopmatrix)
		nmissing		<- apply(mypopmatrix,2,function(x) length(x[is.na(x)])) # number of NA per allele 
		snps$freqtemp	<<- round(colSums(mypopmatrix)/(2*npopind-2*nmissing),4)
		names(snps)[names(snps) == "freqtemp"] <<- paste("allelefreq",mypop,sep = "_")
		}
	# Print info on screen:
	cat("Created two dataframes called 'snps' and 'inds', as well as a genlight object called 'mygenlight'.",sep="\n")
	}

# correlation between multi allelic allele frequencies:
corrfrequencies<-function()
	{
	combitable	<- combn(populations,m=2)
	mycorr1		<- rep(NA,ncol(combitable))	# pearson
	mycorr2		<- rep(NA,ncol(combitable))	# spearman
	for (i in c(1:ncol(combitable)))
		{
		pop1	<- combitable[1,i]	
		freq1	<- snps[,names(snps)==paste("allelefreq",pop1,sep="_")]
		pop2	<- combitable[2,i]	
		freq2	<- snps[,names(snps)==paste("allelefreq",pop2,sep="_")]
		mycorr1[i]	<- cor(freq1,freq2,method="pearson")
		mycorr2[i]	<- cor(freq1,freq2,method="spearman")
		}
	mycorr						<<- rbind(combitable,mycorr1,mycorr2)
	b							<<- matrix(1,nrow=length(populations),ncol=length(populations))
	b[lower.tri(b, diag=FALSE)] <<- mycorr1
	b							<<- t(b)
	b[lower.tri(b, diag=FALSE)] <<- mycorr2
	colnames(b)				<<- populations
	rownames(b)				<<- populations
	}

# histogram of allele frequencies for multiallelic data:
allelefreqhisto<-function(export=FALSE)
	{
	# reorder:
	snpstemp	<- snps[order(as.integer((levels(snps$allele))),as.integer((levels(snps$allele)))),]
	if(export){pdf("Allelefrequencies.pdf",width=12,height=20)}
	par(mfrow=c(16,4),mar=c(3,0.5,0.5,0.5),oma=c(1,5,3,1),cex.axis=1.25,cex.lab=1,cex.main=1.5)
	for (j in (c(1:16)))
		{
		npop		<- length(populations)
		temp		<- snpstemp[snpstemp$locus==j,c(8:(8+npop-1))]
		myymax		<- max(temp)
		for (i in c(1:length(populations)))
			{
			mypop	<- populations[i]
			myfreq	<- snpstemp[,names(snpstemp)==paste("allelefreq",mypop,sep="_")]
			myyaxt	<- ifelse(i == 1,"s","n")
			barplot(myfreq[snpstemp$locus==j],las=2,names.arg=snpstemp$allele[snpstemp$locus==j],col=mypop,ylim=c(0,myymax),ylab="",yaxt=myyaxt)
			if(i == 1){mtext(paste("locus",j,sep=""),side=2,line=3.5,cex=1.5)}
			if(j == 1){mtext(mypop,side=3,line=0.25,cex=1.5)}
			}
		}
	if(export){dev.off()}
	}

# These plots are useless: there is no reason to expect correlation between Fst and Fis, other than when populations are wrongly defined. 
# maples plot for each population:
# locusspecific Fst (pairwise comparison) vs locusspecific Fis
# y-axis: Fis	(Hexp_pop-Hobs_pop)/Hexp_pop		# if true population (no substructure), Fis hovers around 0.   
# x-axis: Fst 	(Hexp_meta-Hobs_meta)Hexp_meta		# high if many homozygotes due to popstructure (e.g AA in pop1 and aa in pop2)	
# So flat plot if population has no substructure.
# If more than 2 populations, we have to select a pairwise population comparison for running the fst analysis.  

# for snps (binned):
waples_snps<-function(mysteps=0.05,mypop=snps$F_Busen,myfst=snps$WeirFst_Busen_Norway)
	{
	mybreaks		<- seq(0,1,mysteps)
	myhalf			<- mysteps/2
	myselection		<- is.finite(mypop)
	mylabels		<- seq(myhalf,1-myhalf,mysteps)
	fstbins			<- cut(myfst[myselection],mybreaks)
	fisperbin		<- aggregate(mypop[myselection], by=list(fstbins),FUN=mean) 
	nperbin			<- aggregate(mypop[myselection], by=list(fstbins),FUN=length)
	nbins			<- nrow(fisperbin)
	ndata			<- nperbin$x
	mylabels2		<- mylabels[1:nbins]
	myfis			<- cbind(mylabels2,fisperbin$x) 
	plot(myfis[ndata>10,],xlab="Fst",ylab="Fis",xlim=c(0,1),ylim=c(-1,1))
	}

# for microsatellites:
waples<-function(export=FALSE,histo=FALSE,multi=FALSE,compare_to_fst=FALSE)
	{
	myseploc 		<- seploc(mygenind, truenames=TRUE, res.type=c('genind','matrix'))
	library(hierfstat)
	# fst:
	myseplocfst 	<<- lapply(myseploc,pairwise.fst)	# pairwise fst values for each locus (multiple values per locus)
	# locfst		<- sapply(myseplocfst, mean)		# mean of pairwise fst values for each locus (one value per locus)
	# fst between two main clusters(ocean and sea of japan)
	locfst			<- as.vector(unlist(myseplocfst))	#
	locfst			<- locfst[seq(5,95,6)]				# this depends on position of the pairwise comparison we are interested in.
	locfst			<<- locfst
	# fis of all populations combined:
	metasummary		<- summary(mygenind)
	metafis 		<- (metasummary$Hexp-metasummary$Hobs)/metasummary$Hexp
	# fis_all or fst as comparison?
	if(compare_to_fst)
		{
		mycontrast		<- locfst 
		}else{
		mycontrast		<- metafis
		}
	# fis per population:
	mypops			<- popNames(mygenind)
	npops			<- length(mypops)
	popfislist		<<- list()
	for (i in c(1:4))
 		{
		mypop		<- mypops[i]
		# mymatrix	<- as.matrix(mygenind[inds$pop==mypop,])
		mymatrix	<- as.matrix(mygenind[mygenind$pop==mypop,])
		popgenind	<- as.genind(mymatrix)
		popsummary	<- summary(popgenind)
		popfislist[[i]]	<- (popsummary$Hexp-popsummary$Hobs)/popsummary$Hexp
		}
	# plot:
	myxlim			<- c(min(mycontrast),max(mycontrast))
	myylim			<- c(min(unlist(popfislist)),max(unlist(popfislist)))
	mylim			<- c(min(c(myxlim,myylim)),max(c(myxlim,myylim)))
	if(histo)
		{
		if(multi)
			{
			graphics.off()
			if(export){pdf("mapleshisto.multi.pdf",height=13.5,width=13.5)}
			par(mfrow=c(2,2),mar=c(2.5,3,3,3),oma=c(5,5,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
			for (i in c(1:4))
				{
				mypop		<- mypops[i]
				popfis		<- popfislist[[i]]
				hist(mycontrast,col="grey",br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005),main=mypop,ylab="",xlab="",ylim=c(0,4))
				hist(popfis,col=mypop,add=TRUE,br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005))
				}
			if(compare_to_fst)
				{
				mtext(side=1,"Fst (grey) and Fis (colour)",outer=TRUE,line=2,cex=3)
				}else{
				mtext(side=1,"Fis",outer=TRUE,line=2,cex=3)
				}
			mtext(side=2,"Frequency",outer=TRUE,line=1,cex=3)
			}else{
			graphics.off()
			if(export){pdf("mapleshisto.single.pdf",height=9,width=9)}
			par(cex.axis=1.5,cex.lab=2,cex.main=2)
			for (i in c(1:4))
				{
				mypop		<- mypops[i]
				popfis		<- popfislist[[i]]
				if(i==1)
					{
					hist(popfis,col=mypop,br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005),main="",ylab="",xlab="",ylim=c(0,4))
					mtext(side=1,"Fis",line=3,cex=3)
					#mtext(side=2,"Frequency",line=1,cex=3)	
					}else{
					hist(popfis,col=mypop,add=TRUE,br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005))
					}
				}
			}
		if(export){dev.off()}
		}else{
		if(export){pdf("maplesscatter.pdf",height=13.5,width=13.5)}
		par(mfrow=c(2,2),mar=c(1,1,1.5,0.5),oma=c(5,5,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
		for (i in c(1:4))
			{
			mypop		<- mypops[i]
			nind		<- nrow(inds[inds$pop==mypop,])
			popfis		<- popfislist[[i]]
			# plot:
			myyaxt		<- ifelse(i==1|i==3,"s","n")
			myxaxt		<- ifelse(i>2,"s","n")
			plot(locfst,popfis,xlim=mylim,ylim=mylim,ylab="",xlab="",pch=16,xaxt=myxaxt,yaxt=myyaxt,col=mypop,cex=1.5)
			fit 		<- lm(popfis ~ locfst)
			fit2		<- summary(fit)
			mypos		<- c(mylim[1],mylim[1])
			mtext(bquote("n" == .(nind)),at = mylim[1],adj=0,line=-1.5,cex=1.5)
			mtext(bquote(paste("r"^"2") == .(round(fit2$r.squared,3))),at = mylim[1],adj=0,line=-3.5,cex=1.5)
			mtext(mypop,cex=2)
			# regression:
			mydata		<-	as.data.frame(cbind(popfis,locfst)) 
			abline(lm(popfis ~ locfst,data=mydata),lty=2)
			}
		mtext(side=1,"Fst",outer=TRUE,line=3,cex=2.5)
		mtext(side=2,"Fis",outer=TRUE,line=2,cex=2.5)
		if(export){dev.off()}
		}
	}
	
# Fis within populations vs Fst between population for multiallelic data:
waples_random<-function(export=FALSE,mysizes=c(100,250,500,1000,2000,4000),mycolours=c("blue","darkgreen","darkred","orange","purple","grey50"))
	{
	myseploc 		<- seploc(mygenind, truenames=TRUE, res.type=c('genind','matrix'))
	library(hierfstat)
	myseplocfst 	<- lapply(myseploc,pairwise.fst)	# pairwise fst values for each locus (multiple values per locus)
	locfst			<- sapply(myseplocfst, mean)		# mean of pairwise fst values for each locus (one value per locus)
	# fst between two main clusters(ocean and sea of japan):
	locfst			<- as.vector(unlist(myseplocfst))	#
	locfst			<- locfst[seq(5,95,6)]				# this depends on position of the pairwise comparison we are interested in.
	popfislist		<- list()
	for (i in c(1:6))
 		{
		mysize			<- mysizes[i]
		mymatrix		<- as.matrix(mygenind[sample(c(1:4656),mysize,replace=FALSE),])
		randomgenind	<- as.genind(mymatrix)
		randomsum		<- summary(randomgenind)
		popfislist[[i]]	<- (randomsum$Hexp-randomsum$Hobs)/randomsum$Hexp
		}
	# plot:
	myxlim			<- c(min(locfst),max(locfst))
	myylim			<- c(min(unlist(popfislist)),max(unlist(popfislist)))
	#mylim			<- c(min(c(myxlim,myylim)),max(c(myxlim,myylim)))
	mylim			<- myxlim
	if(export){pdf("maplesplot.randomsubsets.pdf",height=10,width=13.5)}
	par(mfrow=c(2,3),mar=c(1,1,1.5,0.5),oma=c(5,5,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)	
	for (i in c(1:6))
 		{
		mysize		<- mysizes[i]
		randomfis	<- popfislist[[i]]
		myyaxt		<- ifelse(i==1|i==4,"s","n")
		myxaxt		<- ifelse(i>3,"s","n")
		plot(locfst,randomfis,xlim=mylim,ylim=mylim,ylab="",xlab="",pch=16,xaxt=myxaxt,yaxt=myyaxt)
		fit 		<- lm(randomfis ~ locfst)
		fit2		<- summary(fit)
		mtext(bquote("n" == .(mysize)),cex=1.5)
		mtext(bquote(paste("r"^"2") == .(round(fit2$r.squared,3))),at = mylim[1],adj=0,line=-1.5)
		mydata		<-	as.data.frame(cbind(randomfis,locfst)) 
		abline(lm(randomfis ~ locfst,data=mydata),lty=2)
		for(j in c(1:length(mycolours)))
			{
			mycol		<- mycolours[j]
			mymatrix	<- as.matrix(mygenind[sample(c(1:4656),mysize,replace=FALSE),])
			randomgenind<- as.genind(mymatrix)
			randomsum	<- summary(randomgenind)
			randomfis	<- (randomsum$Hexp-randomsum$Hobs)/randomsum$Hexp
			points(locfst,randomfis,pch=16,col=mycol)
			fit 		<- lm(randomfis ~ locfst)
			fit2		<- summary(fit)
			mtext(bquote(paste("r"^"2") == .(round(fit2$r.squared,3))),at = mylim[1],adj=0,line=((j+1)*-1.5),col=mycol)
			mydata		<-	as.data.frame(cbind(randomfis,locfst)) 
			abline(lm(randomfis ~ locfst,data=mydata),lty=2,col=mycol)
			}
 		}
	mtext(side=1,"Fst",outer=TRUE,line=3,cex=2.5)
	mtext(side=2,"Fis",outer=TRUE,line=2,cex=2.5)
	if(export){dev.off()}
	}

# expected correlation between fst and fis for this dataset if neutral subset:
meanr2<-function(mysize=500,ntimes=100)
	{
	myoutput<<- rep(NA,ntimes)
	# fst per locus:
	myseploc <- seploc(mygenind, truenames=TRUE, res.type=c('genind','matrix'))
	myseplocfst <- lapply(myseploc,pairwise.fst)
	locfst<- as.vector(unlist(myseplocfst))
	locfst<- locfst[seq(4,94,6)]
	# fis per locus, and regression with fst:
	for (i in c(1:ntimes))
		{
		cat(i,sep="\n")
		mymatrix<- as.matrix(mygenind[sample(c(1:4656),mysize,replace=FALSE),])
		randomgenind<- as.genind(mymatrix)
		randomsum<- summary(randomgenind)
		randomfis<- (randomsum$Hexp-randomsum$Hobs)/randomsum$Hexp
		fit <- lm(randomfis ~ locfst)
		fit2<- summary(fit)
		myoutput[i]<- round(fit2$r.squared,3)
		}
	}


#################### DATA PREPARATION ################### 

# This function executes all steps of the data preparation at once: 
filterdata<-function(indmiss=0.25,snpmiss=0.1,chromosomes=FALSE,min_mac=2,dohefilter=TRUE,minimum_spacing=500,silent=TRUE)
	{
	if(!exists("inds"))
		{
		return(cat("ERROR: Object 'inds' is missing. First (re)run the importdata() function.",sep="\n"))
		}
	if(!exists("snps"))
		{
		return(cat("ERROR: Object 'snps' is missing. First (re)run the importdata() function.",sep="\n"))
		}
	if(!exists("mygenlight"))
		{
		return(cat("ERROR: Object 'mygenlight' is missing. First (re)run the importdata() function.",sep="\n"))
		}		
	if(indmiss>=1|indmiss<=0)
		{
		return(cat("ERROR: Value of indmiss argument should be between 0 and 1.",sep="\n"))
		}
	if(snpmiss>=1|snpmiss<=0)
		{
		return(cat("ERROR: Value of snpmiss argument should be between 0 and 1.",sep="\n"))
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
	setwd(mysambar$QCdir)
	cat("Step 1 out of 6: Checking data quality...",sep="\n")
	# Reorder the snps to the order they occur in the genome:
	# Not necessary when data is created with importdata function, but possibly necessary if created with findoverlap() or dummydata() or subsetdata() functions:
	# First reorder the snps dataframe:
	snpstemp		<- snps
	#snps			<<- snpstemp[order(as.numeric(snpstemp$chr),as.numeric(snpstemp$pos)),]
	snps			<<- snpstemp[order(snpstemp$chr,as.numeric(snpstemp$pos)),]
	# Second reorder the data in the genlight object:
	#mymatrix		<- as.matrix(mygenlight[,order(as.numeric(snpstemp$chr),as.numeric(snpstemp$pos))])
	mymatrix		<- as.matrix(mygenlight[,order(snpstemp$chr,as.numeric(snpstemp$pos))])
	mygenlight		<<- as.genlight(mymatrix)
	pop(mygenlight)	<<- inds$pop
	# general statistics and missing data:
	if(!silent){cat("calcGC",sep="\n")}
	calcGC()
	if(!silent){cat("calctransit",sep="\n")}
	calctransit()
	if("dist" %in% colnames(snps))
		{
		mymaxdist	<- max(snps$dist,na.rm=TRUE)
		if(mymaxdist<=1000)
			{
			cat("WARNING: No pair of adjacent snps is separated by more than 1 kb.",sep="\n")
			cat("Are you sure the information in the first column of your MAP file refers to chromosomes/contigs and not to reads?",sep="\n")
			}
		if(!silent){cat("readpos",sep="\n")}
		readpos(export="eps")
		readpos(export="pdf")
		readpos(export="png")
		readpos(export="wmf")
		if(!silent){cat("plotspacing",sep="\n")}
		plotspacing(export="eps")
		plotspacing(export="pdf")
		plotspacing(export="png")
		plotspacing(export="wmf")
		}
	if(chromosomes)
		{
		if(!silent){cat("distperchrom",sep="\n")}
		distperchrom()
		#plotspacingperchrom(export="pdf") # replaced by distperchrom
		}
	if(!silent){cat("indsmissingness",sep="\n")}
	indsmissingness(indthreshold=indmiss)	
	if(!any(inds$miss<=indmiss))
		{
		cat("ERROR: no individuals retained after filtering on missingness.",sep="\n")
		if(!silent){cat("barplot missing data",sep="\n")}
		barplot(inds$miss,ylab="Proportion missing data per sample",xlab="Sample number",ylim=c(0,1),names=inds$nr,las=2,cex.names=0.5)
		abline(h=0.1,lty=2)
		return(cat("Change filter settings (i.e. choose a higher value for indmiss) and rerun the filterdata() function.",sep="\n"))
		}
	if(!silent){cat("plot_indsmissingdata",sep="\n")}
	plot_indsmissingdata(indthreshold=indmiss,export="eps")
	plot_indsmissingdata(indthreshold=indmiss,export="pdf")
	plot_indsmissingdata(indthreshold=indmiss,export="png")
	plot_indsmissingdata(indthreshold=indmiss,export="wmf")
	if(!silent){cat("snpsmissingness",sep="\n")}
	snpsmissingness(indthreshold=indmiss,snpthreshold=snpmiss)
	if(!any(snps$miss<=snpmiss))
		{
		cat("ERROR: no snps retained after filtering on missingness.",sep="\n")
		cat("Change filter settings (i.e. choose a higher value for snpmiss) and rerun the filterdata() function.",sep="\n")
		return(cat("For an overview of missing data per snp, have a look at the 'missingdataperlocus' plot in the QC subdirectory.",sep="\n"))
		}
	if(!silent){cat("plot_snpsmissingdata",sep="\n")}
	plot_snpsmissingdata(snpthreshold=snpmiss,export="eps")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="pdf")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="png")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="wmf")
	if(length(mysambar$populations)>1)
		{
		if(!silent){cat("missingness_perpop",sep="\n")}
		missingness_perpop(export="eps")
		missingness_perpop(export="pdf")
		missingness_perpop(export="png")
		missingness_perpop(export="wmf")
		missingness_perpop(export="eps",addylabel=FALSE)
		missingness_perpop(export="pdf",addylabel=FALSE)
		missingness_perpop(export="png",addylabel=FALSE)
		missingness_perpop(export="wmf",addylabel=FALSE)
		}
	#if(any(inds$miss==1))
	#	{
	#	cat("ERROR: The following sample(s) has/have zero data:",sep="\n")
	#	cat(as.vector(inds$name[inds$miss==1]),sep="\n")
	#	cat("For an overview of missing data per sample, have a look at the 'missingdatapersample' plot in the QC subdirectory.",sep="\n")
	#	cat("SambaR does not accept samples with zero data.", sep="\n")
	#	return(cat("Remove this/these sample(s) from input file (i.e ped file) and run the plink --make-bed and Sambar importdata() function again to import reduced dataset.",sep="\n"))
	#	}
	# snps maf/he:
	cat("Step 2 out of 6: Calculating locus specific minor allele frequencies and heterozygosities...",sep="\n")
	if(!silent){cat("snp_maf",sep="\n")}
	snp_maf(indthreshold=indmiss)
	if(length(popnoind)>0)
		{
		cat("ERROR: SambaR does not accept populations with zero retained individuals.",sep="\n")
		cat("Change filter settings (i.e. choose a higher value for indmiss) and run the filterdata() again.",sep="\n")
		cat("Alternatively, remove samples/populations from input file (i.e. ped file) and run the plink --make-bed and Sambar importdata() function again to import reduced dataset.",sep="\n")
		return(cat("For an overview of missing data per population, have a look at the 'Missingdata.perpop' plot in the QC subdirectory.",sep="\n"))
		}
	if(!silent){cat("correctmaf",sep="\n")}
	correctmaf()
	if(!silent){cat("getpopmaf",sep="\n")}
	getpopmaf(snpthreshold=snpmiss)
	if(!silent){cat("mafsd",sep="\n")}
	mafsd()
	if(!silent){cat("snp_hetero",sep="\n")}
	snp_hetero(indthreshold=indmiss,snpthreshold=snpmiss)
	if(chromosomes)
		{
		if(!silent){cat("chrom_He_maf",sep="\n")}
		chrom_He_maf(export="eps")	
		chrom_He_maf(export="pdf")
		chrom_He_maf(export="png")
		chrom_He_maf(export="wmf")
		}
	# filter:
	cat("Step 3 out of 6: Setting filters...",sep="\n")
	filters(indthreshold=indmiss,snpthreshold=snpmiss,mac=min_mac,mindistance=minimum_spacing,hefilter=dohefilter,paralogthreshold2=0.05,export="eps")
	filters(indthreshold=indmiss,snpthreshold=snpmiss,mac=min_mac,mindistance=minimum_spacing,hefilter=dohefilter,paralogthreshold2=0.05,export="png")
	filters(indthreshold=indmiss,snpthreshold=snpmiss,mac=min_mac,mindistance=minimum_spacing,hefilter=dohefilter,paralogthreshold2=0.05,export="pdf")
	filters(indthreshold=indmiss,snpthreshold=snpmiss,mac=min_mac,mindistance=minimum_spacing,hefilter=dohefilter,paralogthreshold2=0.05,export="wmf")
	if(!any(snps$filter))
		{
		cat("ERROR: No snps retained after overall filtering.",sep="\n")
		cat("Change filter settings (i.e. choose a higher value for snpmiss) and run the filterdata() again.",sep="\n")
		return(cat("For an overview of missing data per snp, have a look at the 'missingdataperlocus' plot in the QC subdirectory.",sep="\n"))
		}
	nretainedinds	<- nrow(inds[inds$filter,])
	ntotalinds		<- nrow(inds)
	nretainedsnps	<- nrow(snps[snps$filter2,])
	nthinnedsnps	<- nrow(snps[snps$filter,])
	ntotalsnps		<- nrow(snps)	
	cat(paste("After filtering retained",nretainedinds,"out of",ntotalinds,"individuals.",sep=" "),sep="\n")
	cat(paste("After filtering retained",nretainedsnps,"out of",ntotalsnps,"snps.",sep=" "),sep="\n")
	cat(paste("After filtering and thinning retained",nthinnedsnps,"out of",ntotalsnps,"snps.",sep=" "),sep="\n")
	# inds maf/he:
	cat ("Step 4 out of 6: Calculating sample specific minor allele frequencies and heterozygosities...",sep="\n")
	if(!silent){cat("ind_maf",sep="\n")}
	ind_maf(allsites=FALSE)
	ind_maf(allsites=TRUE)
	if(!silent){cat("ind_hetero",sep="\n")}
	ind_hetero(allsites=FALSE)
	ind_hetero(allsites=TRUE)
	if(!silent){cat("hwe",sep="\n")}
	if(length(mysambar$populations)<9){hwe(export="eps")}
	hwe(export="pdf")			
	hwe(export="png")
	hwe(export="wmf")
	cat("Step 5 out of 6: Generating summary table...",sep="\n")
	mysummarytable()
	cat("Step 6 out of 6: Generating summary plots...",sep="\n")
	if(!silent){cat("plotHe_perind",sep="\n")}
	plotHe_perind(export="eps")
	plotHe_perind(export="pdf")
	plotHe_perind(export="png")
	plotHe_perind(export="wmf")
	if(length(mysambar$populations)>1)
		{
		if(!silent){cat("retainedinds_perpop",sep="\n")}
		retainedinds_perpop(export="eps")
		retainedinds_perpop(export="pdf")
		retainedinds_perpop(export="png")
		retainedinds_perpop(export="wmf")
		if(!silent){cat("discardedinds_perpop",sep="\n")}
		if(any(!inds$filter))
			{
			discardedinds_perpop(export="eps")
			discardedinds_perpop(export="pdf")
			discardedinds_perpop(export="png")
			discardedinds_perpop(export="wmf")
			}else{
			cat("All individuals retained. Omitting 'Discardedinds.perpop' plots.",sep="\n")
			}
		if(!silent){cat("retainedsites_perpop",sep="\n")}
		retainedsites_perpop(export="eps")
		retainedsites_perpop(export="pdf")
		retainedsites_perpop(export="png")
		retainedsites_perpop(export="wmf")
		}
	if("meandepth"%in%colnames(snps))
		{
		if(!silent){cat("plotlocusdepth",sep="\n")}
		plotlocusdepth(export=TRUE)			# This is in fact mean individual depth, different from plot created in snpsmissingness function.
		}
	if(!silent){cat("plot_number_segregating_sites",sep="\n")}
	plot_number_segregating_sites(export="eps")
	plot_number_segregating_sites(export="pdf")
	plot_number_segregating_sites(export="png")
	plot_number_segregating_sites(export="wmf")
	if(!silent){cat("plotminor",sep="\n")}
	plotminor(export="eps")
	plotminor(export="pdf")
	plotminor(export="png")
	plotminor(export="wmf")
	if(!silent){cat("plottransits",sep="\n")}
	plottransits(filter=FALSE,export="eps")
	plottransits(filter=FALSE,export="pdf")
	plottransits(filter=FALSE,export="png")
	plottransits(filter=FALSE,export="wmf")
	plottransits(filter=TRUE,export="eps")
	plottransits(filter=TRUE,export="pdf")
	plottransits(filter=TRUE,export="png")
	plottransits(filter=TRUE,export="wmf")
	if(!silent){cat("plotfiltermaf",sep="\n")}
	if(length(mysambar$populations)<9){plotfiltermaf(export="eps")}	# figure margins too large if 10 pops
	plotfiltermaf(export="pdf")
	plotfiltermaf(export="png")
	plotfiltermaf(export="wmf")
	if("dist" %in% colnames(snps))
		{
		if(!silent){cat("multimafdiff",sep="\n")}
		multimafdiff()
		}
	if(length(mysambar$populations)>1)
		{
		if(!silent){cat("histo_locusHe",sep="\n")}
		if(length(mysambar$populations)<9){histo_locusHe(export="eps")}
		histo_locusHe(export="pdf")
		histo_locusHe(export="png")
		histo_locusHe(export="wmf")
		if(!silent){cat("boxplot_locusHe",sep="\n")}
		boxplot_locusHe(export="eps")
		boxplot_locusHe(export="pdf")
		boxplot_locusHe(export="png")
		boxplot_locusHe(export="wmf")
		}
	if(!silent){cat("plotparalogs",sep="\n")}
	plotparalogs(export="eps")
	plotparalogs(export="pdf")
	plotparalogs(export="png")
	plotparalogs(export="wmf")
	# if(!silent){cat("calc_indF allsites",sep="\n")}
	# calc_indF(allsites=TRUE,export="eps")	# 26-09-2019: incorrect at the moment, needs to be improved
	# calc_indF(allsites=TRUE,export="pdf")
	# calc_indF(allsites=TRUE,export="png")
	# calc_indF(allsites=TRUE,export="wmf")
	if(!silent){cat("calc_indF",sep="\n")}
	calc_indF(allsites=TRUE,export=NULL)	
	if(!silent){cat("expHe_vs_He",sep="\n")}
	expHe_vs_He(export="eps",allsites=FALSE)
	expHe_vs_He(export="pdf",allsites=FALSE)
	expHe_vs_He(export="png",allsites=FALSE)
	expHe_vs_He(export="wmf",allsites=FALSE)
	if(!silent){cat("expHe_vs_He allsites",sep="\n")}
	expHe_vs_He(export="eps",allsites=TRUE)
	expHe_vs_He(export="pdf",allsites=TRUE)
	expHe_vs_He(export="png",allsites=TRUE)
	expHe_vs_He(export="wmf",allsites=TRUE)
	# optionally plot statistics per sequencing pool:
	if(!silent){cat("plotperpool",sep="\n")}
	plotperpool()
	# stacks_demultiplex()
	#
	# create a report of filter settings:
	mysettings			<- data.frame("settings"=c("date/time","indmiss","snpmiss","chromosomes","minimum_minor_allele_count","dohefilter","minimum_spacing"),"value"=rep(NA,7))
	mysettings$value[1]	<- as.character(Sys.time())
	mysettings$value[2]	<- as.character(indmiss)
	mysettings$value[3]	<- as.character(snpmiss)
	mysettings$value[4]	<- as.character(chromosomes)
	mysettings$value[5]	<- ifelse(is.null(min_mac),"0",as.character(min_mac))
	mysettings$value[6]	<- as.character(dohefilter)
	mysettings$value[7]	<- as.character(ifelse("dist"%in%colnames(snps),minimum_spacing,0))
	write.table(mysettings,"SambaR_filtersettings.txt",row.names=FALSE,col.names=FALSE,quote=FALSE,sep="\t")
	# create a file with information about filter settings per individual:
	indstable	<- inds[,c("name","nr","pop","popcol","filter","miss","filter")]
	write.table(indstable,"SambaR_samples.filterinfo.txt",row.names=FALSE,sep="\t",quote=FALSE)
	#
	if(any(is.na(inds$filter)))
		{
		return(cat("ERROR: The column inds$filter contains NA-values. Contact the developer of SambaR.",sep="\n"))
		}
	if(any(is.na(inds$filter)))
		{
		return(cat("ERROR: The column snps$filter contains NA-values. Contact developer of SambaR.",sep="\n"))
		}
	cat("Finished filtering dataset. Summary plots and tables have been written to:",sep="\n")
	cat(mysambar$QCdir,sep="\n")
	#
	setwd(mysambar$sambardir)
	exportmethods(ind_miss=indmiss,snp_miss=snpmiss,minmac=min_mac,hefilter=dohefilter,minimumspacing=minimum_spacing)
	cat("A description of the methods has been written to a txt.file called 'SambaR_methods.txt' within the directory:",sep="\n")
	cat(mysambar$sambardir,sep="\n")
	setwd(mysambar$inputdatadir)
	}

exportsambarfiles<-function()
	{
	setwd(mysambar$inputfilesdir)
	if(length(mysambar$populations)>1)
		{
		cat("Exporting input for Bayesass ('Bayesassinput.immanc.txt')...",sep="\n")
		genlight2immanc(quiet=TRUE)
		}else{
		cat("Currently only 1 population defined. Not exporting Bayesass input ('Bayesassinput.immanc.txt').",sep="\n")
		}
	#
	cat("Exporting input for plink relatedness calculations ('metapop.filter.number.ped' and 'metapop.filter.number.map)...",sep="\n")
	genlight2ped(snpsfilter=snps$filter,indsfilter=inds$filter,exportname="metapop.filter.number") 		# 17-06-2019: This was originally called 'Relatednessinput'
	#
	cat("Exporting input for plink LD calculations (files ending on 'filter2.number.ped' and 'filter2.number.map'). This make take a while...",sep="\n")	
	exportdata(snpsfilter=snps$filter2,indsfilter=inds$filter,export_name="filter2.number",quiet2=TRUE)
	#
	setwd(mysambar$inputdatadir)
	cat("Filtered datasets have been written to:",sep="\n")
	cat(mysambar$inputfilesdir,sep="\n")
	}
	
# 03042017: could still incorporate this function, but not an essential analysis:
# minor allele frequency range per stack:
stackdata<-function(mypop="Barff",myfilter=snps$filter2)
	{
	if(!("stackID2" %in% colnames(snps)))
		{
		snps$stackID2	<- as.factor(as.character(snps$stackID))
		}
	mymaf				<- snps[,paste("maf",mypop,sep="_")]			
	mymin				<- aggregate(mymaf[myfilter],by=list(as.factor(as.character(snps$stackID[myfilter]))),FUN=min)
	mymax				<- aggregate(mymaf[myfilter],by=list(as.factor(as.character(snps$stackID[myfilter]))),FUN=max)
	stack_data			<- aggregate(mymaf[myfilter],by=list(as.factor(as.character(snps$stackID[myfilter]))),FUN=length)
	colnames(stack_data)		<- c("stackID2","stack_nsnps")
	stack_data$stack_mafrange	<- mymax$x-mymin$x   
	snpstemp			<<- merge(snps,stack_data,by="stackID2",all=TRUE)
	}
	
calcGC<-function()
	{
	# The rationale behind this function is that the distribution of major alleles reflects the distribution of nucleotides in the species genome. 
	if(!("GC" %in% colnames(snps)))
		{
		snps$GC	<<-	(snps$major2=="C")|(snps$major2=="G")
		}	
	}

calctransit<-function()
	{
	if(!("transit" %in% colnames(snps)))
		{
		snps$transit<<-	(snps$minor==1&snps$major==3)|(snps$minor==3&snps$major==1)|(snps$minor==2&snps$major==4)|(snps$minor==4&snps$major==2)
		}	
	}

distperchrom<-function(dothin=FALSE)
	{
	# Table:
	statsfunction 	<- function(x){c(mean = mean(x), std = sd(x), quantiles = quantile(x))}
	distancetable	<- cbind(as.vector(table(as.vector(snps$chr[snps$placed]))),do.call(rbind,tapply(snps$dist[snps$dist2&snps$placed],snps$chr[snps$dist2&snps$placed],statsfunction)))
	distancetable	<- round(distancetable)
	colnames(distancetable)<-c("nsnps","mean","stdv","min","25%","median","75%","max")
	write.table(distancetable,"Distperchrom.txt",col.names=TRUE,row.names=TRUE,quote=FALSE)
	# boxplot:
	if(!dothin)
		{
		pdf("Distperchrom.filtered.pdf",height=6,width=12)
		myselection<- snps$filter2
		}else{
		pdf("Distperchrom.thinned.pdf",height=6,width=12)
		myselection<- snps$filter
		}
	myselection2<- snps$placed&myselection
	mychroms	<- as.vector(snps$chr[myselection2])
	mydist		<- snps$dist[myselection2]
	mydist[mydist==0]	<-NA
	boxplot(mydist~mychroms,las=2,col="grey",xlab="",ylab="",yaxt="n",cex.lab=2,cex.axis=1.5,log="y")
	aty 		<- axTicks(2)
	atylog		<- log10(aty)
	axis(2,at=aty,labels=atylog,las=1,cex=1.5)
	mtext("Distance (log Mb)",side=2,line=2.5,cex=2)
	mtext("Chromosome",side=1,line=3.5,cex=2)
	dev.off()
	}	
	
readpos<-function(export=NULL)
	{
	if(any(is.na(snps$readpos)))
		{
		return()
		}
	mymax			<- max(snps$readpos)
	if(mymax<250)
		{
		mycounts		<- hist(snps$readpos,breaks=seq(0,mymax,1))
		mysd			<- sd(mycounts$counts[mycounts$counts!=0])
		mymean			<- mean(mycounts$counts[mycounts$counts!=0])
		mydev			<- mycounts$counts<(mymean+mysd)&mycounts$counts>(mymean-mysd)
		mylower			<- which(mydev==TRUE)[1]
		mydev2			<- rev(mydev)
		myupper			<- length(mydev2)-which(mydev2==TRUE)[1]+1
		snps$readpos2	<<- snps$readpos>=mylower&snps$readpos<=myupper
		snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
		# plot:
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPalongreads.eps",family=mysambar$myfont,width=16,height=10)}
			if(export=="pdf"){pdf("SNPalongreads.pdf",family=mysambar$myfont,width=16,height=10)}
			if(export=="png"){png("SNPalongreads.png",family=mysambar$myfont,width=1260,height=720)}
			if(export=="wmf"){win.metafile("SNPalongreads.wmf",family=mysambar$myfont,width=16,height=10)}
			}
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		hist(snps$readpos,breaks=seq(0,mymax,1),xlab="Position along read (bp)",ylab="Frequency",main="Distribution of snps along reads")
		hist(snps$readpos[!snps$readpos2],breaks=seq(0,mymax,1),add=TRUE,col="orange")
		mtext("dashed line = mean; solid lines = mean +/- sd", side = 3, line = -1, cex = 2)
		abline(mymean,0,lty=2)
		abline(mymean-mysd,0)
		abline(mymean+mysd,0)
		if(!is.null(export)){dev.off()}
		}
	}	

plotspacing<-function(export=NULL)
	{
	mymaxdist	<- max(snps$pos,na.rm=TRUE)
	if(mymaxdist>1000)
		{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPspacing.eps",family=mysambar$myfont,width=18,height=10)}
			if(export=="pdf"){pdf("SNPspacing.pdf",family=mysambar$myfont,width=18,height=10)}
			if(export=="png"){png("SNPspacing.png",family=mysambar$myfont,width=1296,height=720)}
			if(export=="wmf"){win.metafile("SNPspacing.wmf",family=mysambar$myfont,width=18,height=10)}
			}
		par(mfrow=c(1,2),mar=c(5,8,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		hist(snps$dist[snps$dist>1000],xlim=c(1000,1000000),breaks=1000,main="",xaxt='n',xlab="Distance (kb)",las=1,ylab="")
		mylabels<-seq(0,1000000,250000)
		axis(side=1,at=mylabels,labels=mylabels/1000,lty=1,las=1)
		mtext("Frequency",side=2,cex=3,line=5)
		mtext("10 kb bins", side = 3, cex = 2.5, line = -1)
		hist((snps$dist),xlim=c(0,500),breaks=1000000,main="",xaxt='n',xlab="Distance (kb)",las=1,ylab="")
		mylabels<-seq(0,500,100)
		axis(side=1,at=mylabels,labels=mylabels/1000,lty=1,las=1)
		mtext("0.01 kb bins", side = 3, cex = 2.5, line = -1)
		mtext("Distance between adjacent snps", side = 3, cex = 3.5, line = -3.5, outer=TRUE)
		if(!is.null(export)){dev.off()}
		}else{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPspacing.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("SNPspacing.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("SNPspacing.png",family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile("SNPspacing.wmf",family=mysambar$myfont,width=10,height=10)}
			}
		par(mar=c(5,8,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		hist((snps$dist),xlim=c(0,500),breaks=1000000,main="",xaxt='n',xlab="Distance (kb)",las=1,ylab="")
		mylabels<-seq(0,500,100)
		axis(side=1,at=mylabels,labels=mylabels/1000,lty=1,las=1)
		mtext("0.01 kb bins", side = 3, cex = 2.5, line = -1)
		mtext("Distance between adjacent snps", side = 3, cex = 3.5, line = -3.5, outer=TRUE)
		if(!is.null(export)){dev.off()}
		}
	#
	# indicate intra- and interread distances:
	if("sameread"%in%colnames(snps))
		{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPspacing.intra_vs_interread.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("SNPspacing.intra_vs_interread.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("SNPspacing.intra_vs_interread.png",family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile("SNPspacing.intra_vs_interread.wmf",family=mysambar$myfont,width=10,height=10)}
			}
		par(mar=c(5.5,8,2.5,2),cex.axis=2.5,cex.lab=2.5,cex.main=2.5)
		hist(snps$dist[snps$dist<500&snps$sameread],breaks=seq(0,1000,10),xlim=c(0,500),las=1,ylab="",xlab="Distance (bp)",main="SNP spacing",col="grey")
		hist(snps$dist[snps$dist<500&!snps$sameread],breaks=seq(0,1000,10),add=TRUE)
		legend("topright",legend=c("same read","different read"),fill=c("grey","white"),bty='n',cex=2.5)
		if(!is.null(export)){dev.off()}
		}	
	}

# Only execute this function if you have a reference genome assembled to chromosomes (not contigs/scaffolds)
plotspacingperchrom<-function(myyrange=c(0,500000),export=NULL)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("SNPspacingperchrom.eps",family=mysambar$myfont,width=18,height=10)}
		if(export=="pdf"){pdf("SNPspacingperchrom.pdf",family=mysambar$myfont,width=18,height=10)}
		if(export=="png"){png("SNPspacingperchrom.png",family=mysambar$myfont,width=1296,height=720)}
		if(export=="wmf"){win.metafile("SNPspacingperchrom.wmf",family=mysambar$myfont,width=18,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=1.5,cex.lab=3,cex.main=3.5)
	boxplot(snps$dist[snps$placed]~as.vector(snps$chr[snps$placed]),ylim=myyrange,main="Distance between adjacent snps",xlab="Chromosome",ylab="Distance (bp)")
	if(!is.null(export)){dev.off()}
	}	
	
indsmissingness<-function(indthreshold=0.25,export=NULL)
	{
	mat 		<- as.matrix(mygenlight)
	nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
	inds$miss 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
	# which samples meet the predefined threshold?
	inds$fmiss	<<- inds$miss <= indthreshold
	# change column name:
	names(inds)[names(inds) == "fmiss"] <<- paste("fmiss",indthreshold,sep = "")
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	}
	
plot_indsmissingdata<-function(export=NULL,indthreshold=0.25)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("missingdatapersample.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("missingdatapersample.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("missingdatapersample.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("missingdatapersample.wmf",family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,2,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(!("meandepth" %in% colnames(inds)))
		{
		hist(inds$miss,breaks=seq(0,1,0.01),main="Missing data per sample",xlab="Proportion of missing data points",ylab="Number of samples")
		hist(inds$miss[inds$miss>indthreshold],breaks=seq(0,1,0.01),add=T,col="red")
		}else{
		plot(inds$meandepth,inds$miss,pch=16,cex=2,main="",xlab="Read depth per sample",ylab="Missing data per sample",ylim=c(0,1))
		points(inds$meandepth[inds$miss>indthreshold],inds$miss[inds$miss>indthreshold],pch=16,cex=2,col="red")
		legend("topright",legend=c("FALSE","TRUE"),title="Pass filter",bty='n',fill=c("red","black"),cex=2)
		}
	if(!is.null(export)){dev.off()}
	}

snpsmissingness<-function(indthreshold=0.25,snpthreshold=0.1,popnames=mysambar$populations)
	{
	indmissfilter			<- inds$miss<=indthreshold
	snps$misscount			<<- glNA(mygenlight[indmissfilter,],alleleAsUnit=FALSE)										# for each locus, calculate number of individuals (from filtered subset) with missing data:
	snps$nonmissallelecount <<- 2*(nInd(mygenlight[indmissfilter,])-snps$misscount)										# The opposite of snps$misscount
	snps$miss				<<- glNA(mygenlight[indmissfilter,],alleleAsUnit=FALSE)/nInd(mygenlight[indmissfilter,])	# as snps$misscount, but divided by length of indmissfilter, giving us a frequency:	
	snps$fmiss				<<- snps$miss <= snpthreshold																# which loci meet the predefined threshold?			
	# change column name:
	names(snps)[names(snps) == "fmiss"] <<- paste("fmiss",snpthreshold,sep = "")
	# missingness per SNP per population:
	# Per population:
	for (i in (1:length(popnames)))
		{
		mypop			<- popnames[i]
		popfilter		<- indmissfilter&inds$pop==mypop
		snps$misspop	<<- glNA(mygenlight[popfilter,],alleleAsUnit=FALSE)/nInd(mygenlight[popfilter,])
		names(snps)[names(snps) == "misspop"] <<- paste("miss",mypop,sep ="_")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}
	
plot_snpsmissingdata<-function(snpthreshold=0.1,export=NULL)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("missingdataperlocus.eps",family=mysambar$myfont,width=12,height=10)}
		if(export=="pdf"){pdf("missingdataperlocus.pdf",family=mysambar$myfont,width=12,height=10)}
		if(export=="png"){png("missingdataperlocus.png",family=mysambar$myfont,width=900,height=720)}
		if(export=="wmf"){win.metafile("missingdataperlocus.wmf",family=mysambar$myfont,width=12,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)	
	if(!("meandepth" %in% colnames(snps)))
		{
		hist(snps$miss,breaks=seq(0,1,0.01),main="",xlab="Proportion of missing data points",ylab="")
		hist(snps$miss[snps$miss>snpthreshold],breaks=seq(0,1,0.01),add=T,col="red")
		mtext("Number of loci",side=2,cex=3,line=7)
		}else{
		if(any(!is.na(snps$meandepth)))
			{
			plot(snps$meandepth,snps$miss,pch=16,cex=2,log='x',xlab="Read depth per SNP",ylab="Missing data per SNP",ylim=c(0,1))
			points(snps$meandepth[snps$miss>snpthreshold],snps$miss[snps$miss>snpthreshold],pch=16,cex=2,col="red")
			legend("topright",legend=c("FALSE","TRUE"),title="Pass filter",bty='n',fill=c("red","black"),cex=2)
			}else{
			hist(snps$miss,breaks=seq(0,1,0.01),main="",xlab="Proportion of missing data points",ylab="")
			hist(snps$miss[snps$miss>snpthreshold],breaks=seq(0,1,0.01),add=T,col="red")
			mtext("Number of loci",side=2,cex=3,line=7)
			}
		}
	if(!is.null(export)){dev.off()}
	}

snp_maf<-function(popnames=mysambar$populations,indthreshold=0.25)	
	{
	indfilter			<- inds$miss<=indthreshold
	# What is minor allele count and major allele count:
	snps$minorcount		<<- as.vector(glSum(mygenlight[indfilter,]))
	snps$majorcount		<<- snps$nonmissallelecount-snps$minorcount	
	# Calculates average maf per locus:
	# Overall dataset:
	snps$maf			<<- round(snps$minorcount/snps$nonmissallelecount,3)
	#snps$maf 			<<- glMean(mygenlight[indfilter,])		# glMean gives wrong estimate if data consists of 1 snp only
	popnoind			<<- vector()
	# Per population:
	for (i in (1:length(popnames)))
		{
		# popminor			<- as.vector(glSum(mygenlight[indfilter&inds$pop2==popnames[i],]))
		# popmiss			<- glNA(mygenlight[indfilter&inds$pop2==popnames[i],],alleleAsUnit=FALSE)
		# popmiss			<- glNA(mygenlight[indfilter&inds$pop2==popnames[i],],alleleAsUnit=FALSE)
		# nind				<- nrow(inds[inds$pop2==popnames[i]&inds$filter,])
		# popall			<- 2*nind-popmiss
		# snps$maftemp		<<- round(popminor/popall,3)			# this leads to ERROR when correcting maf (something about NA's)	
		if(any(indfilter&inds$pop2==popnames[i]))
			{
			snps$maftemp 	<<- glMean(mygenlight[indfilter&inds$pop2==popnames[i],])		# glMean gives wrong estimates of maf when a samples doesn't have all genotypes (0,1,2) at least represented once in your subset of loci. 
			snps$maftemp[!is.finite(snps$maftemp)]	<<- NA 
			if(any(is.na(snps$maftemp)))
				{
				cat(paste("WARNING: No data for 1 or more snps in population:",popnames[i],sep=" "),sep="\n")
				}
			}else{
			cat(paste("No individuals retained in population:",popnames[i],sep=" "),sep="\n")
			popnoind			<<- c(popnoind,popnames[i])   
			snps$maftemp 		<<- NA
			}
		names(snps)[names(snps) == "maftemp"] 	<<- paste("maf",popnames[i],sep = "_")
		}
	# if this function has been executed before, remove columns produced during previous execution:
	snps 					<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}

pheno_maf<-function(indthreshold=0.25)	
	{
	if(is.null(inds$type))
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	indfilter			<- inds$miss<=indthreshold
	snps$maf_pheno1 	<<- glMean(mygenlight[indfilter&inds$type,])
	snps$maf_pheno2 	<<- glMean(mygenlight[indfilter&(!inds$type),])
	# if this function has been executed before, remove columns produced during previous execution:
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}	

snp_mymaf<-function(popnames=mysambar$populations,indthreshold=0.25,snpthreshold=0.1)
	{
	# snpmaf uses the function glMean.
	# glMean gives wrong estimates of maf when one or more samples don't have all genotypes (0,1,2) at least represented once in your subset of loci. 
	# If so, you might consider using this script, which is a bit slower:
	indfilter	<- inds$miss<=indthreshold
	mafmyway	<- vector()
	mymatrix	<- as.matrix(mygenlight[indmissfilter,])
	for (i in c(1:(ncol(mymatrix))))
		{
		temp1		<- mymatrix[,i]
		bool		<- !is.na(temp1)
		temp		<- temp1[bool]
		temp2		<- as.data.frame(table(temp))
		if(nrow(temp2)==3)
			{
			maf		<- (temp2[3,2]+((1/2)*temp2[2,2]))/(temp2[1,2]+temp2[2,2]+temp2[3,2])
			}
		if(nrow(temp2)==2)
			{
			if(temp2$temp[1]==0&temp2$temp[2]==1){maf	<- (1/2)*temp2[2,2]/(temp2[1,2]+temp2[2,2])}
			if(temp2$temp[1]==1&temp2$temp[2]==2){maf	<- ((1/2)*temp2[1,2]+temp2[2,2])/(temp2[1,2]+temp2[2,2])}
			if(temp2$temp[1]==0&temp2$temp[2]==2){maf	<- temp2[2,2]/(temp2[1,2]+temp2[2,2])}
			}
		if(nrow(temp2)==1)
			{
			if(temp2$temp[1]==0){maf	<- 0}
			if(temp2$temp[1]==1){maf	<- 0.5}
			if(temp2$temp[1]==2){maf	<- 1}
			}
		mafmyway[i]	<- maf
		}
	snps$mafmyway	<<- mafmyway
	}

correctmaf<-function(popnames=mysambar$populations,indthreshold=0.25)
	{
	# Due to excluding datapoints, the allele which is listed as minor might have become major
	# For example: if you have: 1 2 2 0 0, and the last individual is removed, then the minor allele has become the major allele
	# this function makes the correction 
	indfilter						<- inds$miss<=indthreshold
	currentmaf						<- snps$maf
	currentmaf[is.na(currentmaf)]	<- 0		# Otherwise following error: Error in snps$minor[currentmaf > 0.5] <- mymajor[currentmaf > 0.5] : NAs are not allowed in subscripted assignments
	n_above0.5					<- length(currentmaf[currentmaf>0.5])
	if(n_above0.5==0)
		{
		return(cat("No snps with maf > 0.5. No need to correct maf.",sep="\n"))
		}
	# else we need to make the correction:
	myminor							<- snps$minor
	mymajor							<- snps$major
	snps$minor[currentmaf>0.5]		<<- mymajor[currentmaf>0.5]
	snps$major[currentmaf>0.5]		<<- myminor[currentmaf>0.5]
	myminorcount					<- snps$minorcount
	mymajorcount					<- snps$majorcount
	snps$minorcount[currentmaf>0.5]	<<- mymajorcount[currentmaf>0.5] 
	snps$majorcount[currentmaf>0.5]	<<- myminorcount[currentmaf>0.5]
	snps$maf[currentmaf>0.5]		<<- (1-currentmaf)[currentmaf>0.5]
	for (j in popnames)
		{
		mypopmaf					<- snps[,names(snps) == paste("maf",j,sep="_")]
		snps[currentmaf>0.5,names(snps) == paste("maf",j,sep="_")]	<<- (1-mypopmaf)[currentmaf>0.5] 
		}
	# edit data in genlight object:
	mymatrix					<- as.matrix(mygenlight)
	mymatrix1					<- mymatrix[,currentmaf>0.5]
	mymatrix2					<- mymatrix[,currentmaf<=0.5]
	tempmatrix					<- mymatrix1
	mymatrix1[tempmatrix==0]	<- 2
	mymatrix1[tempmatrix==2]	<- 0
	if(n_above0.5==1)
		{
		temp					<- as.matrix(mymatrix1)
		colnames(temp)			<- colnames(mymatrix)[currentmaf>0.5]
		mymatrix1				<- temp
		}
	mymatrix3				<- cbind(mymatrix1,mymatrix2)
	mymatrix4					<- mymatrix3[,order(colnames(mymatrix3))]
	# now reorder matrix3 to order of snps in snps dataframe:
	snpstemp					<- snps[order(snps$name),]
	#mymatrix5					<- mymatrix4[,order(as.numeric(snpstemp$chr),as.numeric(snpstemp$pos))]
	mymatrix5					<- mymatrix4[,order(snpstemp$chr,as.numeric(snpstemp$pos))]
	mygenlight					<<- as.genlight(mymatrix5)
	mygenlight@pop				<<- as.factor(inds$pop2)
	# if this function has been executed before, remove columns produced during previous execution:
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	#
	currentmaf					<<- currentmaf
	mymatrix					<<- mymatrix
	mymatrix1					<<- mymatrix1
	mymatrix2					<<- mymatrix2
	mymatrix3					<<- mymatrix3
	mymatrix4					<<- mymatrix4
	mymatrix5					<<- mymatrix5
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: after reordering, column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
	}
	
# depreciated:
correctmaf_old<-function(popnames=mysambar$populations,indthreshold=0.25)
	{
	# Due to excluding datapoints, the allele which is listed as minor might have become major
	# For example: if you have: 1 2 2 0 0, and the last individual is removed, then the minor allele has become the major allele
	# this function makes the correction 
	indfilter	<- inds$miss<=indthreshold
	mymatrix	<- as.matrix(mygenlight)
	for (i in (1:(ncol(mymatrix))))
		{
		if (snps$maf[i]>0.5)
			{
			# edit snps-dataframe:
			myminor				<- snps$minor[i]
			mymajor				<- snps$major[i]
			snps$minor[i]		<<- mymajor
			snps$major[i]		<<- myminor
			myminorcount		<- snps$minorcount[i]
			mymajorcount		<- snps$majorcount[i]
			snps$minorcount[i]	<<- mymajorcount 
			snps$majorcount[i]	<<- myminorcount
			mymaf				<- snps$maf[i]
			snps$maf[i]			<<- 1-mymaf
			for (j in popnames)
				{
				mypopmaf		<- snps[i,names(snps) == paste("maf",j,sep="_")]
				snps[i,names(snps) == paste("maf",j,sep="_")]	<<- 1-mypopmaf 
				}
			# edit data in genlight object:
			temp				<- mymatrix[,i]
			temp[temp==0]		<- 3
			temp[temp==2]		<- 0
			temp[temp==3]		<- 2
			mymatrix[,i]		<- temp
			}
		}
	mygenlight		<<- as.genlight(mymatrix)
	mygenlight@pop	<<- as.factor(inds$pop2)
	# Per population: (double?)
	#for (i in (1:length(popnames)))
	#	{
	#	snps$maftemp 	<<- glMean(mygenlight[indfilter&inds$pop2==popnames[i],])
	#	names(snps)[names(snps) == "maftemp"] <<- paste("maf",popnames[i],sep = "_")
	#	}
	# if this function has been executed before, remove columns produced during previous execution:
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}	
	
getpopmaf<-function(popnames=mysambar$populations,dofilter=TRUE,snpthreshold=0.1)
	{
	# It can happen that a certain allele is the minor allele in the meta population but the major allele in the subpopulation.
	# The maf_popname columns in the snp dataset define minor alleles based on the meta pop reference.
	# This function will create new columns (maf2_popname) which define minor allele based on the subpopulation.
	# This maf2-column is needed for intrapopulation analyses, such as sfs plot. 
	# For comparisons between populations, use maf-column rather than maf2-column.   
	inds$popmaf			<<- NA
	inds$popmaf_all		<<- NA
	popnames			<- as.vector(popnames) 
	for (i in (1:length(popnames)))
		{
		mymaf					<- snps[names(snps) == paste("maf",popnames[i],sep="_")]
		mymaf					<- as.vector(unlist(mymaf))
		snps$mymaf				<<- mymaf
		mymaf[is.na(mymaf)]		<- 0
		snps$mymaf[mymaf>0.5]	<<- 1-mymaf[mymaf>0.5] 
		if(!dofilter)
			{
			snpfilter				<- snps$miss<=snpthreshold
			myfilter1				<- snpfilter&is.finite(snps$mymaf)
			myfilter2				<- snpfilter&snps$mymaf>0&is.finite(snps$mymaf)
			}else{
			myfilter1				<- is.finite(snps$mymaf)
			myfilter2				<- is.finite(snps$mymaf)
			}
		inds$popmaf[inds$pop2==popnames[i]]			<<- mean(snps$mymaf[myfilter2],na.rm=TRUE)
		inds$popmaf_all[inds$pop2==popnames[i]]		<<- mean(snps$mymaf[myfilter1],na.rm=TRUE)
		inds$expHe[inds$pop2==popnames[i]]			<<- mean(2*snps$mymaf[myfilter2]*(1-snps$mymaf[myfilter2]),na.rm=TRUE)				# all sites
		inds$expHe_all[inds$pop2==popnames[i]]		<<- mean(2*snps$mymaf[myfilter1]*(1-snps$mymaf[myfilter1]),na.rm=TRUE)	
		names(snps)[names(snps) == "mymaf"] 		<<- paste("maf2",popnames[i],sep = "_")
		}
	snps$mymaf	<<- NULL
	snps 		<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}

snp_hetero<-function(popnames=mysambar$populations,indthreshold=0.25,snpthreshold=0.1)
	{
	# Locusspecific heterozygosities:
	indfilter	<- inds$miss <= indthreshold
	snpfilter	<- snps$miss <= snpthreshold
	mymatrix 	<- as.matrix(mygenlight[indfilter,])
	#snps$hetero	<<- apply(mymatrix,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
	mymatrix[is.na(mymatrix)]	<- 3
	snps$hetero	<<- apply(mymatrix,2,function(z){(length(z[z==1])/length(z[z!=3]))})
	# get genotype counts:
	AA_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==0))))
	Aa_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==1))))
	aa_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==2))))
	#na_vector	<- as.vector(apply(mymatrix, 2, function(c)length(c[is.na(c)])))
	na_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==3))))
	snps$AA		<<- AA_vector	
	snps$Aa		<<- Aa_vector	
	snps$aa		<<- aa_vector	
	# optionally check if everything adds up:
	mysum		<- AA_vector+Aa_vector+aa_vector+na_vector
	mysum2		<- AA_vector+Aa_vector+aa_vector
	myhetero2	<<- snps$Aa/mysum2			# if(snps$hetero!=snps$hetero2), something is wrong
	# to compare observed genotypes with expected genotypes:
	snps$expAA	<<- round((1-snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expAa	<<- round(2*(snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expaa	<<- round(snps$maf*snps$maf*snps$nonmissallelecount/2)
	# Per population:
	for (i in (1:length(popnames)))
		{
		matrixtemp						<- as.matrix(mygenlight[indfilter&inds$pop2==popnames[i],])
		#snps$heterotemp				<<- apply(matrixtemp,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		matrixtemp[is.na(matrixtemp)]	<- 3		# because otherwise NA's are counted as 1.
		snps$heterotemp					<<- apply(matrixtemp,2,function(z){(length(z[z==1])/length(z[z!=3]))})
		names(snps)[names(snps) == "heterotemp"] <<- paste("hetero",as.vector(popnames[i]),sep = "")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}	

snp_hetero_old<-function(popnames=mysambar$populations,indthreshold=0.25,snpthreshold=0.1)
	{
	# Locusspecific heterozygosities:
	indfilter	<- inds$miss <= indthreshold
	snpfilter	<- snps$miss <= snpthreshold
	mymatrix 	<- as.matrix(mygenlight[indfilter,])
	snps$hetero	<<- apply(mymatrix,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
	for (i in (1:nrow(snps)))
		{
		temp2		<- mymatrix[,i]
		temp		<- temp2==0
		temp		<- ifelse(is.na(temp),FALSE,temp)
		snps$AA[i]	<<- length(temp[temp])
		snps$Aa[i]	<<- sum(temp2[temp2==1],na.rm=TRUE)
		snps$aa[i]	<<- 1/2*sum(temp2[temp2==2],na.rm=TRUE)
		#snps$hetero2[i]	<<- snps$Aa[i]/(snps$AA[i]+snps$Aa[i]+snps$aa[i])
		# if(snps$hetero!=snps$hetero2), something is wrong
		}
	# to compare observed genotypes with expected genotypes:
	#nrofinds	<- length(inds$nr[indmissfilter])
	snps$expAA	<<- round((1-snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expAa	<<- round(2*(snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expaa	<<- round(snps$maf*snps$maf*snps$nonmissallelecount/2)
	# Per population:
	for (i in (1:length(popnames)))
		{
		matrixtemp						<- as.matrix(mygenlight[indfilter&inds$pop2==popnames[i],])
		# snps$heterotemp				<<- apply(matrixtemp,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		matrixtemp[is.na(matrixtemp)]	<- 3		# because otherwise NA's are counted as 1.
		snps$heterotemp					<<- apply(matrixtemp,2,function(z){(length(z[z==1])/length(z[z!=3]))})
		names(snps)[names(snps) == "heterotemp"] <<- paste("hetero",as.vector(popnames[i]),sep = "")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}		
	
chrom_He_maf<-function(mychroms=NULL,addX=TRUE,export=NULL)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("MAF_He_perchrom.eps",family=mysambar$myfont,width=25,height=10)}
		if(export=="pdf"){pdf("MAF_He_perchrom.pdf",family=mysambar$myfont,width=25,height=10)}
		if(export=="png"){png("MAF_He_perchrom.png",family=mysambar$myfont,width=1800,height=720)}
		if(export=="wmf"){win.metafile("MAF_He_perchrom.wmf",family=mysambar$myfont,width=25,height=10)}
		}
	par(mfrow=c(2,1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
	boxplot(snps$maf[snps$placed]~as.vector(snps$chr[snps$placed]),main="",xaxt='n',ylab="Minor allele frequencies")
	boxplot(snps$hetero[snps$placed]~as.vector(snps$chr[snps$placed]),main="",xlab="Chromosome",ylab="Heterozygosities")
	mtext("Chromosome",side=1,cex=2.5,line=3)
	if(!is.null(export)){dev.off()}
	}

filters<-function(indthreshold=0.25,snpthreshold=0.1,mac=2,mindistance=500,hefilter=TRUE,paralogthreshold1=0.5,paralogthreshold2=0.05,export=NULL,silent=TRUE)
	{
	##### For individuals:
	inds$filter		<<- inds$miss<=indthreshold
	mynind			<- as.data.frame(table(inds$pop[inds$filter]))
	inds$pop_ninds	<<- NA
	for (i in c(1:nrow(inds)))
		{
		mypop				<- inds$pop[i]
		mypop2				<- which(mynind$Var1==mypop)
		inds$pop_ninds[i]	<<- mynind$Freq[mypop2]
		}
	##### For snps:
	# filter out paralogs (based on maf-he relationship):
	if(hefilter)
		{
		snps$hefilter		<<- (snps$maf<paralogthreshold2)|(snps$hetero<(paralogthreshold1*snps$maf+(2*snps$maf*(1-snps$maf))))
		}else{
		snps$hefilter		<<- TRUE
		}
	# Is snp on different contig or at least certain number of bp away from previous snp?
	chrfilter			<- (as.vector(snps$chr))!=c(as.vector(snps$chr[2:length(snps$chr)]),as.factor("dummy"))
	chrfilter			<- c(TRUE,chrfilter[1:(length(chrfilter)-1)])
	if("dist" %in% colnames(snps))
		{
		snps$distfilter	<<- chrfilter|(snps$dist>=mindistance)
		}else{
		snps$distfilter	<<- TRUE
		}
	# Does snp have at least certain number of minor alleles?
	if(!is.null(mac))
		{
		macfilter		<- snps$minorcount >= mac
		}else{
		macfilter		<- TRUE
		}
	if(!silent){cat("Setting overall filter.",sep="\n")}
	# Set overall filters:
	snps$filter			<<- (snps$miss<=snpthreshold)&snps$hefilter&macfilter&snps$uniqpos&snps$depthfilter&snps$distfilter&snps$poly
	snps$filter2		<<- (snps$miss<=snpthreshold)&snps$hefilter&macfilter&snps$uniqpos&snps$depthfilter&snps$poly
	if(!silent){cat("Overall filters set.",sep="\n")}
	# The following lines are necessary to present the error: Error in if (!any(snps$filter)) { : missing value where TRUE/FALSE needed
	# Although probably if there is a NA, the problem was earlier.
	snps$filter[is.na(snps$filter)]		<<- FALSE	
	snps$filter2[is.na(snps$filter2)]	<<- FALSE	
	# remove duplicate columns:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)]
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	#
	# create heatmap showing number of filter data:
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Filterclasses.eps",family=mysambar$myfont,width=12,height=11)}
		if(export=="pdf"){pdf("Filterclasses.pdf",family=mysambar$myfont,width=12,height=11)}
		if(export=="png"){png("Filterclasses.png",family=mysambar$myfont,width=1200,height=1100)}
		if(export=="wmf"){win.metafile("Filterclasses.wmf",family=mysambar$myfont,width=12,height=11)}
		}
	mytable				<- matrix(NA,ncol=7,nrow=6)
	colnames(mytable)	<- c("overall","miss","he","mac","dist","depth","poly")
	rownames(mytable)	<- c("overall","miss","he","mac","dist","depth")
	mytable[1,1]		<- length(snps$name[!(snps$filter)])
	mytable[1,2]		<- length(snps$name[!(snps$filter)&snps$miss>snpthreshold])
	mytable[1,3]		<- length(snps$name[!(snps$filter)&!(snps$hefilter)])
	mytable[1,4]		<- length(snps$name[!(snps$filter)&snps$minorcount<mac])
	mytable[1,5]		<- length(snps$name[!(snps$filter)&!(snps$distfilter)])
	mytable[1,6]		<- length(snps$name[!(snps$filter)&!(snps$depthfilter)])
	mytable[1,7]		<- length(snps$name[!(snps$filter)&!(snps$poly)])
	#mytable[2,2]		<- length(snps$name[snps$miss>snpthreshold&snps$miss>snpthreshold])
	mytable[2,3]		<- length(snps$name[snps$miss>snpthreshold&!(snps$hefilter)])
	mytable[2,4]		<- length(snps$name[snps$miss>snpthreshold&snps$minorcount<mac])
	mytable[2,5]		<- length(snps$name[snps$miss>snpthreshold&!(snps$distfilter)])
	mytable[2,6]		<- length(snps$name[snps$miss>snpthreshold&!(snps$depthfilter)])
	mytable[2,7]		<- length(snps$name[snps$miss>snpthreshold&!(snps$poly)])
	#mytable[3,3]		<- length(snps$name[!(snps$hefilter)&!(snps$hefilter)])
	mytable[3,4]		<- length(snps$name[!(snps$hefilter)&snps$minorcount<mac])
	mytable[3,5]		<- length(snps$name[!(snps$hefilter)&!(snps$distfilter)])
	mytable[3,6]		<- length(snps$name[!(snps$hefilter)&!(snps$depthfilter)])
	mytable[3,7]		<- length(snps$name[!(snps$hefilter)&!(snps$poly)])
	#mytable[4,4]		<- length(snps$name[snps$minorallelecount<mac&snps$minorcount<mac])
	mytable[4,5]		<- length(snps$name[snps$minorallelecount<mac&!(snps$dist)])
	mytable[4,6]		<- length(snps$name[snps$minorallelecount<mac&!(snps$depthfilter)])
	mytable[4,7]		<- length(snps$name[snps$minorallelecount<mac&!(snps$poly)])
	#mytable[5,5]		<- length(snps$name[!(snps$distfilter)&!(snps$distfilter)])
	mytable[5,6]		<- length(snps$name[!(snps$distfilter)&!(snps$depthfilter)])
	mytable[5,7]		<- length(snps$name[!(snps$distfilter)&!(snps$poly)])
	#mytable[6,6]		<- length(snps$name[!(snps$depthfilter)&!(snps$depthfilter)])
	mytable[6,7]		<- length(snps$name[!(snps$depthfilter)&!(snps$poly)])
	#mytable[7,7]		<- length(snps$name[!(snps$poly)&!(snps$poly)])
	# define colours:
	mymax		<- max(mytable,na.rm=TRUE)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myBreaks	<- seq(0,1000,100)
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	# create heatmap:
	heatmap.2(lwid=c(0.5,4),lhei=c(0.5,4),mytable,cellnote=ifelse(!is.na(mytable),mytable,""),notecol="black",adjRow = c(0.5,0.5),adjCol=c(NA,0.5),notecex=3,cex.lab=2,cexRow=3,cexCol=3,Colv=FALSE,Rowv=FALSE,scale="none",dendrogram="none",key=FALSE,col=myColours,keysize=1,trace="none",ylab = "",xlab = "",srtCol=45,srtRow=45)
	mtext("Number of filtered SNPs", side = 3, line = 0.5, cex = 3)
	if(!is.null(export)){dev.off()}
	}
	
ind_maf<-function(popnames=mysambar$populations,allsites=FALSE)	
	{
	# This function calculates the average number of minor alleles (relative to metapopulation) per locus.
	# For each locus (2 alleles) the outcome can be: 
	# 0/2 = 0
	# 1/2 = 0.5
	# 2/2 = 1
	# This is averaged over all loci. Say for example we have the following genotype score for 10 loci:
	# 1 0 0 1 
	# Then we: (1 + 1)/8 = 0.25. 
	# So each locus 25 percent of observing a minor allele, according to calculations. 
	# This is correct, because the probabilities per locus are 0.5, 0, 0, 0.5. 
	# As a side note: we observe 50 percent heterozygous loci. This is a slight he-excess, because expected heterozygosity is: 2*0.25*0.75 = 0.375.  
	#   	
	# If allsites = TRUE, maf is calculated for all sites, including sites which are not segregating within the population to which the individual belongs
	# If allsites = TRUE, results will be stored in column inds_maf_all
	# If allsites = FALSE (default), maf is calculated for segregating sites only
	# If allsites = FALSE (default), results will be stored in column inds_maf
	indmaf					<- rep(NA,nrow(inds))
	nsegsites1				<- rep(NA,nrow(inds))
	nsegsites2				<- rep(NA,nrow(inds))
	nsegsites3				<- rep(NA,nrow(inds))
	nsegsites4				<- rep(NA,nrow(inds))
	n0						<- rep(NA,nrow(inds))
	n1						<- rep(NA,nrow(inds))
	n2						<- rep(NA,nrow(inds))
	ntotal					<- rep(NA,nrow(inds))
	for (i in (1:(nrow(inds))))
		{
		#cat(as.vector(inds$name[i]),sep="\n")
		mypop				<- as.vector(inds$pop[i])
		if(allsites)
			{
			temp			<- as.matrix(mygenlight[i,snps$filter])
			mymaf1			<- snps[snps$filter,names(snps)==paste("maf",mypop,sep="_")]
			mymaf2			<- snps[snps$filter,names(snps)==paste("maf2",mypop,sep="_")]
			}else{
			mypop			<- inds$pop2[i]
			mypopmaf		<- snps[,names(snps) == paste("maf",mypop,sep="_")] 	
			mypopmaf[is.na(mypopmaf)]	<- 0	# 09-07-2019: to prevent ERROR: 'ERROR in 1:nLoc(x) : NA/NaN argument'
			temp			<- as.matrix(mygenlight[i,snps$filter&mypopmaf>0])
			mymaf1			<- snps[snps$filter&mypopmaf>0,names(snps)==paste("maf",mypop,sep="_")]
			mymaf2			<- snps[snps$filter&mypopmaf>0,names(snps)==paste("maf2",mypop,sep="_")]
			nsegsites1[i]	<- ncol(temp)
			nsegsites2[i]	<- length(temp[!is.na(temp)])
			temp2			<- as.matrix(mygenlight[i,mypopmaf>0])
			nsegsites3[i]	<- ncol(temp2)
			nsegsites4[i]	<- length(temp2[!is.na(temp2)])
			}
		temp2	<- as.data.frame(table(temp))
		# number of 1's (heterozygous sites): 	(length(z[z==1])-(length(z)-length(z[!is.na(z)]))
		# indmaf[i]			<- apply(temp,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)]))+2*(length(z[z==2])-(length(z)-length(z[!is.na(z)]))))/(2*length(z[!is.na(z)])))
		# the apply-function works fine, but this one is easier to understand:
		#
		# correct for minor alleles which flipped over in subpopulation to becoming major allele:
		temp4				<- temp
		temp[(mymaf1!=mymaf2)&temp4==2]	<- 0
		temp[(mymaf1!=mymaf2)&temp4==0]	<- 2
		# now we are ready to calculate average proportion of minor alleles:
		temp3				<- temp[!is.na(temp)]
		n0[i]				<- length(temp3[temp3==0])
		n1[i]				<- length(temp3[temp3==1])
		n2[i]				<- length(temp3[temp3==2])
		ntotal[i]			<- length(temp3)
		indmaf[i]			<- sum(temp3)/(2*length(temp3))		# 2 alleles per locus, so hence times 2
		}
	if(allsites)
		{
		inds$maf_all		<<- indmaf
		inds$n0				<<- n0
		inds$n1				<<- n1
		inds$n2				<<- n2
		inds$ndata			<<- ntotal
		}else{
		inds$maf			<<- indmaf
		inds$nsegsites1		<<- nsegsites1
		inds$nsegsites2		<<- nsegsites2
		inds$nsegsites3		<<- nsegsites3
		inds$nsegsites4		<<- nsegsites4
		}
	# if this function has been executed before, remove columns produced during previous execution:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	}

ind_hetero<-function(popnames=mysambar$populations,chrominfo=FALSE,allsites=FALSE)
	{
	# Calculates individual heterozygosities:
	indhet		<- rep(NA,nrow(inds))
	indhet2		<- rep(NA,nrow(inds))
	indhetX		<- rep(NA,nrow(inds))
	indnsites1	<- rep(NA,nrow(inds))
	indnsites2	<- rep(NA,nrow(inds))
	for (i in (1:(nrow(inds))))
		{
		if(chrominfo)
			{
			if(allsites)
				{
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter&snps$chr!="X"])
				Xmatrix		<- as.matrix(mygenlight[i,snps$filter&snps$chr=="X"])
				}else{
				mypop		<- inds$pop2[i]
				mypopmaf	<- snps[,names(snps) == paste("maf",mypop,sep="_")]
				mypopmaf[is.na(mypopmaf)]	<- 0	# 09-07-2019: to prevent ERROR: 'ERROR in 1:nLoc(x) : NA/NaN argument'
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter&snps$chr!="X"&mypopmaf>0])
				Xmatrix		<- as.matrix(mygenlight[i,snps$filter&snps$chr=="X"&mypopmaf>0])
				}
			# the next seemingly complicated formula is necessary because NA are counted as 1's.
			# the formula has the following structure:
			# ((number of He-sites) - (number of sites with missing data))/(number of sites without missing data) 
			# For example, the following vector: 2 0 NA 1 1 NA
			# would result in:
			# 4 - (4 - 2))/4				
			indnsites1[i]	<- apply(mymatrix,1,function(z) length(z))
			indnsites2[i]	<- apply(mymatrix,1,function(z) length(z[!is.na(z)]))
			indhet[i]		<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
			indhetX[i]		<- apply(Xmatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
			}else{
			if(allsites)
				{
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter])
				}else{
				mypop		<- inds$pop2[i]
				mypopmaf	<- snps[,names(snps) == paste("maf",mypop,sep="_")]
				mypopmaf[is.na(mypopmaf)]	<- 0	# 09-07-2019: to prevent ERROR: 'ERROR in 1:nLoc(x) : NA/NaN argument'
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter&mypopmaf>0])
				}
			# the next seemingly complicated formula is necessary because NA are counted as 1's.
			indnsites1[i]	<- apply(mymatrix,1,function(z) length(z))
			indnsites2[i]	<- apply(mymatrix,1,function(z) length(z[!is.na(z)]))
			indhet[i]		<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
			}
		}
	if(!allsites)	{inds$hetero	<<- indhet}
	if(!allsites)	{inds$hetero[inds$popmaf==0]	<<- 0}		# necessary because of line: mymatrix 	<- as.matrix(mygenlight[i,snps$filter&mypopmaf>0]) 
	if(allsites)	{inds$nsites1	<<- indnsites1}
	if(allsites)	{inds$nsites2	<<- indnsites2}
	if(allsites)	{inds$hetero_all<<- indhet}
	if(chrominfo)	{inds$heteroX	<<- indhetX}
	if(allsites&&chrominfo)	{inds$heteroX_all<<- indhetX}
	# if this function has been executed before, remove columns produced during previous execution:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	}	

plotlocusdepth<-function(export=FALSE)
	{
	myscores	<- snps$meandepth[!is.na(snps$meandepth)]
	temp		<- myscores[myscores<quantile(myscores,0.995)]
	mythreshold	<- qnorm((1-0.05/length(myscores)), mean = mean(temp,na.rm=TRUE), sd = sd(temp,na.rm=TRUE), lower.tail = TRUE, log.p = FALSE)
	hs			<- hist(log(myscores),breaks=1000)
	if(export){pdf("Locusdepth.pdf")}
	par(layout(matrix(c(1,1,1,1,1,1,1,1,2),1,9)),mar=c(2,0,2,0),oma=c(3,7,2,2))
	plot(myscores,log="y",cex=0.75,pch=16,cex.axis=1.5,cex.lab=2,las=1)
	points(c(1:length(myscores))[myscores>mythreshold],myscores[myscores>mythreshold],cex=0.75,pch=16,col="red")
	abline(h=mythreshold,lty=2)
	mtext("Mean read depth",side=2,line=4,cex=2)
	mtext("SNP index",side=1,line=4,cex=2)
	# add histogram on the side
	plot(NA, type='n', axes=FALSE, yaxt='n',xlab='',ylab=NA,main=NA,xlim=c(0,max(hs$counts)),ylim=c(1,length(hs$counts)))
	arrows(rep(0,length(hs$counts)),1:length(hs$counts),hs$counts,1:length(hs$counts),length=0,angle=0,lwd=2,col="grey")
	if(export){dev.off()}
	}

plotHe_perind<-function(export=NULL,genomehe=FALSE)
	{
	ninds	<- nrow(inds[inds$filter,])
	if(!is.null(export))
		{
		plotname	<- ifelse(genomehe,"Genomehe_per_ind","He_per_ind")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=ninds*0.25,width=15)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=ninds*0.25,width=15)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=ninds*25,width=1500)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=ninds*0.25,width=15)}
		}
	indstemp	<- inds[order(inds$pop2),]
	if(!genomehe)
		{
		myhe	<- indstemp$hetero_all
		}else{
		myhe	<- indstemp$genomehe
		}
	barplot(myhe[indstemp$filter],col=indstemp$popcol[indstemp$filter],border=indstemp$popcol[indstemp$filter],horiz=TRUE,names.arg=indstemp$nr[indstemp$filter],las=1)	
	if(!genomehe)
		{
		mtext(side=1,"Heterozygosity",line=2.5,cex=2)
		}else{
		mtext(side=1,"Genome wide heterozygosity",line=2.5,cex=2)
		}
	if(!is.null(export)){dev.off()}
	}
	
retainedsites_perpop<-function(export=NULL)
	{
	npops	<- length(mysambar$populations)
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Retainedsites.perpop.eps",family=mysambar$myfont,width=npops*2.5,height=6)}
		if(export=="pdf"){pdf("Retainedsites.perpop.pdf",family=mysambar$myfont,width=npops*2.5,height=6)}
		if(export=="png"){png("Retainedsites.perpop.png",family=mysambar$myfont,width=npops*360,height=720)}
		if(export=="wmf"){win.metafile("Retainedsites.perpop.wmf",family=mysambar$myfont,width=npops*2.5,height=6)}
		}
	par(mar=c(4,8,0.5,0.5))
	boxplot(inds$nsites2[inds$filter]~inds$pop[inds$filter],col=mysambar$mycolour[order(mysambar$populations)],las=1,xlab="",ylab="",cex.axis=1.5,cex.axis=2,pch=16)
	mtext(side=2,"Number of retained sites",line=5,cex=2)
	mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

retainedinds_perpop<-function(export=NULL,popnames=mysambar$populations)
	{
	npops		<- length(mysambar$populations)
	nindsperpop	<- table(inds$pop[inds$filter])
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Retainedinds.perpop.eps",family=mysambar$myfont)}
		if(export=="pdf"){pdf("Retainedinds.perpop.pdf",family=mysambar$myfont)}
		if(export=="png"){png("Retainedinds.perpop.png",family=mysambar$myfont)}
		if(export=="wmf"){win.metafile("Retainedinds.perpop.wmf",family=mysambar$myfont)}
		}
	par(mar=c(4,8,2.5,2.5))
	barplot(nindsperpop,col=mysambar$mycolours,border=mysambar$mycolours,space=0.1,horiz=TRUE,main="Retained individuals",names.arg=popnames,las=1)
	if(!is.null(export)){dev.off()}
	}	

discardedinds_perpop<-function(export=NULL,popnames=mysambar$populations)
	{
	npops		<- length(mysambar$populations)
	nindsperpop	<- table(inds$pop[!inds$filter])
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Discardedinds.perpop.eps",family=mysambar$myfont)}
		if(export=="pdf"){pdf("Discardedinds.perpop.pdf",family=mysambar$myfont)}
		if(export=="png"){png("Discardedinds.perpop.png",family=mysambar$myfont)}
		if(export=="wmf"){win.metafile("Discardedinds.perpop.wmf",family=mysambar$myfont)}
		}
	par(mar=c(4,8,2.5,2.5))
	barplot(nindsperpop,col=mysambar$mycolours,border=mysambar$mycolours,space=0.1,horiz=TRUE,main="Discarded individuals",names.arg=popnames,las=1)
	if(!is.null(export)){dev.off()}
	}
	
plot_number_segregating_sites<-function(popnames=mysambar$populations,export=NULL,dofilter=FALSE)
	{
	if(dofilter)
		{
		mysegsites	<- inds$nsegsites4
		}else{
		mysegsites	<- inds$nsegsites2
		}
	# plot:
	graphics.off()
	if(!is.null(export))
		{
		mystring	<- ifelse(dofilter,"retained","all")
		if(export=="eps"){postscript(paste("Segregatingsites",mystring,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("Segregatingsites",mystring,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("Segregatingsites",mystring,"eps",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("Segregatingsites",mystring,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)	
	mymin					<- (min(c(min(inds$nsites2),min(mysegsites))))/1000
	mymax					<- (max(c(max(inds$nsites2),max(mysegsites))))/1000
	plot(inds$nsites2[inds$filter]/1000,mysegsites[inds$filter]/1000,xlim=c(mymin,mymax),ylim=c(mymin,mymax),main="Proportion segregating sites",xlab="# Retained sites (x 1000)",ylab="# Retained segregating sites (x 1000)",cex=2.5)
	for (j in c(1:length(popnames)))
		{
		mypop				<- popnames[j]
		points(inds$nsites2[inds$pop2==mypop&inds$filter]/1000,mysegsites[inds$pop2==mypop&inds$filter]/1000,col=mysambar$mycolours[j],pch=16,cex=2.5)
		points(inds$nsites2[inds$pop2==mypop&!inds$filter]/1000,mysegsites[inds$pop2==mypop&!inds$filter]/1000,col=mysambar$mycolours[j],cex=2.5)
		}
	lines(c(-1000,nrow(snps)),c(-1000,nrow(snps)))
	legend("topleft",legend=popnames,bty='n',fill=unique(inds$popcol),cex=2)
	if(!is.null(export)){dev.off()}
	}
	
mysummarytable<-function()
	{
	options(scipen=999)	# no scientific notation
	if("dist" %in% colnames(snps))
		{
		mydf				<- as.data.frame(matrix(NA,nrow=8,ncol=3))
		rownames(mydf)		<- c("Number of individuals","Number of SNPs","Percentage of SNPs with maf >= 0.05","Mean spacing between SNPs","Median spacing between SNPs","Mean proportion of missing data per individual","GC content","Transition vs transversion ratio")
		colnames(mydf)		<- c("Before filtering","After filtering","After thinning")
		for(i in (c(1:3)))
			{
			if(i==1){snpstemp<-snps;indstemp<-inds}
			if(i==2){snpstemp<-snps[snps$filter2,];indstemp<-inds[inds$filter,]}
			if(i==3){snpstemp<-snps[snps$filter,];indstemp<-inds[inds$filter,]}
			mydf[1,i]		<- nrow(indstemp)
			mydf[2,i]		<- nrow(snpstemp)
			mydf[3,i]		<- 100*nrow(snpstemp[snpstemp$maf>=0.05,])/nrow(snpstemp)
			mydf[4,i]		<- mean(snpstemp$dist,na.rm=TRUE)
			mydf[5,i]		<- median(snpstemp$dist,na.rm=TRUE)
			mydf[6,i]		<- mean(indstemp$miss,na.rm=TRUE)
			mydf[7,i]		<- nrow(snpstemp[snpstemp$GC,])/(nrow(snpstemp))
			mydf[8,i]		<- nrow(snpstemp[snpstemp$transit,])/(nrow(snpstemp[!snpstemp$transit,]))
			}
		}else{
		mydf				<- as.data.frame(matrix(NA,nrow=6,ncol=2))
		rownames(mydf)		<- c("Number of individuals","Number of SNPs","Percentage of SNPs with maf >= 0.05","Mean proportion of missing data per individual","GC content","Transition vs transversion ratio")
		colnames(mydf)		<- c("Before filtering","After filtering")
		for(i in (c(1:2)))
			{
			if(i==1){snpstemp<-snps;indstemp<-inds}
			if(i==2){snpstemp<-snps[snps$filter2,];indstemp<-inds[inds$filter,]}
			if(i==3){snpstemp<-snps[snps$filter,];indstemp<-inds[inds$filter,]}
			mydf[1,i]		<- nrow(indstemp)
			mydf[2,i]		<- nrow(snpstemp)
			mydf[3,i]		<- 100*nrow(snpstemp[snpstemp$maf>=0.05,])/nrow(snpstemp)	
			mydf[4,i]		<- mean(indstemp$miss,na.rm=TRUE)
			mydf[5,i]		<- nrow(snpstemp[snpstemp$GC,])/(nrow(snpstemp))
			mydf[6,i]		<- nrow(snpstemp[snpstemp$transit,])/(nrow(snpstemp[!snpstemp$transit,]))
			}
		}
	mydf				<- round(mydf,2)
	write.table(mydf,"SambaR.summarystats.txt",row.names=TRUE,col.names=TRUE,quote=FALSE,sep="\t")
	}	

plotminor<-function(export=NULL)
	{	
	if(length(table(snps$minor[snps$minor!=0&!is.na(snps$minor)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present. Omitting minor allele histogram.",sep="\n"))
		}
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Minoralleles.pdf",width=16,height=6)}	
		if(export=="pdf"){pdf("Minoralleles.pdf",width=16,height=6)}
		if(export=="png"){png("Minoralleles.png",width=1260,height=600)}
		if(export=="wmf"){win.metafile("Minoralleles.wmf",width=16,height=6)}
		}
	par(mfrow=c(1,3),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	mytable<-table(snps$minor2)
	mytable<- round(mytable/1000,1)
	mymax<-(max(mytable)+5)
	xx<-barplot(mytable,col=c("darkred","blue","gold","darkgreen"),ylim=c(0,mymax),xlab="",ylab="",las=1)
	text(x = xx, y = mytable,label=mytable,pos=3,col="black",cex=2.5)
	mtext("Before filtering",side=3,cex=2,line=-1.5)
	mtext("Number of SNPs (x 1000)",side=2,line=3.5,cex=2)
	mytable<-table(snps$minor2[snps$filter2])
	mytable<- round(mytable/1000,1)
	xx<-barplot(mytable,col=c("darkred","blue","gold","darkgreen"),ylim=c(0,mymax),las=1)
	text(x = xx, y = mytable,label=mytable,pos=3,col="black",cex=2.5)
	mtext("After filtering",side=3,cex=2,line=-1.5)
	mtext("Nucleotide",side=1,cex=2,line=3.5)
	mytable<-table(snps$minor2[snps$filter])
	mytable<- round(mytable/1000,1)
	xx<-barplot(mytable,col=c("darkred","blue","gold","darkgreen"),ylim=c(0,mymax),xlab="",las=1)
	text(x = xx, y = mytable,label=mytable,pos=3,col="black",cex=2.5)
	mtext("After filtering and thinning",side=3,cex=2,line=-1.5)
	mtext("Distribution of minor alleles",side=3,outer=TRUE,cex=2,line=-3.5)
	if(!is.null(export)){dev.off()}
	}

plottransits<-function(filter=FALSE,thin=FALSE,export=NULL)
	{
	if(length(table(snps$minor[snps$minor!=0&!is.na(snps$minor)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present. Omitting transition-transversion matrix.",sep="\n"))
		}
	if(filter)			{mytable	<- table(snps$major2[snps$filter2],snps$minor2[snps$filter2])}
	if(thin)			{mytable	<- table(snps$major2[snps$filter],snps$minor2[snps$filter])}
	if(!(filter|thin))	{mytable	<- table(snps$major2,snps$minor2)}
	if(nrow(mytable)<2|ncol(mytable)<2)
		{
		return()			#return(cat("Only 1 allele type (A,C,G or T) as minor or major allele. Skipping transition/transversion plots.",sep="/n"))
		}
	mymax		<- max(mytable)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myBreaks	<- seq(0,mymax,(mymax/10))
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	graphics.off()
	if(!is.null(export))
		{
		if(filter)
			{
			if(export=="eps"){postscript("Transitions_vs_transversions.filtered.wmf",width=10,height=10)}
			if(export=="pdf"){pdf("Transitions_vs_transversions.filtered.pdf",width=10,height=10)}
			if(export=="wmf"){win.metafile("Transitions_vs_transversions.filtered.wmf",width=10,height=10)}
			# png returns blank file
			}
		if(thin)
			{
			if(export=="eps"){postscript("Transitions_vs_transversions.thinned.wmf",width=10,height=10)}
			if(export=="pdf"){pdf("Transitions_vs_transversions.thinned.pdf",width=10,height=10)}
			if(export=="wmf"){win.metafile("Transitions_vs_transversions.thinned.wmf",width=10,height=10)}
			# png returns blank file
			}
		if(!(filter|thin))
			{
			if(export=="eps"){postscript("Transitions_vs_transversions.nofilter.pdf",width=10,height=10)}
			if(export=="pdf"){pdf("Transitions_vs_transversions.nofilter.pdf",width=10,height=10)}
			if(export=="wmf"){win.metafile("Transitions_vs_transversions.nofilter.wmf",width=10,height=10)}
			# png returns blank file
			}
		}
	heatmap.2(lwid=c(0.5,4),lhei=c(0.5,4),mytable,cellnote=ifelse(mytable>0,mytable,""),notecol="black",adjRow = c(0.5,NA),adjCol=c(NA,0.5),notecex=3,cex.lab=2,cexRow=3,cexCol=3,Colv=FALSE,Rowv=FALSE,scale="none",dendrogram="none",key=FALSE,col=myColours,keysize=1.5,trace="none",ylab = "",xlab = "",srtCol=0)
	mtext("Minor allele", side = 1, cex = 3, line = 3.75)
	mtext("Major allele", side = 4, cex = 3, line = 0.75)
	mtext("Transitions vs transversions", side = 3, line = 2, cex = 3)
	if(filter){mtext("After filtering", side = 3, line = -0.5, cex = 2.5)}
	if(thin){mtext("After thinning", side = 3, line = -0.5, cex = 2.5)}
	if(!(filter|thin)){mtext("Before filtering", side = 3, line = -0.5, cex = 2.5)}
	if(!is.null(export)){dev.off()}
	}
	
plotfiltermaf<-function(popnames=mysambar$populations,yrange=c(0,(nrow(snps)/3.5)),export=NULL)
	{
	popnames	<- as.vector(popnames)
	npops		<- length(popnames)
	mycolours	<- as.vector(unique(inds$popcol))
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("MAFperpop.pdf",width=(npops)+1*8+1,height=9)}	
		if(export=="pdf"){pdf("MAFperpop.pdf",width=(npops)+1*8+1,height=9)}
		if(export=="png"){png("MAFperpop.png",width=(npops+1)*800+100,height=900)}
		if(export=="wmf"){win.metafile("MAFperpop.wmf",width=(npops+1)*8+1,height=9)}
		}
	par(mfrow=c(1,length(popnames)+1),mar=c(5,6,5,2),cex.axis=1.75,cex.lab=2,cex.main=2.25)
	hist(snps$maf[snps$filter],40,main = "",ylim=yrange,xlab=NULL)
	mtext("MAF",side=1,line=3.5,cex=2)	
	title("Metapop",line=-3,cex=2.5)
	for (i in (1:length(popnames)))
		{
		#cat(popnames[i],sep="\n")
		maftemp <- glMean(mygenlight[inds$filter&inds$pop2==popnames[i],snps$filter])
		hist(maftemp,40,main ="",ylim=yrange,xlab=NULL,col=mycolours[i],xlim=c(0,1))
		mtext("MAF",side=1,line=3.5,cex=2)	
		title(popnames[i],line=-3,cex=2.5)
		}
	#mtext("Locus specific minor allele frequencies", side = 1, outer = TRUE,line=-2,cex=2)		# not handy if user wants to subselect tiles from the plot
	#mtext("MAF per population", side = 3, outer = TRUE,line=-4.5,cex=3.5)						# not handy if user wants to subselect tiles from the plot
	if(!is.null(export)){dev.off()}
	}	

histo_locusHe<-function(popnames=mysambar$populations,yrange=c(0,(nrow(snps)/4)),mysubtitle=NULL,export=NULL)
	{
	popnames	<- as.vector(popnames)
	npops		<- length(popnames)
	mycolours	<- mysambar$mycolours[1:npops]
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Heperpop.pdf",width=npops*6,height=7)}	
		if(export=="pdf"){pdf("Heperpop.pdf",width=npops*6,height=7)}
		if(export=="png"){png("Heperpop.png",width=npops*600,height=720)}
		if(export=="wmf"){win.metafile("Heperpop.wmf",width=npops*6,height=7)}
		}
	par(mfrow=c(1,length(popnames)+1),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	hist(snps$hetero[snps$filter],40,main = "",ylim=yrange,xlab=NULL,xlim=c(0,1))
	mtext("He",side=1,line=3.5,cex=2)
	title("Metapop",line=-3,cex=2.5)
	for (i in (1:length(popnames)))
		{
		snps 		<<- snps[, !duplicated(colnames(snps))]
		heterotemp	<- snps[names(snps) == paste("hetero",as.vector(popnames[i]),sep = "")]
		heterotemp	<- as.vector(heterotemp[,1])
		heterotemp	<- heterotemp[snps$filter]
		hist(heterotemp,40,main ="",ylim=yrange,xlab=NULL,col=mycolours[i],xlim=c(0,1))
		mtext("He",side=1,line=3.5,cex=2)	
		title(popnames[i],line=-3,cex=2.5)
		}
	#mtext("Locus specific heterozygosity", side = 1, outer = TRUE, line=-2, cex=2)			# not handy if user wants to subselect tiles from the plot
	#mtext("Heterozygosity per population", side = 3, outer = TRUE, line=-4.5, cex=3.5)		# not handy if user wants to subselect tiles from the plot
	if(!is.null(mysubtitle))
		{
		mtext(mysubtitle, side = 3, outer = TRUE,line=-3.5)
		}
	if(!is.null(export)){dev.off()}
	}

boxplot_locusHe<-function(export=NULL,popnames=mysambar$populations)
	{
	npops	<- length(popnames)
	if(npops==1)
		{
		return(cat("Only 1 population. Sambar will not generate boxplot with heterozygosity per population.",sep="\n"))
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("LocusHe.perpop.boxplot.eps",family=mysambar$myfont,width=npops*2,height=6)}
		if(export=="pdf"){pdf("LocusHe.perpop.boxplot.pdf",family=mysambar$myfont,width=npops*2,height=6)}
		if(export=="png"){png("LocusHe.perpop.boxplot.png",family=mysambar$myfont,width=npops*360,height=720)}
		if(export=="wmf"){win.metafile("LocusHe.perpop.boxplot.wmf",family=mysambar$myfont,width=npops*2,height=6)}
		}
	par(mar=c(4,5,0.5,0.5))
	# 
	# create new dataframe, with one column popname, and other column He-estimates:
	temp	<- snps[snps$filter,names(snps)!="hetero"]
	temp	<- temp[, grep("hetero", names(temp))]
	myhe	<- as.vector(unlist(temp))
	mypops	<- rep(popnames,each=nrow(temp))
	mydf	<- data.frame(pop=mypops,hetero=myhe)
	boxplot(mydf$hetero~mydf$pop,col=mysambar$mycolour[order(mysambar$populations)],las=1,xlab="",ylab="",cex.axis=1.5,cex.axis=2,pch=16)
	# add means:
	mymeans <- aggregate(hetero ~ pop, mydf, mean)
	points(c(1:npops),mymeans$hetero,pch=16,col="white",cex=1)
	mtext(side=2,"Locus heterozygosity",line=3.5,cex=2)
	mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}	

# not used by filter wrapper function:
plotHe<-function(popnames=mysambar$populations)
	{
	npops	<- length(popnames)
	par(mfrow=c(1,4))
	mydf	<- snps[snps$filter,c("maf","hetero")]
	mydf	<- unique(mydf)
	x		<- seq(0,1,0.01)
	y		<- 2*x*(1-x)
	plot(mydf,ylim=c(0,1),xlim=c(0,1))
	lines(x,y,col="red",lwd=2)
	for(i in c(1:npops))
		{
		mypop	<- popnames[i]
		mydf	<- snps[snps$filter,c(paste("maf",mypop,sep="_"),paste("hetero",mypop,sep=""))]
		mydf	<- unique(mydf)
		plot(mydf,ylim=c(0,1),xlim=c(0,1))
		lines(x,y,col="red",lwd=2)
		}
	}
	
plotparalogs<-function(export=NULL)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("He_vs_maf.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("He_vs_maf.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("He_vs_maf.png",family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile("He_vs_maf.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(snps$maf[snps$hefilter],snps$hetero[snps$hefilter],pch=16,cex=1,xlab="Locus specific minor allele frequency",ylab="Locus specific heterozygosity",ylim=c(0,1),main="Identification of paralogs")
	points(snps$maf[!snps$hefilter],snps$hetero[!snps$hefilter],pch=16,cex=1,col="red",xlab="Locus specific minor allele frequency",ylab="Locus specific heterozygosity",ylim=c(0,1))
 	legend("topleft",legend=c("FALSE","TRUE"),title="Pass He filter",bty='n',fill=c("red","black"),cex=2)
	if(!is.null(export)){dev.off()}
	}

plotperpool<-function(popnames=mysambar$populations)
	{
	if("pool"%in%colnames(inds))
		{
		npops		<- length(popnames)
		mycolours	<- mysambar$mycolours[1:npops]
		# heterozygosity:
		mymax		<- max(inds$hetero,na.rm=TRUE)
		pdf("He_perpool.pdf",width=5,height=npops*1.25)
		par(mfrow=c(npops,1),mar=c(2,3.5,0.5,0.5),oma=c(2,1,1,1))
		for (j in c(1:npops))
			{
			mypop	<- popnames[j]
			boxplot(inds$hetero[inds$pop==mypop]~inds$pool[inds$pop==mypop],col=mycolours[j],ylim=c(0,mymax),las=1,border=mycolours[j])
			}
		mtext("Sequencing pool",side=1,outer=TRUE,line=0.5)
		mtext("Sample heterozygosity",side=2,outer=TRUE,line=-0.75)
		dev.off()
		# missingness:
		mymax		<- max(inds$miss,na.rm=TRUE)
		pdf("Missingness_perpool.pdf",width=5,height=npops*1.25)
		par(mfrow=c(npops,1),mar=c(2,3.5,0.5,0.5),oma=c(2,1,1,1))
		for (j in c(1:npops))
			{
			mypop	<- popnames[j]
			boxplot(inds$miss[inds$pop==mypop]~inds$pool[inds$pop==mypop],col=mycolours[j],ylim=c(0,mymax),las=1,border=mycolours[j])
			}
		mtext("Sequencing pool",side=1,outer=TRUE,line=0.5)
		mtext("Proportion missing data",side=2,outer=TRUE,line=-0.75)
		dev.off()
		}
	}

plot_F<-function(export=FALSE,popnames=mysambar$populations,addlabels=TRUE,myfvalues=NULL)
	{
	npops		<- length(popnames)
	if(is.null(myfvalues))
		{
		myfvalues	<- snps[snps$filter,paste("F",mysambar$populations,sep="_")]
		}
	if(export){pdf("Fixationindex_perlocus.pdf",width=npops*2.5,height=6)}
	par(cex.axis=1.5,mar=c(3,6,1,2))
	boxplot(myfvalues, use.cols = TRUE,col=mysambar$mycolours,names=mysambar$populations,outline=FALSE,las=1)
	mtext("Locus specific FIS",side=2,line=3.75,cex=1.75)
	if(addlabels)
		{
		mtext("He-deficit",side=4,at=0.01,adj=0,line=0.5,cex=1.5)
		mtext("He-excess",side=4,at=-0.01,adj=1,line=0.5,cex=1.5)
		abline(h=0,lty=3)
		}
	if(export){dev.off()}
	}

# This gives incredibly high estimates:	
# Idea is nice, but can we improve on it?
calc_indF<-function(popnames=mysambar$populations,mycolours=mysambar$mycolours,allsites=TRUE,export=NULL)
	{
	# The inbreeding coefficient F is the probability that the two alleles at a locus are identical by descent (IBD).
	# If they are IBD, they are homozygous.
	# The inbreeding coefficient F can therefore be treated as a measure for increased homozygosity compared to HWE expectations.
	# And likewise as a measure of decreased observed heterozygosity (Ho): 
	# Ho = (1-F)(2pq) = (1-F)He
	# Therefore, the inbreeding coefficient F can be calculated as: 
	# F = 1-(Ho/He)					# obtained after substitution: Ho=(1-F)He -> (1-F)=Ho/He -> F = 1-Ho/He 
	# Ho = observed proportion of heterozygous loci 
	# He = expected proportion of heterozygous loci = 2pq
	# q = average minor allele frequency within the population to which individual belongs (i.e. snps$maf_pop)
	# p = 1-q
	# if considering multiple loci, we average He over all loci:
	# He = mean(2pq_1 + 2pq_2 + ... + 2pq_n)
	# Say for example we have 100 loci, 50 with q = 0.1 and 50 with q = 0.2, then we expect 50*2*0.1*0.9+50*2*0.2*0.8 = 25 heterozygous loci. 
	# If we find instead 20 heterozygous loci (observed heterozygotes), the inbreeding coefficient equals: F = 1-(20/25) = 0.2.
	# So 20 percent more homozygotes then expected at HWE. 
	# Note that although deviation from HWE is defined as inbreeding coefficient, there are multiple causing factors. 
	#
	npops			<- length(popnames)
	mycolours		<- mycolours[1:npops]
	# calculate inbreeding coefficient:
	inds$expHe		<<- 2*(inds$popmaf*(1-inds$popmaf))				# all sites
	inds$expHe_all	<<- 2*(inds$popmaf_all*(1-inds$popmaf_all))		# include only sites which are segregating in the population to which the individual belongs
	# inds$F		<<- (inds$expHe-inds$hetero)/inds$expHe
	# inds$F_all	<<- 1-(inds$hetero_all/inds$expHe_all)				# either of the two
	# inds$F_all	<<- (inds$expHe_all-inds$hetero_all)/inds$expHe_all	# either of the two
	hetemp1			<- inds$expHe
	hetemp2			<- hetemp1+0.0001
	hetemp1[hetemp1==0]	<- hetemp2[hetemp1==0]
	inds$F			<<- (inds$expHe-inds$hetero)/hetemp2
	hetemp1			<- inds$expHe_all
	hetemp2			<- hetemp1+0.0001
	hetemp1[hetemp1==0]	<- hetemp2[hetemp1==0]
	inds$F_all			<<- (inds$expHe-inds$hetero)/hetemp2
	# if this function has been executed before, remove columns produced during previous execution:
	inds 			<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)]	
	# plot:
	npop			<- length(popnames)
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Inbreeding.pdf",width=npops*2.5,height=7)}	
		if(export=="pdf"){pdf("Inbreeding.pdf",width=npops*2.5,height=7)}
		if(export=="png"){png("Inbreeding.png",width=npops*250,height=720)}
		if(export=="wmf"){win.metafile("Inbreeding.wmf",width=npops*2.5,height=7)}
		}
	par(mar=c(5,7,5,2),cex.axis=2,cex.lab=2.5,cex.main=3,las=1)
	if(allsites)
		{
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,npop+0.5),col="white",ylim=c(min(inds$F_all[is.finite(inds$F)&inds$filter]),max(inds$F_all[is.finite(inds$F)&inds$filter])),xaxt="n",xlab="",ylab="")	
		}else{
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,npop+0.5),col="white",ylim=c(min(inds$F[is.finite(inds$F)&inds$filter]),max(inds$F[is.finite(inds$F)&inds$filter])),xaxt="n",xlab="",ylab="")	
		}
	for (i in c(1:npop))
		{
		mypop			<- popnames[i]
		if(allsites)
			{
			vioplot(inds$F_all[inds$filter&inds$pop2==mypop&is.finite(inds$F_all)&!is.na(inds$F_all)],at=i,add=TRUE,col=mycolours[i])
			}else{
			vioplot(inds$F[inds$filter&inds$pop2==mypop&is.finite(inds$F)&!is.na(inds$F)],at=i,add=TRUE,col=mycolours[i])
			}
		}
	axis(side=1,at=seq(1,npop),labels=popnames,lty=1,las=1,cex.axis=1.75)
	mtext("Population",1,line=3,cex=2.25)
	mtext("Inbreeding coefficient",3,line=1.5,cex=2.5)
	mtext("F (1 - Hobs/Hexp)",2,line=4.5,cex=2.5,las=0)
	if(!is.null(export)){dev.off()}
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

# old: not realistic values:
plot_Fold<-function(export=FALSE)
	{
	if(export){pdf("Inbreeding2.pdf",width=12,height=6)}
	par(mfrow=c(1,2))
	mymin<-min(c(inds$popmaf_all[inds$filter],inds$maf_all[inds$filter]),na.rm=TRUE)
	mymax<-max(c(inds$popmaf_all[inds$filter],inds$maf_all[inds$filter]),na.rm=TRUE)
	plot(inds$popmaf_all[inds$filter],inds$maf_all[inds$filter],xlab="mean(popMAF)",ylab="MAF_sample",col=inds$popcol[inds$filter],pch=16,xlim=c(mymin,mymax),ylim=c(mymin,mymax),las=1)
	lines(c(0,1),c(0,1),col="grey")
	mymin<-min(c(inds$expHe_all[inds$filter],inds$hetero_all[inds$filter]),na.rm=TRUE)
	mymax<-max(c(inds$expHe_all[inds$filter],inds$hetero_all[inds$filter]),na.rm=TRUE)
	plot(inds$expHe_all,inds$hetero_all,col=inds$popcol,pch=16,xlab="Expected sample heterozygosity",ylab="Observed sample heterozygosity",xlim=c(mymin,mymax),ylim=c(mymin,mymax),las=1)
	lines(c(0,1),c(0,1),col="grey")
	if(export){dev.off()}
	}	

expHe_vs_He<-function(popnames=mysambar$populations,export=NULL,allsites=FALSE)
	{
	# plot:
	graphics.off()
	if(!is.null(export))
		{
		exportname	<- ifelse(allsites,"expHe_vs_He.allsites","expHe_vs_He.segregatingsites")
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)	
	if(allsites)
		{
		mymaf	<- inds$popmaf_all
		myhetero<- inds$hetero_all
		}else{
		mymaf	<- inds$popmaf
		myhetero<- inds$hetero
		}
	plot(mymaf[inds$filter],myhetero[inds$filter],xlab="Observed sample maf",ylab="Observed sample He",cex=2,ylim=c(0,0.5))
	for (j in c(1:length(popnames)))
		{
		mypop				<- popnames[j]
		points(mymaf[inds$pop2==mypop&inds$filter],myhetero[inds$pop2==mypop&inds$filter],col=mysambar$mycolours[j],pch=16,cex=2)
		points(mymaf[inds$pop2==mypop&!inds$filter],myhetero[inds$pop2==mypop&!inds$filter],col=mysambar$mycolours[j],cex=2)
		}
	# add line showing expected values:
	temp	<- seq(0,1,0.01)
	temp2	<- 2*temp*(1-temp)
	lines(temp,temp2,col="black",lwd=2)
	# add legend:
	legend("topleft",legend=popnames,bty='n',fill=unique(inds$popcol),cex=2)
	if(!is.null(export)){dev.off()}
	}

missingness_perpop<-function(export=NULL,addylabel=TRUE)
	{
	npops	<- length(mysambar$populations)
	if(!is.null(export))
		{
		mylabel	<- ifelse(addylabel,"perpop","perpop.no_ylabel")
		if(export=="eps"){postscript(paste("Missingdata",mylabel,"eps",sep="."),family=mysambar$myfont,width=npops*2.5,height=6)}
		if(export=="pdf"){pdf(paste("Missingdata",mylabel,"pdf",sep="."),family=mysambar$myfont,width=npops*2.5,height=6)}
		if(export=="png"){png(paste("Missingdata",mylabel,"png",sep="."),family=mysambar$myfont,width=npops*360,height=720)}
		if(export=="wmf"){win.metafile(paste("Missingdata",mylabel,"wmf",sep="."),family=mysambar$myfont,width=npops*2.5,height=6)}
		}
	par(mar=c(4,5,0.5,0.5))
	boxplot(inds$miss~inds$pop,col=mysambar$mycolour[order(mysambar$populations)],las=1,xlab="",ylab="",cex.axis=1.5,cex.axis=2,pch=16)
	if(addylabel)
		{	
		mtext(side=2,"Proportion missing data",line=3.25,cex=2)
		}
	mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}
	
thindata<-function(mindistance=500)
	{
	for (i in (1:nrow(snps)))
		{
		snps$distfilter[i]	<<- ifelse(snps$dist[i]>=mindistance,TRUE,FALSE) 
		}
	snps$distfilter			<<- ifelse(is.na(distfilter),FALSE,distfilter)
	}	

stacks_demultiplex<-function(plotretained=TRUE,QC=FALSE)
	{
	x		<- read.table("I:/PhD/Reindeer/Processradtagsoutput_nosums.txt",header=TRUE)
	x$Pool2	<- gsub("Pool","",x$Pool)
	mylanes	<- as.vector(unique(x$Sequencing_Lane))
	x$Sequencing_Lane2	<- NA
	for(j in c(1:length(mylanes)))
		{
		mylane		<- mylanes[j]
		x$Sequencing_Lane2[x$Sequencing_Lane==mylane]<-j
		}
	x$Pool3<-paste(x$Sequencing_Lane2,x$Pool2,sep=".")
	# retained reads:
	if(plotretained)
		{
		if(QC)
			{
			pdf("Retainedreads.QC.pdf",width=12,height=12)
			par(mfrow=c(2,2),oma=c(0,2,0,1))
			boxplot((x$LowQuality/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion low quality reads",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot((x$NoRadTag/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion reads with no barcode",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot(((x$Unpaired_forward+x$Unpaired_reverse)/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion reads with no barcode",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot(((x$Read_pairs*2)/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion retained reads",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			dev.off()
			}else{
			pdf("Retainedreads.overall2.pdf",width=12,height=6)
			par(mfrow=c(1,2),oma=c(0,2,0,0))
			boxplot(((x$Read_pairs*2)/x$Total_Reads)~(x$Pool3),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion retained reads",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot(x$Read_pairs/1000000~x$Pool3,ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Retained read pairs (x 1M)",side=2,line=2.5,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			dev.off()
			}
		}
	# Read depth per locus vs total read depth:
	y				<- x[order(x$ID),]
	inds$pool		<- y$Pool3
	inds$nreadpairs	<- y$Read_pairs
	pdf("Mean.vs.total.readdepth.pdf",height=6,width=12)
	par(mfrow=c(1,2),oma=c(0,2,0,0))
	plot(inds$nreadpairs/1000000,inds$meandepth,ylab="",xlab="",pch=16,cex.axis=1.5,cex.lab=2,las=1)
	points(inds$nreadpairs[!inds$filter]/1000000,inds$meandepth[!inds$filter],pch=16,col="red")
	mtext("Mean read depth",side=2,line=3,cex=2)	
	mtext("Number of read pairs (x 1M)",side=1,line=3,cex=2)
	plot(inds$meandepth,inds$miss,ylab="",xlab="",pch=16,cex.axis=1.5,cex.lab=2,las=1)
	points(inds$meandepth[!inds$filter],inds$miss[!inds$filter],pch=16,col="red")
	mtext("Proportion missing data",side=2,line=3,cex=2)	
	mtext("Mean read depth",side=1,line=3,cex=2)
	dev.off()
	}

plotgenocounts<-function(popnames=mysambar$populations,export=FALSE,myout=NULL,addlabels=TRUE)
	{
	npops			<- length(popnames)
	if(is.null(myout))
		{
		myout			<- matrix(NA,ncol=4,nrow=npops)
		rownames(myout)	<- popnames
		for (j in c(1:npops))
			{
			mypop		<- popnames[j]
			# cat(mypop,sep="\n")
			mymaf		<- snps[,paste("maf",mypop,sep="_")]
			mymaf[is.na(mymaf)]	<- 0
			mymat		<- as.matrix(mygenlight[inds$filter&inds$pop==mypop,mymaf>0&snps$filter,])
			n0			<- length(mymat[mymat==0&!is.na(mymat)])
			n1			<- length(mymat[mymat==1&!is.na(mymat)])
			n2			<- length(mymat[mymat==2&!is.na(mymat)])
			nall		<- length(mymat[!is.na(mymat)])
			myout[j,1]	<- n0/nall
			myout[j,2]	<- n1/nall
			myout[j,3]	<- n2/nall
			myout[j,4]	<- (n1+2*n2)/(2*nall)
			}
		myout			<- as.data.frame(myout)
		colnames(myout)	<- c("n0","n1","n2","maf") 
		myout$prop		<- myout$n2/myout$n1
		}else{
		myout	<- myout
		}
	# plot:
	myout2			<- t(myout[,c(1:3)])
	myout			<<- myout
	myout2			<<- myout2
	npops			<- length(popnames)
	if(npops>1)
		{
		x			<- matrix(0,ncol=npops,nrow=npops*3)
		for(j in c(1:npops))
			{
			mydata	<- myout2[,j]
			x[(j*3-2):(j*3),j]	<- mydata
			}
		}else{
		x			<- myout2
		}
	mycolours		<- mysambar$mycolours[1:npops]
	mycols			<- vector()
	for(j in c(1:npops))
		{
		mycol	<- mycolours[j]
		colfunc <- colorRampPalette(c("grey",mycol))
		mycol2	<- colfunc(3)
		mycols	<- c(mycols,mycol2)
		}
	if(export)
		{
		if(addlabels)
			{
			pdf("Genocounts.withlabels.pdf")
			}else{
			pdf("Genocounts.pdf")
			}
		}
	par(mar=c(4,10,2.5,2.5))
	xx<-barplot(x,col=mycols,border=NA,space=0.1,horiz=TRUE,names.arg=popnames,las=1,cex.names=1.5)
	if(addlabels)
		{
		for(j in c(1:npops))
			{
			poppoints	<- x[,j]
			poppoints	<- poppoints[poppoints!=0]
			poppoints	<- cumsum(poppoints)
			barmid		<- xx[j]
			text(poppoints,barmid,labels = c(0,1,2),adj=1,cex=1.5)
			}
		mtext("Genotype proportions",side=3,line=0.5,cex=2)
		mtext("0: homozygous major; 1: heterozygous; 2: homozygous minor",side=3,line=-0.75,cex=1)
		}
	if(export){dev.off()}
	}
	
plotmapping<-function(export=FALSE,input1="alignmentscores.reinasref.txt",input2="alignmentscores.cowasref.txt",myrefs=c("reindeer","cow"),plotcols=c("grey","black"))
	{
	if(export){pdf("Mapping_scores.pdf")}
	x<-read.table(input1)
	colnames(x)	<- c("sample","mapped","concordant")
	y<-read.table(input2)
	colnames(y)	<- c("sample","mapped","concordant")
	plot(inds$nreadpairs/1000000,x$mapped,las=1,pch=16,xlab="",ylab="",col=plotcols[1])
	mtext("Mapped reads (%)",side=2,line=2.5,cex=2)	
	mtext("Number of read pairs (x 1M)",side=1,line=3,cex=2)
	points(inds$nreadpairs/1000000,x$concordant,col=plotcols[1])
	points(inds$nreadpairs/1000000,y$mapped,pch=16,col=plotcols[2])
	points(inds$nreadpairs/1000000,y$concordant,col=plotcols[2])
	legend("bottomright",fill=plotcols,legend=myrefs,bty='n',cex=1.5)
	if(export){dev.off()}
	mymeans	<<- c(mean(x$mapped), mean(x$concordant), mean(y$mapped), mean(y$concordant))
	mysd	<<- c(sd(x$mapped), sd(x$concordant), sd(y$mapped), sd(y$concordant))
	# The inputfiles were generated on Linux using the commands:
	# cat ./*mapped.txt > allsamples.reinasref.mappedcounts.txt
	# cat ./*paired.txt > allsamples.reinasref.pairedcounts.txt
	# ls -1 ./*verysensitive.bam > samfiles.txt
	# sed -i 's/bam/sam/g' samfiles.txt 
	# sed 's/.reinasref.verysensitive.sam//g' samfiles.txt > mysamples.txt
	# sed -i 's/\.\///g' mysamples.txt
	# paste mysamples.txt allsamples.reinasref.mappedcounts.txt allsamples.reinasref.pairedcounts.txt > allsamples.alignmentscores.txt
	# cat ./*mapped.txt > allsamples.cowgenome.mappedcounts.txt
	# cat ./*paired.txt > allsamples.cowgenome.pairedcounts.txt
	# ls -1 ./*verysensitive.bam > samfiles.txt
	# sed -i 's/bam/sam/g' samfiles.txt 
	# sed 's/.cowgenome.verysensitive.sam//g' samfiles.txt > mysamples.txt
	# sed -i 's/\.\///g' mysamples.txt
	# paste mysamples.txt allsamples.cowgenome.mappedcounts.txt allsamples.cowgenome.pairedcounts.txt > allsamples.alignmentscores.txt
	}
	
# End of data preparation	
############################################################################################################	




############################################################################################################
# Population structure analyses

# This function executes all population structure analyses at once:
# I still want to include phylogenetic analyses.
# This webpage has tips:
# https://www.molecularecologist.com/2016/02/quick-and-dirty-tree-building-in-r/

findstructure<-function(add_legend=TRUE,legend_pos="right",legend_cex=2,Kmax=6,do_nei=TRUE,do_pi=TRUE,do_dapc=TRUE,onlyLEA=FALSE,symbol_size=2,colour_vector=NULL,silent=TRUE)
	{
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		# This would lead to error message: Error in 1:nLoc(x) : NA/NaN argument.
		# a quick and dirty way of working around this would be to type:
		# inds$filter[is.na(inds$filter)]	<- FALSE
		}else{
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column inds$filter contains NA-values, which are not allowed.",sep="\n"))
			}
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}else{
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column snps$filter contains NA-values, which are not allowed.",sep="\n"))
			}
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
	# legend_pos can be either topleft, top, topright, left, center, right, bottomleft, bottom, or bottomright
	setwd(mysambar$structuredir)
	# do analyses:
	if(!onlyLEA)
		{
		#cat("Testing for Wahlund effect...",sep="\n")
		#if(nrow(snps[snps$filter,])>500)	# 09-07-19: only meaningful results if reasonably amount of data per bin
		#	{
		#	wahlundplot(export="eps")
		#	wahlundplot(export="pdf")
		#	wahlundplot(export="png")
		#	wahlundplot(export="wmf")
		#	}								# 26-09-2019: incorrect at the moment, needs to be improved
		if(length(mysambar$populations)>2)
			{
			cat("Executing correspondence analysis...",sep="\n")
			# for populations:
			if(!silent){cat("makeinputfca",sep="\n")}
			makeinputfca()
			if(!silent){cat("run_ca",sep="\n")}
			run_ca(mydf=fca_input,addlegend=FALSE,export="eps",symbolsize=symbol_size)
			run_ca(mydf=fca_input,addlegend=FALSE,export="pdf",symbolsize=symbol_size)
			run_ca(mydf=fca_input,addlegend=FALSE,export="png",symbolsize=symbol_size)
			run_ca(mydf=fca_input,addlegend=FALSE,export="wmf",symbolsize=symbol_size)
			run_ca(mydf=fca_input,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="eps",symbolsize=symbol_size)
			run_ca(mydf=fca_input,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="pdf",symbolsize=symbol_size)
			run_ca(mydf=fca_input,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="png",symbolsize=symbol_size)
			run_ca(mydf=fca_input,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="wmf",symbolsize=symbol_size)
			}else{
			cat("Currently less than 3 population defined. Skipping correspondence analysis for populations.",sep="\n")
			}
		if(!silent){cat("makeinputfca_ind",sep="\n")}
		makeinputfca_ind()
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=FALSE,export="eps",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=FALSE,export="pdf",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=FALSE,export="png",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=FALSE,export="wmf",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="eps",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="pdf",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="png",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="wmf",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="eps",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="pdf",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="png",symbolsize=symbol_size)
		run_ca(mydf=fca_input_ind,perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="wmf",symbolsize=symbol_size)
		if(do_nei)
			{
			cat("Creating Nei's genetic distance matrix...",sep="\n")
			ind_neimatrix(export=NULL)
			if(!silent){cat("plot_ind_neimatrix",sep="\n")}
			plot_ind_neimatrix(export="eps")
			plot_ind_neimatrix(export="pdf")
			plot_ind_neimatrix(export="png")
			plot_ind_neimatrix(export="wmf")
			}
		cat("Creating pcoa plot based on nucleotide diversity using Sambar functions and Ape...",sep="\n")
		if(!silent){cat("calcpi",sep="\n")}
		calcpi(pi_per_pop=FALSE)
		calcpi(pi_per_pop=TRUE)
		if(!silent){cat("ape_pcoa",sep="\n")}
		if(do_pi)
			{
			ape_pcoa(labels=FALSE,method="pi",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=FALSE,method="pi",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=FALSE,method="pi",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=FALSE,method="pi",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=TRUE,method="pi",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=TRUE,method="pi",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=TRUE,method="pi",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=TRUE,method="pi",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			}
		if(do_nei)
			{
			cat("Creating pcoa plot based on Nei's genetic distance using StAMPP and Ape...",sep="\n")
			ape_pcoa(labels=FALSE,method="nei",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=FALSE,method="nei",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=FALSE,method="nei",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=FALSE,method="nei",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=TRUE,method="nei",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=TRUE,method="nei",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=TRUE,method="nei",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			ape_pcoa(labels=TRUE,method="nei",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			}
		cat("Creating pcoa plot based on Hamming's genetic distance using poppr and Ape...",sep="\n")
		ape_pcoa(labels=FALSE,method="hamming",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		ape_pcoa(labels=FALSE,method="hamming",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		ape_pcoa(labels=FALSE,method="hamming",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		ape_pcoa(labels=FALSE,method="hamming",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		ape_pcoa(labels=TRUE,method="hamming",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		ape_pcoa(labels=TRUE,method="hamming",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		ape_pcoa(labels=TRUE,method="hamming",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		ape_pcoa(labels=TRUE,method="hamming",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		if(nrow(snps[snps$filter,])>1000)
			{
			cat("Creating pcoa plots based on Nei's genetic distance using various number of loci...",sep="\n")
			plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE)
			plotmulti_pcoa(mymethod="nei",export="pdf")
			cat("Creating pcoa plots based on Hamming's genetic distance using various number of loci...",sep="\n")
			plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE)
			plotmulti_pcoa(mymethod="hamming",export="pdf")
			}
		cat("Creating pca plot using snprelate...",sep="\n")
		snprelate_pca(export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)	
		snprelate_pca(export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		snprelate_pca(export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		snprelate_pca(export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		snprelate_pca(export="eps",addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)	
		snprelate_pca(export="pdf",addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		snprelate_pca(export="png",addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		snprelate_pca(export="wmf",addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		file.remove("my.gds")
		cat("Creating multidimensional scaling (MDS) plots...",sep="\n")
		if(!silent){cat("bothMDS",sep="\n")}
		bothMDS(exporttype="pdf")
		if(!silent){cat("doMDS",sep="\n")}
		doMDS(labels=TRUE,nonmetric=TRUE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		doMDS(labels=TRUE,nonmetric=FALSE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		doMDS(labels=FALSE,nonmetric=TRUE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		doMDS(labels=FALSE,nonmetric=FALSE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
		if(do_dapc)
			{
			cat("Creating dapc plot...",sep="\n")	
			genlight2genind()
			if(!silent){cat("adegenet_dapc",sep="\n")}
			# adegenet_dapc(maxclusters=Kmax,export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size) 
			adegenet_dapc(maxclusters=Kmax,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			adegenet_dapc(maxclusters=Kmax,export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)
			}
		if(length(mysambar$populations)>1)
			{
			cat("Calculating Bayesian assignment probabilities...",sep="\n")
			assign2pop()
			if(!silent){cat("plotassign2pop",sep="\n")}
			plotassign2pop(export="eps",addsamplenr=TRUE)
			plotassign2pop(export="pdf",addsamplenr=TRUE)
			plotassign2pop(export="png",addsamplenr=TRUE)
			plotassign2pop(export="wmf",addsamplenr=TRUE)
			plotassign2pop(export="eps",addsamplenr=FALSE)
			plotassign2pop(export="pdf",addsamplenr=FALSE)
			plotassign2pop(export="png",addsamplenr=FALSE)
			plotassign2pop(export="wmf",addsamplenr=FALSE)
			if(!silent){cat("plotassign2pop_hetero",sep="\n")}
			plotassign2pop_hetero()
			#cat("Generating genotype network...",sep="\n")	# 01-10-2019: not insightful
			#if(nrow(snps[snps$filter,])>1000)	# if less than 1000 loci, no need to sample, and therefore no stochastic element, so no need to run analysis multiple times to see general behaviour
			#	{
			#	makenetworks(nplots=5)
			#	}else{
			#	makenetworks(nplots=1)
			#	}
			}
		}
	cat("Creating admixture barplot using LEA...",sep="\n")
	# LEAstructureplot(maxdemes=Kmax,export="eps",addindnr=TRUE,colourvector=colour_vector)	# It takes too long to do all graphical formats.
	# LEAstructureplot(maxdemes=Kmax,export="eps",addindnr=FALSE,colourvector=colour_vector)
	LEAstructureplot(maxdemes=Kmax,export="pdf",addindnr=TRUE,colourvector=colour_vector)
	LEAstructureplot(maxdemes=Kmax,export="pdf",addindnr=FALSE,colourvector=colour_vector)
	# LEAstructureplot(maxdemes=Kmax,export="png",addindnr=TRUE,colourvector=colour_vector)
	# LEAstructureplot(maxdemes=Kmax,export="png",addindnr=FALSE,colourvector=colour_vector)
	LEAstructureplot(maxdemes=Kmax,export="wmf",addindnr=TRUE,colourvector=colour_vector)
	LEAstructureplot(maxdemes=Kmax,export="wmf",addindnr=FALSE,colourvector=colour_vector)
	# optionally order by longitude:
	if(("latitude" %in% colnames(inds)&"longitude" %in% colnames(inds)))
		{
		if(any(is.na(inds$longitude))|any(is.na(inds$latitude)))
			{
			cat("No missing values allowed in longitude and latitude column.",sep="\n")
			cat("SambaR will not order LEA structure plots by longitude.",sep="\n")
			}else{
			if(!silent){cat("LEAstructureplot by longitude",sep="\n")}
			LEAstructureplot(maxdemes=Kmax,export="pdf",addindnr=TRUE,order_on_longitude=TRUE,colourvector=colour_vector)
			LEAstructureplot(maxdemes=Kmax,export="pdf",addindnr=FALSE,order_on_longitude=TRUE,colourvector=colour_vector)	
			LEAstructureplot(maxdemes=Kmax,export="wmf",addindnr=TRUE,order_on_longitude=TRUE,colourvector=colour_vector)
			LEAstructureplot(maxdemes=Kmax,export="wmf",addindnr=FALSE,order_on_longitude=TRUE,colourvector=colour_vector)
			}
		}
	if(!onlyLEA)
		{
		# optionally create geographical maps:
		if(!silent){cat("create_sambarmaps",sep="\n")}
		create_sambarmaps(K_max=Kmax,radius_ratio=30)
		}
	# reset working directory to default:
	setwd(mysambar$inputdatadir)
	cat("Finished structure analyses.",sep="\n")
	}

create_sambarmaps<-function(K_max=6,radius_ratio=30)
	{
	# radius_ratio is the ratio between radius of piechart and the range of either longitude or latitude (i.e. smallest of the two)
	# e.g.: 30 means 1/30th.
	if(("latitude" %in% colnames(inds)&"longitude" %in% colnames(inds)))
		{
		if(any(is.na(inds$longitude))|any(is.na(inds$latitude)))
			{
			cat("No missing values allowed in longitude and latitude column.",sep="\n")
			return(cat("SambaR will not create geographical maps. If wanted, you can use the addgeofile() function to update the inds$latitude and inds$longitude column.",sep="\n"))
			}
		if(!"geomapsdir" %in% (names(mysambar)))
			{
			geomapsdir				<- paste(mysambar$structuredir,"Maps",sep="/")
			nelements				<- length(mysambar)
			mysambar[[nelements+1]]				<<- geomapsdir
			names(mysambar)[nelements+1]		<<- "geomapsdir"
			}else{
			if(is.null(mysambar$geomapsdir))
				{
				geomapsdir				<- paste(mysambar$structuredir,"Maps",sep="/")
				nelements				<- length(mysambar)
				mysambar[[nelements+1]]				<<- geomapsdir
				names(mysambar)[nelements+1]		<<- "geomapsdir"
				}
			}
		setwd(mysambar$geomapsdir)
		if(exists("leaqmatrixlist"))
			{
			cat("Creating geographical maps with admixture piecharts using LEA output...",sep="\n")
			mymaxK	<- length(leaqmatrixlist)+1
			if(mymaxK<K_max)
				{
				cat(paste("Warning: K_max is set to",K_max,"but currently data for available for a maximum K of",mymaxK,sep=" "),sep="\n")
				cat("If desired, rerun the findstructure() function with a higher Kmax value.",sep="\n")
				cat(paste("Creating plots now for K = 2 to K =",mymaxK,sep=" "),sep="\n")
				maplea(maxdemes=mymaxK,radiusratio=radius_ratio,exporttype="pdf",plotperpop=TRUE,addlabels=TRUE)
				maplea(maxdemes=mymaxK,radiusratio=radius_ratio,exporttype="pdf",plotperpop=TRUE,addlabels=FALSE)
				}else{
				maplea(maxdemes=K_max,radiusratio=radius_ratio,exporttype="pdf",plotperpop=TRUE,addlabels=TRUE)
				maplea(maxdemes=K_max,radiusratio=radius_ratio,exporttype="pdf",plotperpop=TRUE,addlabels=FALSE)
				}
			}else{
			cat("Could not find object called leaqmatrixlist. Run the findstructure() function and try again.",sep="\n")
			}
		if(exists("dapcqmatrixlist"))
			{
			cat("Creating geographical maps with admixture piecharts using DAPC output...",sep="\n")
			mymaxK	<- length(dapcqmatrixlist)+1
			if(mymaxK<K_max)
				{
				cat(paste("Warning: K_max is set to",K_max,"but currently data for available for a maximum K of",mymaxK,sep=" "),sep="\n")
				cat("If desired, rerun the findstructure() function with a higher Kmax value.",sep="\n")
				cat(paste("Creating plots now for K = 2 to K =",mymaxK,sep=" "),sep="\n")
				mapdapc(maxdemes=mymaxK,exporttype="pdf",plotperpop=TRUE,addlabels=TRUE)
				mapdapc(maxdemes=mymaxK,exporttype="pdf",plotperpop=TRUE,addlabels=FALSE)
				}else{
				mapdapc(maxdemes=K_max,exporttype="pdf",plotperpop=TRUE,addlabels=TRUE)
				mapdapc(maxdemes=K_max,exporttype="pdf",plotperpop=TRUE,addlabels=FALSE)
				}
			}else{
			cat("Could not find object called dapcqmatrixlist. Run the findstructure() function and try again.",sep="\n")
			}
		cat("Creating mantel plot...",sep="\n")
		multi_mantel_plot(popnames=mysambar$populations,doexport=TRUE)
		cat("Plotting location of samples...",sep="\n")
		plotlocations(export="pdf",addaxislabels=FALSE)
		plotlocations(export="pdf",addaxislabels=TRUE)
		setwd(mysambar$structuredir)
		}else{
		cat("Longitude and/or latitude column are absent in inds dataframe.",sep="\n")
		cat("SambaR will not generate geographical maps.",sep="\n")
		}	
	}

# make input for correspondence analysis (I called it factorial correspondence analysis, but actually not sure whether it is factorial indeed)	
makeinputfca<-function(popnames=mysambar$populations,remove0=FALSE)
	{
	if(length(popnames)==1)
		{
		return(cat("Currently only 1 population defined. SambaR can not execute correspondence analysis (CA).",sep="\n"))
		}else{
		temp	<- snps[snps$filter,c(paste("maf",mysambar$populations,sep="_"))]
		nsites	<- snps$nonmissallelecount[snps$filter]
		for (j in c(1:nrow(temp)))
			{
			myrow			<- as.vector(temp[j,]*nsites[j])
			if(remove0)
				{
				myrow[myrow==0]	<- 1
				}
			temp[j,]		<- myrow
			}
		temp			<- round(temp)
		colnames(temp)	<- mysambar$populations
		fca_input	<<- temp[complete.cases(temp), ]
		}
	}

makeinputfca_ind<-function(popnames=mysambar$populations,doall=FALSE)
	{
	fcatemp					<- as.matrix(mygenlight)
	# impute data (because no missing values allowed):
	cat("Imputing data...",sep="\n")
	for (i in c(1:nrow(inds)))
		{
		myind				<- as.vector(inds$name)[i]
		#cat(myind,sep="\n")
		#cat(i,sep="\n")
		myrow				<- fcatemp[i,]
		myrow_data			<- myrow[!is.na(myrow)]
		myrow_na			<- myrow[is.na(myrow)]
		nmiss				<- length(myrow_na)
		if(nmiss<nrow(snps))
			{
			myrow_na[1:nmiss]	<- sample(as.vector(myrow[!is.na(myrow)]),nmiss,replace=TRUE)
			myrow_all			<- c(myrow_data,myrow_na)
			myrow_all			<- myrow_all[order(names(myrow_all))]
			fcatemp[i,]			<- myrow_all
			}else{
			if(inds$filter[i]&doall)
				{
				return(cat(paste("ERROR: Sample ",myind, "contains missing data only. Set doall flag to FALSE.")),sep="\n")
				}
			}
		}
	if(doall)
		{
		fca_input_ind		<<- t(fcatemp[,snps$filter])
		}else{
		fca_input_ind		<<- t(fcatemp[inds$filter,snps$filter])
		}
	fcatemp		<<- fcatemp
	}

run_ca<-function(mydf=fca_input,perpop=TRUE,mymethod="dudi",doall=FALSE,do_scree=FALSE,export=NULL,dolabels=FALSE,addlegend=TRUE,popnames=mysambar$populations,symboltype=16,symbolsize=2.5,legendpos="topleft",legendcex=1.5,resetgraphics=TRUE,doinstall=FALSE)
	{
	if(perpop&length(popnames)<3)
		{
		return(cat("Currently less than 2 population defined. SambaR can not execute fca analysis when perpop is set is TRUE.",sep="\n"))
		}
	if(!(mymethod=="dudi"|mymethod=="factominer"))
		{
		return(cat("ERROR: mymethod should be 'dudi' or 'factominer'.",sep="\n"))
		}
	# correspondence analysis is principal components analysis for categorical data (rather than for numerical data?)
	# mymethod can be be 'factominer' (FactoMineR package) or 'dudi' (ade4 package).
	# Other options for correspondence analysis, at present not incorporated, would be:
	# library(ca)
	# res.ca <- ca(housetasks)
	# library(MASS)
	# res.ca <- corresp(housetasks, nf = 3)
	# No matter which method, factominer is used for plotting.
 	#
	if(doinstall)
		{
		install.packages("FactoMineR")
		install.packages("factoextra")
		library("FactoMineR")
		library("factoextra")
		}
	npops	<- length(popnames)
	if(is.null(mydf))
		{
		return(cat("Error: provide a dataframe with minor allele counts per population to mydf flag.",sep="\n"))
		}
	if(!perpop)
		{
		if(doall)
			{
			ninds	<- nrow(inds)
			}else{
			ninds	<- nrow(inds[inds$filter,])
			}
		if(ncol(fca_input_ind)!=ninds)
			{
			return(cat("ERROR: number of columns in input file does not correspond with expected number of individuals.",sep="\n"))
			}
		}else{
		if(ncol(fca_input)!=npops)
			{
			return(cat("ERROR: number of columns in input file does not correspond with expected number of populations.",sep="\n"))
			}
		}
	# mydf	<- unique(mydf)							# remove duplicates rows
	if(mymethod=="factominer")
		{
		res.ca 	<- CA(mydf,ncp=5,graph=FALSE)			 # this gives sometimes to error: Error in eigen(crossprod(X, X), symmetric = TRUE) : infinite or missing values in 'x'
		}
	if(mymethod=="dudi")
		{
		res.ca <- dudi.coa(mydf,scannf=FALSE,nf=5)		
		}
	#
	if(mymethod=="factominer")
		{
		eig.val <- as.data.frame(get_eigenvalue(res.ca))
		mycoord	<- res.ca$col$coord
		perc1	<- round(res.ca$eig[1,2],1)
		perc2	<- round(res.ca$eig[2,2],1)
		}
	if(mymethod=="dudi")
		{
		ca_out 	<- get_ca_col(res.ca)
		mycoord	<- ca_out$coord
		eig.val <- get_eigenvalue(res.ca)
		perc1	<- round(eig.val$variance.percent[1],1)
		perc2	<- round(eig.val$variance.percent[2],1)
		}
	# screeplot:
	if(do_scree)
		{
		if(!is.null(export))
			{
			if(perpop)
				{
				if(export=="eps"){postscript("CA.pop.screeplot.eps",family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf("CA.pop.screeplot.pdf",family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png("CA.pop.screeplot.png",family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile("CA.pop.screeplot.wmf",family=mysambar$myfont,width=10,height=10)}
				}else{
				if(export=="eps"){postscript("CA.ind.screeplot.eps",family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf("CA.ind.screeplot.pdf",family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png("CA.ind.screeplot.png",family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile("CA.ind.screeplot.wmf",family=mysambar$myfont,width=10,height=10)}
				}
			}
		barplot(eig.val$variance.percent,ylab="Percentage explained variance",names.arg=c(1:nrow(eig.val)))
		if(!is.null(export)){dev.off()}
		}
	#
	# ordination plot:
	if(resetgraphics){graphics.off()}
	if(!is.null(export))
		{
		mylegend	<- ifelse(addlegend,ifelse(perpop,"pop.withlegend","ind.withlegend"),ifelse(perpop,"pop.nolegend",ifelse(dolabels,"ind.nolegend.labels","ind.nolegend")))
		if(export=="eps"){postscript(paste("CA",mylegend,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("CA",mylegend,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("CA",mylegend,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("CA",mylegend,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,5,2,2),cex.lab=2.5,cex.axis=2.5)
	plot(mycoord[,1],mycoord[,2],col="white",cex=symbolsize,pch=16,xlab=paste("Dim 1 (",perc1," %)",sep=""),ylab=paste("Dim 2 (",perc2," %)",sep=""))
	abline(h=0,col="grey")
	abline(v=0,col="grey")
	if(perpop)
		{
		mycolours	<- mysambar$mycolours
		}else{
		if(doall)
			{
			mycolours	<- inds$popcol
			}else{
			mycolours	<- inds$popcol[inds$filter]
			}
		}
	if(dolabels)
		{
		if(doall)
			{
			mynumbers	<- inds$nr
			}else{
			mynumbers	<- inds$nr[inds$filter]
			}
		text(x=mycoord[,1],y=mycoord[,2],mynumbers,col=mycolours,cex=0.5)
		}else{
		points(mycoord[,1],mycoord[,2],col=mycolours,cex=symbolsize,pch=16)
		}
	if(addlegend==TRUE&npops>1)
		{
		if(length(symboltype)>1)
			{
			legend(legendpos,legend=popnames,fill=mysambar$mycolours,pch=symboltype,bty="n",cex=legendcex)
			}else{
			legend(legendpos,legend=popnames,fill=mysambar$mycolours,bty="n",cex=legendcex)
			}
		}
	if(!is.null(export)){dev.off()}
	}
	
	
hwe<-function(myinput=mygenlight,popnames=mysambar$populations,indselection=inds$filter,mycolours=unique(inds$popcol),export=NULL,addlabels=TRUE)
	{
	popnames		<- as.vector(popnames)
	npops			<- length(popnames)
	### For metapop:
	snps$Hexp_meta	<<- 2*snps$maf*(1-snps$maf)
	snps$F_meta		<<- (snps$Hexp_meta-snps$hetero)/snps$Hexp_meta
	# alternatively:
	# snps$F_meta	<<- (snps$expAa-snps$Aa)/snps$expAa
	snps$HWEchi2	<<- ((snps$expAA-snps$AA)^2/(snps$expAA+1))+((snps$Aa-snps$expAa)^2/(snps$expAa+1))+((snps$aa-snps$expaa)^2/(snps$expaa+1))
	# Degrees of freedom (df) = N_genotypes - N_alleles. For biallelic snps: 3-2=1.
	# This is the reason: once we decided on a value for p, everything else was decided for us. Whatever p was, q had to be 1-p, and p2, 2pq, and q2 were set as well. 
	# So, to make a column for significance (TRUE or FALSE), we can type:
	snps$HWE		<<- snps$HWEchi2 < (qchisq(.95,df=1))
	# He deficit or excess?
	snps$Hdeficit	<<- ifelse(snps$expAa-snps$Aa>0,TRUE,FALSE) 
	# I noticed that deficit is often caused by high maf. Maybe to correct for it:
	# snps$Hdeficit <<- ifelse(snps$HWE=="TRUE"&snps$maf<0.45,snps$Hdeficit,NA)
	### Plot:
	graphics.off()
	ntiles			<- npops+1
	if(!is.null(export))
		{
		mywidth1	<- ntiles*6+1
		mywidth2	<- ntiles*400+200
		if(export=="eps"){postscript("HWE.eps",family=mysambar$myfont,width=mywidth1,height=10)}
		if(export=="pdf"){pdf("HWE.pdf",family=mysambar$myfont,width=mywidth1,height=10)}
		if(export=="png"){png("HWE.png",family=mysambar$myfont,width=mywidth2,height=720)}
		if(export=="wmf"){win.metafile("HWE.wmf",family=mysambar$myfont,width=mywidth1,height=10)}
		}
	par(mfrow=c(1,ntiles),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	hist(snps$HWEchi2[snps$filter],breaks=seq(0,max(snps$HWEchi2[snps$filter]+10,0.5)),xlim=c(0,20),ylim=c(0,nrow(snps[snps$filter,])),main="",xlab="",ylab="Number of loci")
	mtext("Metapop",side=3,line=-2,cex=2)
	abline(v=qchisq(.95,df=1),lty=2)
	mtext("Locus specific HWE chi squared scores",side=1,line=-1.5,cex=2,outer=TRUE)
	mtext("HWE test scores",side=3,line=-3.5,cex=2.5,outer=TRUE)
	# For individuals populations:
	### For individual pops:
	for (i in (1:length(popnames)))
		{
		# Expected genotypes per population:
		misscount			<- glNA(mygenlight[indselection&inds$pop2==popnames[i],],alleleAsUnit=FALSE)
		npopind				<- nrow(inds[indselection&inds$pop2==popnames[i],])
		nonmisscount 		<- 2*npopind-misscount
		mymaf				<- snps[,paste("maf",popnames[i],sep="_")]
		expAA				<- round((1-mymaf)*(1-mymaf)*nonmisscount/2)
		expAa				<- round(2*mymaf*(1-mymaf)*nonmisscount/2)
		expaa				<- round(mymaf*mymaf*nonmisscount/2)
		# Observed genotypes per population:
		mymatrix 			<- as.matrix(mygenlight[indselection&inds$pop2==popnames[i],])
		mymatrix[is.na(mymatrix)]	<- 3
		obsAA				<- apply(mymatrix,2,function(z){length(z[z==0])})
		obsAa				<- apply(mymatrix,2,function(z){length(z[z==1])})
		obsaa				<- apply(mymatrix,2,function(z){length(z[z==2])})
		# Do the HWE-test:
		snps$Ftemp			<<- (expAa-obsAa)/expAa
		snps$HWEchi2temp	<<- ((expAA-obsAA)^2/(expAA+1))+((obsAa-expAa)^2/(expAa+1))+((obsaa-expaa)^2/(expaa+1))
		snps$HWEtemp		<<- snps$HWEchi2temp < (qchisq(.95,df=1))
		snps$Hdeficittemp	<<- ifelse(expAa-obsAa>0,TRUE,FALSE) 
		snps$obsAatemp		<<- obsAa
		snps$expAatemp		<<- expAa
		# Plot:
		hist(snps$HWEchi2temp[snps$filter],breaks=seq(0,max(snps$HWEchi2temp[snps$filter],na.rm=TRUE)+10,0.5),xlim=c(0,20),ylim=c(0,nrow(snps[snps$filter,])),main="",xlab="",ylab="",col=mycolours[i])
		mtext(popnames[i],side=3,line=-2,cex=2)
		abline(v=qchisq(.95,df=1),lty=2)
		# Rename:
		names(snps)[names(snps) == "Ftemp"] 		<<- paste("F",popnames[i],sep = "_")
		names(snps)[names(snps) == "HWEchi2temp"] 	<<- paste("HWEchi2",popnames[i],sep = "_")
		names(snps)[names(snps) == "HWEtemp"] 		<<- paste("HWE",popnames[i],sep = "_")
		names(snps)[names(snps) == "Hdeficittemp"]	<<- paste("Hdeficit",popnames[i],sep = "_")
		names(snps)[names(snps) == "obsAatemp"]		<<- paste("Aa",popnames[i],sep = "_")
		names(snps)[names(snps) == "expAatemp"]		<<- paste("expAa",popnames[i],sep = "_")
		} 
	if(!is.null(export)){dev.off()}
	# results per population:
	nsnps		<- nrow(snps[snps$filter,])
	results		<- matrix(, nrow = (length(popnames)+1), ncol = 4)
	colnames(results)<- c("Equilibrium","Disequilibrium","He_deficit","He_surplus")
	rownames(results)<- c("metapop",as.vector(popnames))
	results[1,1]	<- nrow(snps[snps$HWE==TRUE&snps$filter,])/nsnps*100
	results[1,2]	<- nrow(snps[snps$HWE==FALSE&snps$filter,])/nsnps*100
	results[1,3]	<- nrow(snps[snps$HWE==FALSE&snps$filter&snps$Hdeficit==TRUE,])/nsnps*100
	results[1,4]	<- nrow(snps[snps$HWE==FALSE&snps$filter&snps$Hdeficit==FALSE,])/nsnps*100
	for (i in (1:length(popnames)))
		{
		myHWE		<- snps[,paste("HWE",popnames[i],sep="_")]
		myHdeficit	<- snps[,paste("Hdeficit",popnames[i],sep="_")]
		results[i+1,1]	<- nrow(snps[myHWE==TRUE&snps$filter,])/nsnps*100
		results[i+1,2]	<- nrow(snps[myHWE==FALSE&snps$filter,])/nsnps*100
		results[i+1,3]	<- nrow(snps[myHWE==FALSE&snps$filter&myHdeficit==TRUE,])/nsnps*100
		results[i+1,4]	<- nrow(snps[myHWE==FALSE&snps$filter&myHdeficit==FALSE,])/nsnps*100
		}
	hwetable			<<- round(results,2)
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}   	

wahlundplot<-function(mysteps=0.05,export=NULL,popnames=mysambar$populations,addlabels=TRUE,silent=TRUE)
	{
	fislist			<- list()
	fislist2		<- list()
	ndatalist		<- list()
	npops			<- length(popnames)
	# for populations:
	for (j in c(1:npops))
		{
		mypop		<- popnames[j]
		if(!silent){cat(mypop,sep="\n")}
		myfis		<- snps[,paste("F",mypop,sep="_")]
		mymaf		<- snps[,paste("maf",mypop,sep="_")]
		myselection	<- is.finite(myfis)&snps$filter2
		if(any(myselection))
			{
			mybreaks	<- seq(0,1,mysteps)
			myhalf		<- mysteps/2
			mylabels	<- seq(myhalf,1-myhalf,mysteps)
			mafbins		<- cut(mymaf[myselection],mybreaks)
			# boxplot(myfis[myselection]~mafbins)
			fisperbin	<- aggregate(myfis[myselection],by=list(mafbins),FUN=mean) 
			nperbin		<- aggregate(myfis[myselection],by=list(mafbins),FUN=length)
			nbins		<- nrow(fisperbin)
			mylabels2	<- mylabels[1:nbins]
			fislist[[j]]	<- cbind(mylabels2,fisperbin$x) 
			fislist2[[j]]	<- fisperbin$x
			ndatalist[[j]]	<- nperbin$x
			}else{
			emptybins		<- seq(0,0.5,mysteps)
			zerodata		<- rep(0,length(emptybins))
			fislist[[j]]	<- cbind(emptybins,zerodata)
			fislist2[[j]]	<- zerodata
			ndatalist[[j]]	<- zerodata
			}
		}
	# for metapop:
	myfis		<- snps$F_meta
	mymaf		<- snps$maf
	myselection	<- is.finite(myfis)&snps$filter2
	mybreaks	<- seq(0,1,mysteps)
	myhalf		<- mysteps/2
	mylabels	<- seq(myhalf,1-myhalf,mysteps)
	mafbins		<- cut(mymaf[myselection],mybreaks)
	fisperbin	<- aggregate(myfis[myselection], by=list(mafbins),FUN=mean) 
	nperbin		<- aggregate(myfis[myselection], by=list(mafbins),FUN=length)
	nbins		<- nrow(fisperbin)
	mylabels2	<- mylabels[1:nbins]
	fislist[[npops+1]]	<- cbind(mylabels2,fisperbin$x) 
	ndatalist[[npops+1]]<- nperbin$x
	fislist2[[npops+1]]	<- fisperbin$x
	# define limit:
	myylim	<- c(-0.05,max(unlist(fislist2)))
	if(myylim[2]<=0)
		{
		myylim	<- c(min(unlist(fislist2)),0.03)
		}
	# plot:
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Wahlund.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Wahlund.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Wahlund.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("Wahlund.wmf",family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)	
	for (j in c(1:(npops+1)))
		{	
		if(j==4)
			{
			mycol		<- "black"
			myfis		<- fislist[[npops+1]]
			ndata		<- ndatalist[[npops+1]]
			}else{
			mycol		<- mysambar$mycolours[j]
			myfis		<- fislist[[j]]
			ndata		<- ndatalist[[j]]
			}
		if(j==1)
			{
			plot(myfis[ndata>100,],xlab="Locus specific maf",ylab="Locus specific Fis",xlim=c(0,1),ylim=myylim,col=mycol,type='b',lwd=3,pch=16)
			}else{
			points(myfis[ndata>100,],col=mycol,lwd=3,type='b',pch=16)
			}
		}
	abline(h=0,lty=2,lwd=1.5)
	if(addlabels)
		{
		mtext("He deficit",side=4,at=0.005,adj=0,line=0.5,cex=2)
		mtext("He excess",side=4,at=-0.005,adj=1,line=0.5,cex=2)
		}
	legend("topright",legend=c("metapop",popnames),fill=c("black",mysambar$mycolours),cex=2,bty="n")
	if(!is.null(export)){dev.off()}
	fislist<<-fislist
	}	

ReadGRMBin<-function(prefix, AllN=F, size=4)
	{
	sum_i			<- function(i){return(sum(1:i))}
	BinFileName		<- paste(prefix,".grm.bin",sep="")
	NFileName		<- paste(prefix,".grm.N.bin",sep="")
	IDFileName		<- paste(prefix,".grm.id",sep="")
	id 				<- read.table(IDFileName)
	n				<- dim(id)[1]
	BinFile			<- file(BinFileName, "rb");
	grm				<- readBin(BinFile, n=n*(n+1)/2, what=numeric(0), size=size)
	NFile			<- file(NFileName, "rb");
	if(AllN==T)
		{
		N			<- readBin(NFile, n=n*(n+1)/2, what=numeric(0), size=size)
		}else{
		N			<- readBin(NFile, n=1, what=numeric(0), size=size)
		i			<- sapply(1:n, sum_i)
		return(list(diag=grm[i], off=grm[-i], id=id, N=N))
		}
	}	

# requires ReadGRMBin:
# 02-12-2019: assumes all individuals are included
do_gctamatrix<-function(export=NULL,gctaprefix="spermwhale_3popr70p3",popnames=mysambar$populations,n_bins=5,currentdir=FALSE)
	{
	if(!currentdir)
		{
		setwd(mysambar$inputfilesdir)
		}
	gctadata 		<<- ReadGRMBin(prefix=gctaprefix, AllN=F, size=4)
	# metapop:
	nind			<- nrow(inds)
	indstemp		<- inds
	indstemp$filter	<- TRUE
	mymatrix 		<- matrix(NA,nrow=nind,ncol=nind)
	mymatrix[upper.tri(mymatrix)] <- gctadata$off
	gctamatrix		<- mymatrix
	mynames 		<- as.character(gctadata$id[,2])
	mynames2 		<- gsub(".verysens.q20.1hit.conc","",mynames)
	colnames(gctamatrix)	<- mynames2
	rownames(gctamatrix)	<- mynames2
	#
	# get same scale for each pop:
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(gctamatrix,na.rm=TRUE),1)
	mymax		<- ceiling_dec(max(gctamatrix,na.rm=TRUE),1)
	binsize		<- ifelse(is.null(n_bins),(mymax-mymin)/10,(mymax-mymin)/n_bins)
	mybreaks	<- seq(mymin,mymax,binsize)
	#
	if(!currentdir)
		{
		setwd(mysambar$divergencedir)
		}
	#
	# metapop:
	# First create indstemp file with all samples clustered together per population:
	inds_reordered		<- indstemp[order(indstemp$pop),]
	gctamatrix_reordered<- gctamatrix[order(indstemp$pop),order(indstemp$pop)]
	# Ready to plot:
	# non filtered:
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctamatrix_reordered,my_inds=inds_reordered,my_snps=snps,my_col="orange",addlab=FALSE,exportname="GCTAmatrix.metapop.no_axis",mytitle="Relatedness",myBreaks=mybreaks)		
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctamatrix_reordered,my_inds=inds_reordered,my_snps=snps,my_col="orange",addlab=TRUE,exportname="GCTAmatrix.metapop.with_axis",mytitle="Relatedness",myBreaks=mybreaks)		
	# filtered:
	gctafiltermat	<- gctamatrix_reordered[inds_reordered$filter,inds_reordered$filter]
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctafiltermat,my_inds=inds_reordered,my_snps=snps,my_col="orange",addlab=FALSE,exportname="GCTAmatrix.metapop.filter.no_axis",mytitle="Relatedness",myBreaks=mybreaks)
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctafiltermat,my_inds=inds_reordered,my_snps=snps,my_col="orange",addlab=TRUE,exportname="GCTAmatrix.metapop.filter.with_axis",mytitle="Relatedness",myBreaks=mybreaks)
	#
	# for each population:
	for (mypop in popnames)
		{
		gctapop		<- gctamatrix[inds$filter&inds$pop==mypop,inds$filter&inds$pop==mypop]
		indspop		<- inds[inds$filter&inds$pop==mypop,]
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctapop,my_inds=indspop,my_snps=snps,my_col="orange",addlab=FALSE,exportname=paste("GCTAmatrix",mypop,"no_axis",sep="."),mytitle=mypop,myBreaks=mybreaks)
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctapop,my_inds=indspop,my_snps=snps,my_col="orange",addlab=TRUE,exportname=paste("GCTAmatrix",mypop,"with_axis",sep="."),mytitle=mypop,myBreaks=mybreaks)
		}
	cat("Matrix heatmaps have been exported to:",sep="\n")
	cat(getwd(),sep="\n")
	if(!currentdir)
		{
		setwd(mysambar$sambardir)
		}
	}
		
# Depends on StAMPP. Requires function do_heatmap. 
ind_neimatrix<-function(bin_size=0.025,export=NULL)
		{
		# First create indstemp file with all samples clustered together per population:
		mymatrixtemp		<- as.matrix(mygenlight)
		mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
		mygenlighttemp		<- as.genlight(mymatrixtemp)
		indstemp			<- inds[order(inds$pop),]
		pop(mygenlighttemp)	<- as.factor(indstemp$pop2)
		if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
			{
			return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
			}
		# Now do the calculation:
		neimatrix 			<<- stamppNeisD(mygenlighttemp[indstemp$filter,snps$filter],pop=FALSE)
		neimatrix[!is.finite(neimatrix)]<<-NA
		do_heatmap(export_type=export,nbins=5,mymatrix=neimatrix,my_inds=indstemp,my_snps=snps,my_col="orange",exportname="Neimatrix.ind",mytitle="Nei's genetic distance")		
		}

plot_ind_neimatrix<-function(bin_size=0.025,export=NULL)
		{
		# First create indstemp file with all samples clustered together per population:
		indstemp			<- inds[order(inds$pop),]
		do_heatmap(export_type=export,nbins=5,mymatrix=neimatrix,my_inds=indstemp,my_snps=snps,my_col="orange",exportname="Neimatrix.ind",mytitle="Nei's genetic distance")		
		#apetree(mymatrix=neimatrix,my_inds=indstemp)
		}

# phylogenetic tree
# requires the package 'Ape'
# Still need to find out how to assign the right colour codes to the tips
# Tree does not reflect population structure accurately, so decided not to use it. 
apetree<-function(mymatrix=neimatrix,my_inds=inds)
	{
	colnames(mymatrix)	<- my_inds$pop2[my_inds$filter]
	colnames(mymatrix)	<- my_inds$pop2[my_inds$filter]
	mytree				<- nj(mymatrix)
	plot(mytree,edge.color=my_inds$popcol[my_inds$filter],cex=0.5)
	}		

# PCoA: Principal Coordinates Analysis (NOTE: this is different from principal component analysis or PCA). Depends on StAMPP (Nei's genetic distance) and Ape (pcoa):
# ape_pcoa(method="hamming",symbolkey="sex",legendpos="topleft")
ape_pcoa<-function(indselection=inds$filter,method="nei",snpselection=snps$filter,export=NULL,popnames=mysambar$populations,colourcode=inds$popcol,popcolours=mysambar$mycolours,symbolkey=NULL,symbolsize=2,addlegend=TRUE,legendpos="right",legendcex=2.5,addtitle=NULL,titledistance=1,labels=FALSE,resetgraphics=TRUE,silent=TRUE)
	{
	# method can be "nei" (Nei's genetic distance D), "hamming" (Hamming's genetic distance, or "pi".
	# Note: snpselection and indselection can not be applied when running method 'pi'. You should use calcpi() function to recalculate pi on different snp dataset.
	# Note: symbol size will be 0.75 for labels (irrespective of settings), to avoid overlap. 
	# Note: legend will not be displayed when only one population is defined, irrespective of settings.
	#
	if(!is.null(symbolkey))
		{
		if(any(symbolkey%in%colnames(inds)))
			{
			symbolkeyvec	<- inds[,symbolkey]
			}else{
			return(cat("ERROR: Symbolkey not present as column name in inds dataframe.",sep="\n"))
			}
		if(length(unique(symbolkeyvec))>13)
			{
			return(cat("ERROR: Symbolkey contains more than 13 levels. Currently not supported by SambaR.",sep="\n"))
			}
		}
	npops			<- length(popnames)
	if(method=="nei")
		{
		neimatrix 		<- stamppNeisD(mygenlight[indselection,snpselection],pop=FALSE)
		if(any(is.na(neimatrix)))
			{
			return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
			}
		p 				<- pcoa(neimatrix, correction="none", rn=NULL)
		}
	if(method=="hamming")
		{
		ploidy(mygenlight)<-2
		hammingmatrix	<- bitwise.dist(mygenlight[indselection,snpselection],mat=TRUE)
		if(any(is.na(hammingmatrix)))
			{
			return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
			}
		p 				<- pcoa(hammingmatrix, correction="none", rn=NULL)
		}
	if(method=="pi")
		{
		# pimatrix is generated with calcpi
		pidf			<- mysambar$tajdlist_meta[[1]]
		if(!silent){cat("Converting from dataframe to matrix...",sep="\n")}
		pimatrix		<- pidf2matrix(pidf=mysambar$tajdlist_meta[[1]],myinds=inds$nr[inds$filter])
		if(any(is.na(pimatrix)))
			{
			return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
			}
		if(!silent){cat("Executing pcoa analyses...",sep="\n")}
		mypi			<<- pimatrix
		p 				<- pcoa(pimatrix, correction="none", rn=NULL)	
		# 15-11-2019: untraceable error when running the function above: Error in array(STATS, dims[perm]) : 'dims' cannot be of length 0
		}
	if(!silent){cat("Finished pcoa analyses. Plotting...",sep="\n")}
	if(resetgraphics){graphics.off()}
	setwd(mysambar$structuredir)
	if(!is.null(export))
		{
		my_symbol	<- ifelse(labels,"labels",ifelse(is.null(symbolkey),"dots",symbolkey))
		if(export=="eps"){postscript(paste("pcoa",method,my_symbol,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("pcoa",method,my_symbol,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("pcoa",method,my_symbol,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("pcoa",method,my_symbol,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	# First create outline of the plot. The argument 'col="white"' hides the datapoints, so we can edit them in the next commands. 
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=3.5)
	plot(p$vectors[,1],p$vectors[,2],xlab=paste("PC1 (",round(p$values$Relative_eig[1]*100,1),"%)"),ylab=paste("PC2 (",round(p$values$Relative_eig[2]*100,1),"%)"),col="white",frame=FALSE)
	if(labels==TRUE)
		{
		text(p$vectors[,1],p$vectors[,2],inds$nr[indselection],col=colourcode[indselection],cex=0.75)
		}else{
		if(!is.null(symbolkey))
			{
			#points(p$vectors[,1],p$vectors[,2],col=colourcode[indselection],pch=inds$symboltype[indselection],cex=symbolsize)			
			symbolvector	<- c(16,17,18,20,15,0,1,2,6,3,4,5,8)
			mypch			<<- symbolvector[as.factor(symbolkeyvec)]
			points(p$vectors[,1],p$vectors[,2],col=colourcode[indselection],pch=mypch[indselection],cex=symbolsize)
			}else{
			points(p$vectors[,1],p$vectors[,2],col=colourcode[indselection],pch=16,cex=symbolsize)
			}
		}
	if(addlegend==TRUE&npops>1)
		{
		mypopcols	<- popcolours[1:npops]
		#if(addsymbols)
		#	{
		#	mysymbols	<- c(15,16,17,18,0,1,2,6,3,4,5,8)[1:npops]
		#	mysymbols	<- mysymbols[order(mysambar$populations)]
		if(!is.null(symbolkey))
			{
			# legend(legendpos,popnames,fill=mypopcols,pch=symboltype,bty="n",cex=legendcex)
			symbolvector<- c(16,17,18,20,15,0,1,2,6,3,4,5,8)
			mypch		<<- symbolvector[as.factor(symbolkeyvec)]
			legendpch	<- unique(mypch[!is.na(mypch)])
			legendkey	<- unique(symbolkeyvec[!is.na(symbolkeyvec)])
			legend(legendpos,legend=legendkey,pch=legendpch,bty="n",cex=legendcex)
			}else{
			legend(legendpos,popnames,fill=mypopcols,bty="n",cex=legendcex)
			}
		}
	if(!is.null(addtitle)){title(addtitle,line=titledistance)}
	if(!is.null(export))
		{
		dev.off()
		#path1<- paste(getwd(),exportname,sep="/")
		#path2<- paste(path1,"pca.wmf",sep = ".")
		#print(paste("PCoA-plot has been written to", path2, sep =" "))
		}
	}

plotmulti_pcoa<-function(export=NULL,mymethod="nei",nloci=c(1000,500,250,125),randomsubset=TRUE)
	{
	if(mymethod=="pi")
		{
		return(cat("ERROR: can not make SNP subsets with method 'pi'. Choose 'nei' or 'hamming'.",sep="\n"))
		}
	if(!is.null(export))
		{
		mylabel	<- ifelse(randomsubset,paste(mymethod,"randomsubset",sep="."),paste(mymethod,"highest_sd_maf",sep="."))
		if(export=="pdf"){pdf(paste("multi_pcoa",mylabel,"pdf",sep="."),height=18,width=18)}
		}
	nsnps		<- nrow(snps[snps$filter,])
	mynumbers	<- c(1:nrow(snps))
	if((!randomsubset)&(!"sd_popmaf"%in%colnames(snps)))
		{
		return(cat("ERROR: SambaR couldn't find column called 'sd_popmaf' in snps dataframe. Rerun the filterdata function, or set the flag randomsubset to TRUE.",sep="\n"))
		}else{
		snpstemp	<- snps[order(-snps$sd_popmaf),]
		mynumbers2	<- snpstemp$nr[snps$filter&snps$distfilter]
		}
	par(mfrow=c(2,2))
	for(n_subset in nloci)
		{
		if(randomsubset)
			{
			mydraw		<- sample(mynumbers[snps$filter],n_subset)
			myselection	<- mynumbers%in%mydraw
			}else{
			mynumbers3	<- mynumbers2[1:n_subset]
			myselection	<- mynumbers%in%mynumbers3
			}
		add_legend		<- ifelse(n_subset==nloci[1],TRUE,FALSE)
		myselection		<<- myselection
		ape_pcoa(snpselection=myselection,method=mymethod,resetgraphics=FALSE,addlegend=add_legend)
		mtext(paste(n_subset," snps",sep=""),cex=3)
		}
	if(!is.null(export)){dev.off()}
	}

plotmulti_pcoa_old<-function(export=NULL,mymethod="nei")
	{
	if(mymethod=="theta")
		{
		return(cat("ERROR: can not make SNP subsets with method 'theta'. Choose 'nei' or 'hamming'.",sep="\n"))
		}
	if(!is.null(export))
		{
		if(export=="pdf"){pdf(paste("multi_pcoa",mymethod,"pdf",sep="."),height=18,width=18)}
		}
	nsnps	<- nrow(snps[snps$filter,])
	mynumbers	<- c(1:nrow(snps))
	par(mfrow=c(2,2))
	# all loci:
	# ape_pcoa(resetgraphics=FALSE,addlegend=FALSE)
	# mtext(paste(nsnps,"snps",sep=" "),cex=3)
	# 1000 loci:	
	mydraw		<- sample(mynumbers[snps$filter],1000)
	myselection	<- mynumbers%in%mydraw
	ape_pcoa(snpselection=myselection,method=mymethod,resetgraphics=FALSE,addlegend=TRUE)
	mtext("1000 snps",cex=3)
	# 500 loci:	
	mydraw		<- sample(mynumbers[snps$filter],500)
	myselection	<- mynumbers%in%mydraw
	ape_pcoa(snpselection=myselection,method=mymethod,resetgraphics=FALSE,addlegend=FALSE)
	mtext("500 snps",cex=3)
	# 250 loci:	
	mydraw		<- sample(mynumbers[snps$filter],250)
	myselection	<- mynumbers%in%mydraw
	ape_pcoa(snpselection=myselection,method=mymethod,resetgraphics=FALSE,addlegend=FALSE)
	mtext("250 snps",cex=3)
	# 125 loci:	
	mydraw		<- sample(mynumbers[snps$filter],125)
	myselection	<- mynumbers%in%mydraw
	ape_pcoa(snpselection=myselection,method=mymethod,resetgraphics=FALSE,addlegend=FALSE)
	mtext("125 snps",cex=3)
	if(!is.null(export)){dev.off()}
	}	
	
# Depends on package SNPRelate
# Note, if you didn't close the genofile before calling it again, you will get this ERROR: ERROR in file(filename, "wb") : cannot open the connection
# In addition: Warning message: # In file(filename, "wb") : cannot open file 'my.gds': Permission denied

snprelate_pca<-function(chrom=FALSE,export=NULL,symbolsize=2,labels=FALSE,addlegend=TRUE,legendpos="right",popnames=mysambar$populations,symboltype=16,legendcex=2)
	{
	mymatrix	<-as.matrix(mygenlight[inds$filter,snps$filter])
	if(chrom)
		{
		snpgdsCreateGeno("my.gds",snpfirstdim=FALSE,genmat=mymatrix,sample.id=inds$name[inds$filter],snp.id=snps$name[snps$filter],snp.chromosome=snps$chr[snps$filter],snp.position = snps$position[snps$filter])
		}else{
		snpgdsCreateGeno("my.gds",snpfirstdim=FALSE,genmat=mymatrix,sample.id=inds$name[inds$filter],snp.id=snps$name[snps$filter],snp.chromosome=rep(1,length(snps$name[snps$filter])),snp.position = snps$position[snps$filter])
		}
	genofile 	<- snpgdsOpen("my.gds")
	pca 		<- snpgdsPCA(genofile)
	sample.id 	<- read.gdsn(index.gdsn(genofile, "sample.id"))
	mypops		<- as.factor(inds$pop2[inds$filter])
	npops		<- length(popnames)
	pcadata 	<- data.frame(sample.id = pca$sample.id,pop=factor(mypops)[match(pca$sample.id,sample.id)],EV1 = pca$eigenvect[,1],EV2 = pca$eigenvect[,2],stringsAsFactors = FALSE)
	pcadata$col	<- inds$popcol[inds$filter]
	snpgdsClose(genofile)
	graphics.off()
	if(!is.null(export))
		{
		if(labels)
			{
			if(export=="eps"){postscript("pca.snprelate.labels.eps",family=mysambar$myfont,width=10.5,height=10.5)}	# 10.5 instead of 10 because otherwise some labels are missing
			if(export=="pdf"){pdf("pca.snprelate.labels.pdf",family=mysambar$myfont,width=10.5,height=10.5)}
			if(export=="png"){png("pca.snprelate.labels.png",family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile("pca.snprelate.labels.wmf",family=mysambar$myfont,width=10.5,height=10.5)}
			}else{
			if(export=="eps"){postscript("pca.snprelate.eps",family=mysambar$myfont,width=10.5,height=10.5)}
			if(export=="pdf"){pdf("pca.snprelate.pdf",family=mysambar$myfont,width=10.5,height=10.5)}
			if(export=="png"){png("pca.snprelate.png",family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile("pca.snprelate.wmf",family=mysambar$myfont,width=10.5,height=10.5)}
			}
		}
	# First create outline of the plot. The argument 'col="white"' hides the datapoints, so we can edit them in the next commands. 
	mycols		<- mysambar$mycolours[1:npops]
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=3.5)
	plot(pcadata$EV2,pcadata$EV1,pch=16,col="white",xlab="eigenvector 2",ylab="eigenvector 1",cex=symbolsize)
	if(labels)
		{
		text(pcadata$EV2,pcadata$EV1,pch=16,col=pcadata$col,cex=0.75)
		}else{
		if(length(symboltype)>1)
			{
			mysymbols	<<- vector()
			for (j in c(1:npops))
				{
				nrsamples	<- length(inds$name[inds$pop2==popnames[j]&inds$filter])
				symboltemp	<- rep(symboltype[j],nrsamples)
				mysymbols	<- c(mysymbols,symboltemp)		
				}
			rm(symboltemp)
			points(pcadata$EV2,pcadata$EV1,col=pcadata$col,pch=mysymbols,cex=symbolsize)
			}else{
			points(pcadata$EV2,pcadata$EV1,col=pcadata$col,pch=16,cex=symbolsize)
			}
		}
	if(addlegend==TRUE&npops>1)
		{
		if(length(symboltype)>1)
			{
			legend(legendpos,legend=popnames,fill=mycols,pch=symboltype,bty="n",cex=legendcex)
			}else{
			legend(legendpos,legend=popnames,fill=mycols,bty="n",cex=legendcex)
			}
		}
	if(!is.null(export)){dev.off}
	}

bothMDS<-function(exporttype=NULL)
	{
	if(!is.null(exporttype))
		{
		if(exporttype=="eps"){postscript("MDS.metric_vs_nonmetric.eps",family=mysambar$myfont,width=20,height=10)}
		if(exporttype=="pdf"){pdf("MDS.metric_vs_nonmetric.pdf",family=mysambar$myfont,width=20,height=10)}
		if(exporttype=="png"){png("MDS.metric_vs_nonmetric.png",family=mysambar$myfont,width=1440,height=720)}
		if(exporttype=="wmf"){win.metafile("MDS.metric_vs_nonmetric.wmf",family=mysambar$myfont,width=20,height=10)}
		}
	par(mfrow=c(1,2))
	doMDS(export=NULL,nonmetric=FALSE,labels=TRUE,addlegend=TRUE,addtitle=TRUE)	# export should be NULL
	doMDS(export=NULL,nonmetric=TRUE,labels=TRUE,addlegend=FALSE,addtitle=TRUE)	# export should be NULL
	if(!is.null(exporttype)){dev.off()}
	}
	
doMDS<-function(export=NULL,ndim=2,nonmetric=FALSE,labels=FALSE,addlegend=TRUE,legendpos="right",popnames=mysambar$populations,symboltype=16,symbolsize=2,addtitle=FALSE,legendcex=2)
	{
	mydata	<- as.matrix(mygenlight)[inds$filter,snps$filter]
	mylabels<- inds$nr[inds$filter]
	npops	<- length(popnames)
	mycols	<- inds$popcol[inds$filter]
	mypopcols<- mysambar$mycolours[1:npops]
	# calculation:
	d 		<- dist(mydata) 						# euclidean distances between the rows
	mymin	<- min(d,na.rm=TRUE)
	if(mymin<=0)
		{
		cat("Zero or negative distance in distance matrix, meaning some individuals have identical genotype scores. Skipping MDS plot.",sep="\n")
		}else{
		if(nonmetric)
			{
			myfit 	<- isoMDS(d,k=ndim)
			x 		<- myfit$points[,1]
			y 		<- myfit$points[,2]
			}else{
			myfit 	<- cmdscale(d,eig=FALSE,k=ndim) 	# k is the number of dim
			x 		<- myfit[,1]
			y 		<- myfit[,2]
			}
		# plot:
		mdstype	<- ifelse(nonmetric,"MDS.nonmetric","MDS.metric")
		if(!is.null(export))
			{
			if(labels)
				{
				if(export=="eps"){postscript((paste(mdstype,"labels.eps",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf((paste(mdstype,"labels.pdf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png((paste(mdstype,"labels.png",sep=".")),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile((paste(mdstype,"labels.wmf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				}else{
				if(export=="eps"){postscript((paste(mdstype,"eps",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf((paste(mdstype,"pdf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png((paste(mdstype,"png",sep=".")),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile((paste(mdstype,"wmf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				}
			}	
		#par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=3.5)
		par(mar=c(5,6,3,1),cex.axis=2)
		plot(x,y,xlab="",ylab="",main="",type="n",las=1)
		mtext("Coordinate 1",side=1,line=3.5,cex=3)
		mtext("Coordinate 2",side=2,line=3.5,cex=3)
		if(labels)
			{
			text(x,y,labels=mylabels,cex=.75,col=mycols)
			}else{
			points(x,y,cex=symbolsize,col=mycols,pch=symboltype)
			}	
		if(addtitle)
			{
			mytitle	<- ifelse(nonmetric,"Non-metric MDS","Metric MDS")
			mtext(mytitle,side=3,line=0.5,cex=3)
			}
		if(addlegend&npops>1)
			{
			if(length(symboltype)>1)
				{
				legend(legendpos,legend=popnames,fill=mypopcols,pch=symboltype,bty="n",cex=legendcex)
				}else{
				legend(legendpos,legend=popnames,fill=mypopcols,bty="n",cex=legendcex)
				}
			}
		if(!is.null(export)){dev.off()}
		}
	}
	
# DAPC (and PCA) with Adegenet
genlight2genind<-function(input=mygenlight)
	{
	# When trying to run dapc analysis with genlight, I got an ERROR stating that on a Windows computer mc.cores is not possible.
	# I decided to work around this problem by converting genlight object to genind object. 
	# The conversion does take time, so first check whether it is needed or whether you already did it:
	if(!is.null(mysambar$genind))
		{
		n_inds	<- dim(mysambar$genind$tab)[1]
		n_snps	<- (dim(mysambar$genind$tab)[2])/2
		if((n_inds==nrow(inds[inds$filter,]))&(n_snps==nrow(snps[snps$filter,])))
			{
			return(cat("Genind object already stored in mysambar$genind. No conversion needed.",sep="\n"))	
			}
		}
	cat("Converting genlight object to genind object...",sep="\n")
	cat("This might take a while.",sep="\n")
	#
	# First line is in case the user (you) changed inds$popcol column and populations vector but forgot to change genlight$pop correspondingly:
	mygenlight@pop		<- as.factor(inds$pop2)
	x.mat 				<- as.matrix(input[inds$filter,snps$filter]) # input is a genlight object
	x.mat[x.mat == 0] 	<- "1/1" # homozygote reference
	x.mat[x.mat == 1] 	<- "1/2" # heterozygote
	x.mat[x.mat == 2] 	<- "2/2" # homozygote alternate
	mycolnames			<- colnames(x.mat)
	mycolnames			<- gsub(":","_",mycolnames)			# 09-07-19: to avoid ERROR: ERROR in .local(.Object, ...) : more than one '.' in column names; please name column as [LOCUS].[ALLELE]
	mycolnames			<- gsub("\\.","_",mycolnames)		# 09-07-19: to avoid ERROR: ERROR in .local(.Object, ...) : more than one '.' in column names; please name column as [LOCUS].[ALLELE]
	colnames(x.mat)		<- mycolnames
	x.mat				<<- x.mat
	mygenind 	  		<- df2genind(x.mat, sep = "/", ploidy = 2)
	pop(mygenind)	  	<- as.vector(mygenlight@pop[inds$filter])
	mysambar$genind		<<- mygenind
	cat("Conversion finished. Genind object is stored at mysambar$genind.",sep="\n")
	}

# dudi.pca does not accept missing data (ERROR: na entries in table)
# therefore, I don't use the following function:	
adegenet_pca<-function(export=NULL,nfactor=10)
	{
	if(is.null(mysambar$genind))
		{
		return(cat("ERROR: No genind object at mysambar$genind. Did you run the genlight2genind()-function?",sep="\n"))
		}
	mygenind		<- mysambar$genind			
	nind			<- nrow(inds[inds$filter,])
	nloc			<- nrow(snps[snps$filter,])
	mypops			<- inds$pop2[inds$filter]
	mypoplabels		<- as.vector(unique(mypops))
	col				<- as.vector(unique(inds$popcol[inds$filter]))
	pca1 			<- dudi.pca(mygenind,cent=FALSE,scale=FALSE,scannf=FALSE,nf=10)
	#
	# PCA eigenvalues (can also be inset in graph):
	if(!is.null(export)){pdf(paste("adegenet.pca.eigenvalues",nloc,"loci",nind,"samples.pca.pdf",sep="."),width=6,height=6)}
	barplot(pca1$eig[1:50],main="PCA eigenvalues", col=heat.colors(50))
	if(!is.null(export)){dev.off()}
	#
	# PCA plot:
	if(!is.null(export)){pdf(paste("adegenet.pca",nloc,"loci",nind,"samples.pca.pdf",sep="."),width=12,height=12)}
	par(mfrow=c(2,2),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
	s.class(pca1$li, pop(mygenind),xax=1,yax=2,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 1-2"))
	s.class(pca1$li, pop(mygenind),xax=1,yax=3,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 1-3"))
	s.class(pca1$li, pop(mygenind),xax=2,yax=3,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 2-3"))
	s.class(pca1$li, pop(mygenind),xax=1,yax=4,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 1-4"))
	if(!is.null(export)){dev.off()}
	# unused:
	# s.label(pca1$li,xax=1,yax=2)														# to plot sample labels
	# add.scatter.eig(pca1$eig[1:20],nf=nfactor,xax=1,yax=2, posi = "bottomright")		# to add inset of PCA eigenvalues
	}

# 09-01-2018: are the following lines regarding the dapc function still true?
#If the length of your populations vector is one (so all individuals are assigned to the same population), the dapc plot will be created interactively, which means that at a certain point you are prompted to input numbers on the screen. Because the plot is generated two times (different formats), and because you get 4 questions per plot, this will be a bit repetitive. 
#The prompts are (and rough guidelines to what the input should be):
#Choose the number PCs to retain (>= 1): 			1/3*nind
#Choose the number of clusters (>=2: 				your a priori guess
#Choose the number PCs to retain (>=1): 			1/3*nind
#Choose the number discriminant functions to retain (>=1):	 3
#If you have your samples assigned to more than one population, this will be done automatically for you, so you won’t be prompted.  

adegenet_dapc<-function(export=NULL,sumstatsplot=TRUE,maxclusters=5,transparent=0.6,symbolsize=2,addlegend=TRUE,legendpos="right",legendcex=1.5,use_current_dir=FALSE)
	{	
	if(is.null(mysambar$genind))
		{
		return(cat("ERROR: No genind object stored at mysambar$genind. Did you run the genlight2genind()-function?",sep="\n"))
		}
	if(!use_current_dir){setwd(mysambar$structuredir)}
	# First create indstemp file with all samples clustered together per population:
	mygenind		<- mysambar$genind
	mymatrixtemp	<- as.matrix(mygenind)
	mypopnames		<- inds$pop[inds$filter]
	mymatrixtemp	<- mymatrixtemp[order(mypopnames),]
	mygenind		<- as.genind(mymatrixtemp)
	indstemp		<- inds[order(inds$pop),]
	pop(mygenind)	<- as.factor(indstemp$pop2[inds$filter])
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name[indstemp$filter])))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	# Now start analysis:	
	nind			<- nrow(indstemp[indstemp$filter,])
	nloc			<- nrow(snps[snps$filter,])
	mypops			<- indstemp$pop2[indstemp$filter]
	mypoplabels		<- as.vector(unique(mypops))
	mycols			<- as.vector(unique(indstemp$popcol[indstemp$filter]))	# used for barplot
	mycols			<- mycols[order(mypoplabels)]							# how to double check if colours are assigned to clusters correctly?
	npops			<- length(mypoplabels)
	if(npops==1)
		{
		cat("At present only 1 population defined.",sep="\n")
		cat("To run without ERRORs, DAPC needs at least 2 populations as input.",sep="\n")		# ERROR message: ERROR in svd(X, nu = 0L) : infinite or missing values in 'x'
		cat("Therefore, Sambar randomly assigned the samples to 2 populations.",sep="\n")
		myhalf			<- floor(nind/2)
		myrandomlabels	<- c(rep("random_pop1",myhalf),rep("random_pop2",(nind-myhalf)))
		pop(mygenind)	<- myrandomlabels
		mypopulations	<- c("random_pop1","random_pop2")
		npops			<- 2
		}else{
		mypopulations	<- mysambar$populations
		}
	if(sumstatsplot)
		{
		## create plot with dapc summary statistics:
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("dapc.summarystatistics.eps",family=mysambar$myfont,width=19,height=7)}
			if(export=="pdf"){pdf("dapc.summarystatistics.pdf",family=mysambar$myfont,width=19,height=7)}
			if(export=="png"){png("dapc.summarystatistics.png",family=mysambar$myfont,width=1300,height=500)}
			if(export=="wmf"){win.metafile("dapc.summarystatistics.wmf",family=mysambar$myfont,width=19,height=7)}
			# wmf only works if solid = 1 (Otherwise ERROR about blank input)
			}
		par(mfrow=c(1,3),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
		#
		## plot pca eigenvalues:
		dapc.out 		<- dapc(mygenind,n.pca=100,n.da=100)	# we set n.pca and n.da for now really high so pc's cover 100 of explained variance (and for nda no choice is made yet(?))
		mypcaeigen 		<- dapc.out$pca.eig
		mypcaeigensum 	<- 100*cumsum(mypcaeigen)/sum(mypcaeigen)
		mytotalpca		<- length(mypcaeigensum)
		# Retaining too many components with respect to the number of individuals can lead to over-fitting and unstability in the membership probabilities returned by the method 
		# The bottomline is therefore retaining a few PCs without sacrificing too much information.
		# Different ways to determine optimal number:
		# mynpca		<- which(mypcaeigensum>80)[1]			# when 80% explained?
		# mynpca		<- which((diff(mypcaeigensum)<0.5))[1]	# alternative method: when added explained variance below a certain threshold (e.g 0.5%)? 
		# accepted way is using built-in function of dapc, which calculates a so called a score, and outputs a plot at the same time:
		my_ascore 		<- optim.a.score(dapc.out)			
		mynpca			<- my_ascore$best
		# if mynpca is below 10, use my method: 
		if(mynpca<10)
			{
			cat(paste("Based on the a-score statistic,",mynpca,"is the optimal number of PCs. This seems too low, so using 80 percent explained variance as threshold instead.",sep=" "),sep="\n")
			#mynpca		<- which((diff(mypcaeigensum)<0.5))[1]	# this way all samples in a population become one indistuingable big blot
			mynpca		<- which(mypcaeigensum>80)[1]
			}else{
			cat(paste("Based on the a-score statistic,",mynpca,"is the optimal number of PCs. DAPC-analyses will be executed using this value.",sep=" "),sep="\n")
			}
		plot(mypcaeigensum,col=rep(c("orange","grey20"),c(mynpca,1000)),ylim=c(0,100),xlim=c(0,mytotalpca),main="Variance explained by PCA", xlab="PCA axis", ylab="Cumulated variance (%)",cex=1, pch=20, type="h", lwd=2)
		legend("topleft",legend=c("Not retained","Retained"),fill=c("grey20","orange"),bty='n',cex=1.5)
		#
		## create bic plot:
		# I set max.n.clust to 10, unless datasets contain no more than 10 (sub)populations, or less individuals): 
		mymaxcluster	<- 10
		mymaxcluster	<- ifelse(npops>10,npops,mymaxcluster)
		mymaxcluster	<- ifelse(nind<10,nind-1,mymaxcluster)
		grp 			<- find.clusters(mygenind,max.n.clust=mymaxcluster,n.pca=mynpca,choose.n.clust=FALSE)	
		plot(grp$Kstat,main="Bic value",xlab="Number of clusters",ylab="BIC",type='b',col="grey20")
		if(!is.null(export)){dev.off()}
		#
		# plot reassignment of samples:
		# this plot is difficult to assign population colours, because I am not sure whether clusters defined by dapc are the same as population clusters
		# graphics.off()
		# if(!is.null(export))
		#	{
		#	if(export=="eps"){postscript("dapc.barplot.eps",family=mysambar$myfont,width=13,height=7)}
		#	if(export=="pdf"){pdf("dapc.barplot.pdf",family=mysambar$myfont,width=13,height=7)}
		#	if(export=="png"){png("dapc.barplot.png",family=mysambar$myfont,width=720,height=500)}
		#	if(export=="wmf"){win.metafile("dapc.barplot.wmf",family=mysambar$myfont,width=13,height=7)}
		#	# wmf only works if solid = 1 (Otherwise ERROR about blank input)
		#	}
		# if(npops==1)
		#	{
		#	tempcols<-mysambar$mycolours[1:2]
		#	}else{
		#	tempcols=mycols1
		#	}
		# par(mar=c(4.5,15,1,2.5),cex.axis=2,cex.lab=2.5,cex.main=2.5)
		# sumtemp <- summary(dapc(mygenind, n.da=20, n.pca=mynpca))$assign.per.pop*100
		# barplot(sumtemp, xlab="% of reassignment to actual cluster",horiz=TRUE,las=1,col=tempcols,xlim=c(0,100))
		# if(!is.null(export)){dev.off()}
		#
		# not sure what this plot is doing:
		# barplot(dapc.out$eig,main="Discriminant analysis eigenvalues",ylab="F-statistic",xlab="Linear Discriminants",col="orange",names.arg=c(1:length(dapc.out$eig)))
		#
		}
	myclusters	<- c(2:maxclusters)
	cat("Running DAPC analyses for various number of expected clusters (K).",sep="\n")
	cat("Observe the screeplot in the 'dapc.summarystatistics'-plot to find the optimal K value (lowest point or flattening of decline).",sep="\n")
	myoverlap	<- list()
	dapcqmatrixlist	<- list()
	for (i in myclusters)
		{
		cat(paste("K =",i,sep=" "),sep="\n")
		#
		## create table showing correspondence between DAPC inferred clusters and expected population division (depends on library(gplots)):
		grp 				<- find.clusters(mygenind,max.n.clust=20,n.pca=mynpca,n.clust=i)
		# From the adegenet manual: For small number of clusters (less than tens), all DA eigenvalues can be saved. 
		# I set n.da to upper limit of 20, but only 'ncluster - 1' are saved when running dapc function   
		dapc.out 			<- dapc(mygenind,grp$grp,n.pca=mynpca,n.da=20)			
		mytable				<- as.matrix(table(pop(mygenind),grp$grp))	
		colnames(mytable)	<-paste("cluster",levels(grp$grp),sep="_")
		myoverlap[[i-1]]	<- mytable
		#
		# matrix with population membership probabilities:
		myqmatrix				<- round(dapc.out$posterior,3)
		myqmatrix				<- myqmatrix[order(rownames(myqmatrix)),]
		dapcqmatrixlist[[i-1]]	<- myqmatrix
		#
		# Scatter plots:
		graphics.off()
		# to add DAPC eigenvalues: scree.da=TRUE; to add PCA eigenvalues: scree.pca=TRUE
		# as mentioned above, number of discriminant functions is nclusters (i) - 1.
		# if i = 2, there is only one option: xax = 1 and yax = 1.
		# if i = 3, there are 3 options: xax = 1 and yax=1; xax = 1 and yax = 2, xax = 2 and yax = 2. However, we are only interested in the second option.
		# if i = 4 or more, this are the options we are interested in: xax = 1 and yax = 2, xax = 1 and yax = 3, xax = 2 and yax = 3.
		# so:
		mydapc	<- as.data.frame(dapc.out$ind.coord)
		mydapc	<<- mydapc
		# if (i == 2)
		#	{
		#	if(!is.null(export))
		#		{
		#		if(export=="eps"){postscript(paste("dapc.K",i,"scatter.dapc.eps",sep="."),height=6,width=6)}
		#		if(export=="pdf"){pdf(paste("dapc.K",i,"scatter.dapc.pdf",sep="."),height=6,width=6)}
		#		if(export=="png"){png(paste("dapc.K",i,"scatter.dapc.png",sep="."),height=720,width=720)}
		#		if(export=="wmf"){win.metafile(paste("dapc.K",i,"scatter.dapc.wmf",sep="."),height=6,width=6)}
		#		}
		#	add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
		#	scatter(dapc.out, grp=mypops, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=transparent,cex.lab=2.5,clabel=2.5,label=NULL,legend=add_leg)
		#	if(!is.null(export)){dev.off()}
		#	}
		if (i == 3)
			{
			for(myrun in c(1:4))
				{
				if(!is.null(export))
					{
					mysymbol	<- ifelse(myrun<3,ifelse(myrun==1,"dots.withlegend","dots.nolegend"),ifelse(myrun==3,"labels.withlegend","labels.nolegend"))
					if(export=="eps"){postscript(paste("dapc.K",i,"scatter.dapc",mysymbol,"eps",sep="."),height=10,width=10)}
					if(export=="pdf"){pdf(paste("dapc.K",i,"scatter.dapc",mysymbol,"pdf",sep="."),height=10,width=10)}
					if(export=="png"){png(paste("dapc.K",i,"scatter.dapc",mysymbol,"png",sep="."),height=720,width=720)}
					if(export=="wmf"){win.metafile(paste("dapc.K",i,"scatter.dapc",mysymbol,"wmf",sep="."),height=10,width=10)}
					}
				par(cex.axis=2,cex.lab=2.5,cex.main=2.5)
				#scatter(dapc.out, grp=mypops, col=mycols, xax=1, yax=2, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=transparent,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
				if(myrun<3)
					{
					plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					}else{
					plot(mydapc$LD1,mydapc$LD2,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					text(mydapc$LD1,mydapc$LD2,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
					}
				abline(v=0,col="grey")
				abline(h=0,col="grey")
				if(myrun%%2!=0)
					{
					add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
					if(add_leg){legend(legendpos,legend=mypopulations,fill=mysambar$mycolours[1:npops],bty='n',cex=legendcex)}
					}
				mtext("DAs: 1 vs 2",side=3,line=0,cex=2.5)
				if(!is.null(export)){dev.off()}
				}
			}
		if (i == 4)
			{
			for(myrun in c(1:4))
				{
				if(!is.null(export))
					{
					mysymbol	<- ifelse(myrun<3,ifelse(myrun==1,"dots.withlegend","dots.nolegend"),ifelse(myrun==3,"labels.withlegend","labels.nolegend"))
					if(export=="eps"){postscript(paste("dapc.K",i,"scatter.dapc",mysymbol,"eps",sep="."),height=12,width=12)}
					if(export=="pdf"){pdf(paste("dapc.K",i,"scatter.dapc",mysymbol,"pdf",sep="."),height=12,width=12)}
					if(export=="png"){png(paste("dapc.K",i,"scatter.dapc",mysymbol,"png",sep="."),height=1200,width=1200)}
					if(export=="wmf"){win.metafile(paste("dapc.K",i,"scatter.dapc",mysymbol,"wmf",sep="."),height=12,width=12)}
					}
				#par(mfrow=c(2,2),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
				par(mfrow=c(2,2),mar=c(1,2,2,1),cex.axis=2,cex.lab=2.5,cex.main=2.5)
				#scatter(dapc.out, grp=mypops, xax=1, yax=2, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
				if(myrun<3)
					{
					plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					}else{
					plot(mydapc$LD1,mydapc$LD2,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					text(mydapc$LD1,mydapc$LD2,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
					}
				abline(v=0,col="grey")
				abline(h=0,col="grey")
				if(myrun%%2!=0)
					{
					add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
					if(add_leg){legend(legendpos,legend=mypopulations,fill=mysambar$mycolours[1:npops],bty='n',cex=legendcex)}
					}
				mtext("DAs: 1 vs 2",side=3,line=0,cex=2.5)
				#scatter(dapc.out, grp=mypops, xax=1, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
				if(myrun<3)
					{
					plot(mydapc$LD1,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					}else{
					plot(mydapc$LD1,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					text(mydapc$LD1,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
					}
				abline(v=0,col="grey")
				abline(h=0,col="grey")
				mtext("DAs: 1 vs 3",side=3,line=0,cex=2.5)
				#scatter(dapc.out, grp=mypops, xax=2, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
				if(myrun<3)
					{
					plot(mydapc$LD2,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					}else{
					plot(mydapc$LD2,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					text(mydapc$LD2,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
					}
				abline(v=0,col="grey")
				abline(h=0,col="grey")
				mtext("DAs: 2 vs 3",side=3,line=0,cex=2.5)
				if(!is.null(export)){dev.off()}
				}
			}
		if (i > 4)
			{
			for(myrun in c(1:4))
				{
				if(!is.null(export))
					{
					mysymbol	<- ifelse(myrun<3,ifelse(myrun==1,"dots.withlegend","dots.nolegend"),ifelse(myrun==3,"labels.withlegend","labels.nolegend"))
					if(export=="eps"){postscript(paste("dapc.K",i,"scatter.dapc",mysymbol,"eps",sep="."),height=12,width=12)}
					if(export=="pdf"){pdf(paste("dapc.K",i,"scatter.dapc",mysymbol,"pdf",sep="."),height=12,width=12)}
					if(export=="png"){png(paste("dapc.K",i,"scatter.dapc",mysymbol,"png",sep="."),height=1200,width=1200)}
					if(export=="wmf"){win.metafile(paste("dapc.K",i,"scatter.dapc",mysymbol,"wmf",sep="."),height=12,width=12)}
					}
				#par(mfrow=c(2,2),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
				par(mfrow=c(2,2),mar=c(1,2,2,1),cex.axis=2,cex.lab=2.5,cex.main=2.5)
				#scatter(dapc.out, grp=mypops, xax=1, yax=2, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
				if(myrun<3)
					{
					plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					}else{
					plot(mydapc$LD1,mydapc$LD2,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					text(mydapc$LD1,mydapc$LD2,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
					}
				abline(v=0,col="grey")
				abline(h=0,col="grey")
				if(myrun%%2!=0)
					{
					add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
					if(add_leg){legend(legendpos,legend=mypopulations,fill=mysambar$mycolours[1:npops],bty='n',cex=legendcex)}
					}
				mtext("DAs: 1 vs 2",side=3,line=0,cex=2.5)
				#scatter(dapc.out, grp=mypops, xax=1, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
				if(myrun<3)
					{
					plot(mydapc$LD1,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					}else{
					plot(mydapc$LD1,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					text(mydapc$LD1,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
					}
				abline(v=0,col="grey")
				abline(h=0,col="grey")
				mtext("DAs: 1 vs 3",side=3,line=0,cex=2.5)
				#scatter(dapc.out, grp=mypops, xax=2, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
				if(myrun<3)
					{
					plot(mydapc$LD2,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					}else{
					plot(mydapc$LD2,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					text(mydapc$LD2,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
					}
				abline(v=0,col="grey")
				abline(h=0,col="grey")
				mtext("DAs: 2 vs 3",side=3,line=0,cex=2.5)
				#scatter(dapc.out, grp=mypops, xax=1, yax=4, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
				if(myrun<3)
					{
					plot(mydapc$LD1,mydapc$LD4,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					}else{
					plot(mydapc$LD1,mydapc$LD4,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
					text(mydapc$LD1,mydapc$LD4,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
					}
				abline(v=0,col="grey")
				abline(h=0,col="grey")
				mtext("DAs: 1 vs 4",side=3,line=0,cex=2.5)
				if(!is.null(export)){dev.off()}
				}
			}
		}
	dapcqmatrixlist		<<- dapcqmatrixlist
	names(dapcqmatrixlist)	<<- paste("K",myclusters,sep="")
	# create heatmaps showing overlap between dapc inferred clusters and your a priori defined populations:
	graphics.off()
	ntables			<- length(myoverlap)
	mymax			<- max(unlist(myoverlap))
	mymin			<- min(unlist(myoverlap))
	mycolfunc 		<- colorRampPalette(c("white","orange"))
	myBreaks		<- seq(mymin,mymax,(mymax/10))
	myColours		<- c(mycolfunc(length(myBreaks)-1))		
	gl <- lapply(1:length(myoverlap), function(i){
		mymatrix	<- data.matrix(myoverlap[[i]])
		heatmap.2(mymatrix,cellnote=mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			notecol="black",notecex=2.5,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=45,srtCol=45,key=FALSE,margins=c(8,8))
		grid.echo()
		grid.grab()})
	graphics.off()
	if(!is.null(export))
		{
		myheight	<- ceiling(ntables/2)*6.5
		mywidth		<- ifelse(ntables==1,7.5,15)
		myheight2	<- ceiling(ntables/2)*650
		mywidth2	<- ifelse(ntables==1,750,1500)
		if(export=="eps"){postscript("dapc.inferred.vs.expectedclusters.eps",height=myheight,width=mywidth)}
		if(export=="pdf"){pdf("dapc.inferred.vs.expectedclusters.pdf",height=myheight,width=mywidth,onefile=FALSE)}
		if(export=="png"){png("dapc.inferred.vs.expectedclusters.png",height=myheight2,width=mywidth2)}
		if(export=="wmf"){win.metafile("dapc.inferred.vs.expectedclusters.wmf",height=myheight,width=mywidth)}
		}	
	grid.newpage()
	grid.arrange(grobs=gl, ncol=2, clip=TRUE)	
	if(!is.null(export)){dev.off()}
	}

makenetworks<-function(nplots=3)
	{
	if(is.null(mysambar$mydnabin))
		{
		genlight2DNAbin(export=TRUE) 
		}
	for(plotnr in c(1:nplots))
		{
		makenetwork(export=TRUE,exportname=paste("Genotype_network",plotnr,sep="_"))
		}
	}
	
makenetwork<-function(myinput=mysambar$mydnabin,nloci=1000,popnames=mysambar$populations,legendpos="topleft",legendcex=1.5,myratio=0.1,export=FALSE,exportname="Genotype_network")
	{
	# too many loci results in overlapping circles.
	# 1000 randomly sampled loci with a ratio of 0.1 works best 
	if(is.null(myinput))
		{
		return(cat("ERROR: specified input file does not exist. Did you run the genlight2DNAbin() function?",sep="\n"))
		}
	# define pops and colours:
	indstemp	<- inds[inds$filter,]
	myorder		<- order(indstemp$pop)
	indstemp	<- indstemp[myorder,]
	mypops		<- indstemp$pop
	mypops2		<- popnames[order(popnames)]
	npops		<- length(popnames)
	mycolours	<- mysambar$mycolours[1:npops]
	# mycolours	<- mycolours[order(popnames)]
	# create network: 
	bigdataset	<- ncol(myinput)>nloci
	if(bigdataset)
		{
		myinput		<- myinput[myorder,sample(c(1:ncol(myinput)),nloci,replace=FALSE)]
		}else{
		myinput		<- myinput[myorder,]
		}
	ndata		<- ncol(myinput)
	e 			<- dist.dna(myinput)
	h 			<- pegas::haplotype(myinput)
	h 			<- sort(h, what = "label")
	net 		<- pegas::haploNet(h)
	ind.hap		<- with(stack(setNames(attr(h, "index"), rownames(h))),table(hap=ind, pop=mypops[values]))
	# plot:
	# without legend:
	if(export){pdf(paste(exportname,ndata,"snps.pdf",sep="."))}
	plot(net,show.mutation=0,bg=mycolours,size=attr(net,"freq"),scale.ratio=myratio,pie=ind.hap,label=FALSE,fast = FALSE)
	dev.off()
	# with legend:
	exportname	<- paste(exportname,"legend",sep=".")
	if(export){pdf(paste(exportname,ndata,"snps.pdf",sep="."))}
	plot(net,show.mutation=0,bg=mycolours,size=attr(net,"freq"),scale.ratio=myratio,pie=ind.hap,label=FALSE,fast = FALSE)
	legend(legendpos,mypops2,col=mycolours,pch=19,ncol=1,bty='n',cex=legendcex)
	if(export){dev.off()}
	}	
		
	
# Bayesian population assignment probabilities:
assign2pop<-function(popnames=mysambar$populations,mylabels=inds$name2[inds$filter],bayesian=TRUE)
	{
	# I developed this method myself, but it turns out to be roughly similar to methods described in:
	# Peatkau et al, 1995, Microsatellite analysis of population structure in Canadian polar bears; 
	# Pritchard et al, 2000, Inference of population structure using multilocus genotype data;
	#
	# What we want to know is: what is the probability that an individual belongs to a certain population given it's observed genotype?
	# This can be denoted as Pr(hypothesis|observation) or in short Pr(H|O).
	# The hypothesis H is the population assignment and the observation O is the genotype score. The genotype score is either 0 (homozygous major), 1 (heterozygous), or 2 (homozygous minor).
	# To find the answer we are going to use the following Bayesian formula:
	# Pr(H|O) = (Pr(O|H)*Pr(H))/Pr(O)
	# in which:
	# Pr(H) 	= 1/npops 			# flat prior distribution
	# Pr(O|H) 	= probability of observed genotypes given the population minor allele frequencies
	# Pr(O)		= sum of product of Pr(H) and Pr(O|H) for all populations
	# Since we use a flat prior distribution, the formula can be simplified to:
	# Pr(H1|O) 	= Pr(O|H1)/(Pr(O|H1)+Pr(O|H2)+ ... + Pr(O|Hn))	# in which n denotes number of populations
	# For example: say we have two bottles, one (A) with 10 red and 90 white balls, and the other (B) with 1 red and 99 red balls.
	# A ball is drawn from either bottle (you don't know which), and it happens to be red. From which bottle is the ball drawn?
	# Pr(A|red) = Pr(red|A)/(Pr(red|A)+Pr(red|B)) = 0.1/(0.1+0.01) = 0.91
	# Pr(B|red) = Pr(red|B)/(Pr(red|A)+Pr(red|B)) = 0.01/(0.1+0.01) = 0.09
	# Similarly, we are going to calculate the probabilities that a sample has been drawn from any of our populations:
	# Pr(popA|genotype) = Pr(genotype|popA)/(Pr(genotype|popA)+Pr(genotype|popB))
	# Pr(popB|genotype) = Pr(genotype|popB)/(Pr(genotype|popA)+Pr(genotype|popB)) 
	# For example, say we have 2 populations, and for a particular locus one population (A) has a minor allele frequency (MAF) of 10 percent, and the other a MAF of 1 percent.
	# What is the chance that an individual which is homozygous for both major alleles (i.e. genotype 0) belongs to either popA or popB?
	# Pr(popA|0) = Pr(0|popA)/(Pr(0|popA)+Pr(0|popB)) = (0.9*0.9)/(0.9*0.9+0.99*0.99) = 0.45 
	# Pr(popB|0) = Pr(0|popB)/(Pr(0|popA)+Pr(0|popB)) = (0.99*0.99)/(0.9*0.9+0.99*0.99) = 0.55
	# This example only shows one locus. When having multiple loci, we calculate the probabilities Pr(geno|popA) and Pr(geno|popB) by multiplying each locus specific probability (assuming they are independent):
	# Pr(geno|popA) = Pr(locus_1|popA)*Pr(locus_2|popA)*...*Pr(locus_k|popA)						# in which k denotes total number of loci
	# Pr(geno|popB) = Pr(locus_1|popB)*Pr(locus_2|popB)*...*Pr(locus_k|popB)						# in which k denotes total number of loci
	# In the script this is (roughly) written as: Pr_geno[j] <- (j-1)*Pr_geno[j-1]*Pr_locus[j]		# in which j denotes each jth locus
	# Excluded from the calculation are all snps for which one of either alleles are not represented in all populations. Those loci would make the probability converge to 0 or 1, and hence they are omitted. 
	#
	# also another way:
	# simply counting how often (for how many loci) a genotype is derived from a population
	#
	myfilter			<- snps$filter
	nsnps				<- nrow(snps[myfilter,])
	ninds				<- nrow(inds)
	npops				<- length(popnames)
	mycol				<<- rep(NA,npops)
	mymafs				<- matrix(NA,nsnps,npops)
	colnames(mymafs)	<- popnames
	for (k in c(1:npops))
		{
		if(!(paste("maf",popnames[k],sep="_")) %in% colnames(snps))
			{
			cat("Missing column with maf values. Execute 'maffunction()' followed by 'correctmaf()' and then try running 'assign2pop()' again",sep="\n")
			} 
		maftemp			<- snps[,paste("maf",popnames[k],sep="_")]
		mymafs[,k]		<- maftemp[myfilter]
		mycol[k]		<<- inds$popcol[inds$pop2==popnames[k]][1]
		}
	mymafs[is.na(mymafs)]<- 0.0000001		# 09-07-19: quick and dirty solution for ERROR: ERROR in if (any(mymafs[j, ] == 0) | any(mymafs[j, ] == 1)) { : missing value where TRUE/FALSE needed
	# start the calculation:
	myassign			<- matrix(NA,ninds,npops)
	myassignalt			<<- matrix(NA,ninds,npops)	# new/temp
	for (i in c(1:nrow(inds)))
		{		
		#
		# cat(as.vector(inds$name[i]),sep="\n")
		myprmat			<- matrix(NA,nsnps,npops)
		mycountmat		<- matrix(NA,nsnps,npops)		### new
		indgeno			<- as.matrix(mygenlight[i,myfilter])
		# pr based on first locus:
		mygeno			<- indgeno[1]
		mypr			<- rep(NA,npops)
		for (k in c(1:npops))
			{
			mypr[k]		<- ifelse(mygeno==2,mymafs[1,k]*mymafs[1,k],ifelse(mygeno==1,2*mymafs[1,k]*(1-mymafs[1,k]),(1-mymafs[1,k])*(1-mymafs[1,k])))
			}
		if(any(is.na(mypr)))
			{
			mypr		<-rep(1/npops,npops)
			mycountmat[1,]	<- rep(NA,npops)
			}else{
			mycountmat[1,]	<- mypr==max(mypr)	
			}
		mypr			<- mypr/sum(mypr)	 
		myprmat[1,] 		<- mypr
		# 
		# now update probability with info from all loci:
		for (j in c(2:nsnps))
			{
			# cat(j,sep="\n")
			mygeno		<- indgeno[j]
			mynewpr		<- rep(NA,npops)
			if(is.na(mygeno))
				{
				myprmat[j,]	<- myprmat[j-1,]
				mycountmat[j,]	<- rep(NA,npops)	
				}else{
				for (k in c(1:npops))
					{
					mynewpr[k]<- ifelse(mygeno==2,mymafs[j,k]*mymafs[j,k],ifelse(mygeno==1,2*mymafs[j,k]*(1-mymafs[j,k]),(1-mymafs[j,k])*(1-mymafs[j,k])))
					}
				mycountmat[j,]	<- mynewpr==max(mynewpr)
				if(any(mymafs[j,]==0)|any(mymafs[j,]==1))
					{
					myprmat[j,]	<- myprmat[j-1,]				# I am excluding from the calculation all snps with at least one population without the minor alleles. Otherwise the probability converges immediately to 0 or 1.   
					}else{
					mynewpr		<- mynewpr/sum(mynewpr)
					for (k in c(1:npops))
						{
						mypr[k] <- (j-1)*mypr[k]*mynewpr[k]
						}
					mypr		<- mypr/sum(mypr)
					myprmat[j,]	<- mypr
					}
				}
			}	
		myassign[i,]		<- myprmat[j,]
		# alternative way:						
		for (k in c(1:npops))
			{
			mycount		<- mycountmat[,k]
			myassignalt[i,k]<- length(mycount[mycount==TRUE&!is.na(mycount)])
			}
		}
	myassign[myassign<0.0001]	<- 0
	myassign[myassign>0.9999]	<- 1
	for (i in c(1:nrow(myassignalt)))
		{
		mysum		<- sum(myassignalt[i,])
		myassignalt[i,] <- myassignalt[i,]/mysum
		}
	for (k in c(1:npops))
		{
		inds$prtemp		<<- myassign[,k]
		names(inds)[names(inds) == "prtemp"] <<- paste("pr",popnames[k],sep = "")
		}
	inds 				<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	# to plot:
	myassign2	<<- t(myassign)
	myassign3	<<- t(myassignalt)
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}
	
plotassign2pop<-function(export=NULL,bayesian=TRUE,popnames=mysambar$populations,shortpop=NULL,addsamplenr=TRUE,myinset=-0.15)
	{
	# First create indstemp file with all samples clustered together per population:
	indstemp			<- inds[order(inds$pop),]
	nsamples			<- length(indstemp$name2[indstemp$filter])
	if(addsamplenr)
		{
		mylabels			<- indstemp$nr[indstemp$filter]
		}else{
		mylabels			<- rep("",nsamples)
		}
	myassign2			<- myassign2[,order(inds$pop)]
	myassign3			<- myassign3[,order(inds$pop)]
	if(is.null(shortpop))
		{
		shortpop		<- substr(popnames,1,2)
		if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
			{
			shortpop	<- substr(popnames,1,3)
			}
		}
	# get info needed for plot:
	mylocs	<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		mypops		<- indstemp$pop2[indstemp$filter]
		mylocs[i]	<- which(mypops==mypop)[1]-1
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit black line of first population (because not necessary)
	mylocs		<- mylocs+1		# can not subset xpos with value 0
	npops		<- length(popnames)
	#
	# Now we are ready to plot:
	if(!is.null(export))
		{
		mywidth		<- nsamples*0.25+8
		mywidth2	<- nsamples*25+800
		plotname	<- ifelse(addsamplenr,"popassign.bayesian.withsamplenr","popassign.bayesian")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=6)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=6)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=600)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=6)}
		}
	par(mar=c(4.5,8,5.5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	if(bayesian)
		{
		# plot bayesian probability:
		mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,0.75,1),1.5)
		#legendcex	<- ifelse(npops>10,1.5,2.25)		# 01-10-2019: legend position difficult to control, and legend not strictly needed. Omit.
		#xpos		<- barplot(myassign2[,indstemp$filter],ylab="",col=mycol,border=NA,legend=popnames,args.legend=list(x="topright",bty = "n",inset=c(myinset,-0.05),cex=legendcex),names.arg=mylabels,cex.names=mycex,las=2)
		xpos		<- barplot(myassign2[,indstemp$filter],ylab="",col=mycol,border=NA,names.arg=mylabels,cex.names=mycex,las=2)
		mtext("Bayesian probability",cex=3,side=2,line=5)
		if(length(popnames)>3)
			{
			mylocs		<- xpos[mylocs]
			mylocs		<- mylocs-mylocs[which(mylocs==min(mylocs))]		# because xpos gives midpoint of bars.
			abline(v=mylocs,lwd=3.5)
			mylas		<- ifelse(any(table(indstemp$pop[indstemp$filter])<3),3,1)
			if(mylas==1)
				{
				mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=2.5,las=mylas)
				}else{
				mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=2.5,las=mylas)
				}
			}else{
			mylocs		<- xpos[mylocs]
			mylocs		<- mylocs-mylocs[which(mylocs==min(mylocs))]		# because xpos gives midpoint of bars.
			if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=2.5)}
			if(length(popnames>1)){abline(v=mylocs,lwd=3.5)}
			}
		}else{
		# plot counts: how many times a locus most likely to be drawn from population k:
		#barplot(myassign3[,indstemp$filter],ylab="",col=mycol,border=NA,legend=popnames,args.legend=list(x="topright",bty = "n",inset=c(-0.07,0),cex=2.25),names.arg=mylabels,cex.names=1.5,las=2)
		barplot(myassign3[,indstemp$filter],ylab="",col=mycol,border=NA,names.arg=mylabels,cex.names=1.5,las=2)
		mtext("Bayesian probability",cex=3,side=2,line=5)
		}
	if(!is.null(export)){dev.off()}
	}

plotstructure<-function(colourvector=NULL,export=NULL,shortpop=NULL,popnames=mysambar$populations,addindnr=TRUE,order_on_longitude=FALSE)
	{
	setwd(mysambar$inputfilesdir)
	filenames 	<- list.files(pattern = ".*.qmatrix.txt")
	filenames	<- filenames[order(filenames,decreasing=T)]
	qmatrixlist <- lapply(filenames,function(x)read.table(x,header=FALSE)) 
	nmatrices	<- length(filenames) 
	nsamples	<- nrow(qmatrixlist[[1]])
	maxdemes	<- ncol(qmatrixlist[[1]])
	npops		<- length(popnames)
	mydemes		<- vector()
	for(i in 1:nmatrices)
		{
		mydemes[i]	<- ncol(qmatrixlist[[i]])
		}
	if(nsamples==nrow(inds))
		{
		cat("Number of samples in input file equals total number of individuals in inds dataframe.",sep="\n")
		cat("Sambar will assume that samples in input file have the same names are in the same order (i.e. alphabetical) as in inds$name column.",sep="\n")
		dofilter	<- FALSE		
		mysamples	<- inds$name
		}else{
		if(nsamples==nrow(inds[inds$filter,]))
			{	
			cat("Number of samples in input file equals total number of retained individuals in inds dataframe.",sep="\n")
			cat("Sambar will assume that samples in input file have the same names are in the same order as in inds$name[inds$filter] column.",sep="\n")
			dofilter	<- TRUE
			mysamples	<- inds$name[inds$filter]
			}else{
			return(cat("ERROR: Number of samples in input file does not correspond with (retained or total) number of individuals in inds dataframe.",sep="\n"))
			}
		}
	nsamples		<- nrow(inds[inds$filter,])
	if(!is.null(export))
		{
		myheight1	<- nmatrices*1.25+1.5
		myheight2	<- nmatrices*125+150
		mywidth1	<- nsamples*0.1+1.5
		mywidth2	<- nsamples*80+200
		orderlabel	<- ifelse(order_on_longitude,"geo","alphabet")
		indlabel	<- ifelse(addindnr,"indnr","noxaxis")
		if(export=="eps"){postscript(paste("Structureplot",orderlabel,indlabel,"eps",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		if(export=="pdf"){pdf(paste("Structureplot",orderlabel,indlabel,"pdf",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		if(export=="png"){png(paste("Structureplot",orderlabel,indlabel,"png",sep="."),"Structureplot.LEA.indnr.png",family=mysambar$myfont,width=560,height=myheight2)}
		if(export=="wmf"){win.metafile(paste("Structureplot",orderlabel,indlabel,"wmf",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		}
	if(is.null(colourvector))
		{	
		colourvector	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","deepskyblue","greenyellow","indianred1","gray20")
		}
	if(maxdemes>length(colourvector))
		{
		cat("ERROR: maxdemes exceeds number of colours.",sep="\n")
		return(cat("Redefine the flag maxdemes or the flag colourvector. If running the findstructure() function, redefine the flag K_max or the flag colour_vector.",sep="\n"))
		}else{
		colourvector	<- colourvector[1:length(colourvector)]
		}
	if(is.null(shortpop))
		{
		shortpop		<- substr(popnames,1,2)
		if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
			{
			shortpop	<- substr(popnames,1,3)
			}
		}
	# First create indstemp file with all samples clustered together per population:
	mymatrixtemp		<- as.matrix(mygenlight)
	if(!order_on_longitude)
		{
		mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
		indstemp			<- inds[order(inds$pop),]
		}else{
		popcoorddf			<- inds[,c("pop","longitude","latitude")]
		poplong 			<- aggregate(popcoorddf$longitude,by=list(popcoorddf$pop),FUN=mean,na.rm=TRUE)
		poplat 				<- aggregate(popcoorddf$latitude,by=list(popcoorddf$pop),FUN=mean,na.rm=TRUE)
		inds$poplong		<<- NA
		inds$poplat			<<- NA
		for(j in c(1:nrow(poplong)))
			{
			mypop			<- poplong$Group.1[j]
			inds$poplong[inds$pop==mypop]	<<- poplong$x[j]
			inds$latlong[inds$pop==mypop]	<<- poplat$x[j]
			}
		mymatrixtemp		<- mymatrixtemp[order(inds$poplong),]
		indstemp			<- inds[order(inds$poplong),]
		popnames			<- popnames[order(poplong$x)]
		shortpop			<- shortpop[order(poplong$x)]
		}
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	mygenlighttemp		<- as.genlight(mymatrixtemp)
	pop(mygenlighttemp)	<- as.factor(indstemp$pop2)
	nsamples			<- nrow(indstemp[indstemp$filter,])
	# get info needed for plot:
	mylocs				<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop			<- popnames[i]
		mypops			<- indstemp$pop2[indstemp$filter]
		mylocs[i]		<- which(mypops==mypop)[1]-1
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit black line of first population (because not necessary)
	mylocs2		<<- mylocs
	#
	par(mfrow=c(length(mydemes),1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,5,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
	for(k in c(1:nmatrices))
		{
		ndemes		<- mydemes[k] 
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		qmatrix 	<- qmatrixlist[[k]]
		if(dofilter)
			{
			filteredinds<- inds[inds$filter,]
			if(!order_on_longitude)
				{
				qmatrix		<- qmatrix[order(filteredinds$pop),]
				}else{
				qmatrix		<- qmatrix[order(filteredinds$poplong),]
				}
			}else{
			if(!order_on_longitude)
				{
				qmatrix		<- qmatrix[order(inds$pop),]
				}else{
				qmatrix		<- qmatrix[order(inds$poplong),]
				}
			}
		mycolours	<- colourvector[1:ndemes]
		if(k==nmatrices&&addindnr)
			{
			mycex		<- ifelse(maxdemes<4,0.5,0.75)
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",names.arg=indstemp$nr[indstemp$filter],cex.names=mycex,las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			}else{
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			}
		if(k==1)
			{
			if(length(popnames)>3)
				{
				# las options: parallel to axis (0, default), horizontal (1), perpendicular (2), vertical (3).
				mylas	<- ifelse(any(table(indstemp$pop[indstemp$filter])<6),3,1)
				if(mylas==1)
					{
					mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)
					}else{
					mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)	# 14-07-2019: can't work out adjustment to the right
					}
				}else{
				if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)}
				}
			}
		mtext(paste("K = ",ndemes,sep=""),side=4,line=-0.75,cex=1.5)
		}
	mtext("Ancestry coefficients",side=2,line=-1.5,outer=TRUE,cex=1.75)
	if(addindnr)
		{
		mtext("Individuals",side=1,line=2.5,outer=TRUE,cex=1.75)
		}else{
		mtext("Individuals",side=1,line=1.5,outer=TRUE,cex=1.75)
		}
	if(!is.null(export)){dev.off()}
	names(qmatrixlist)	<- paste("K",mydemes,sep="_")
	qmatrixlist			<<- qmatrixlist
	if(!is.null(export))
		{
		dev.off()
		cat("Structure plot exported either to working directory or to inputfilesdir.",sep="\n")
		}
	}	
		
plotassign2pop_hetero<-function(popnames=mysambar$populations)
	{
	npops		<- length(popnames)
	mycolours	<- mysambar$mycolours[1:npops]
	#pdf("popassign.bayesian.vshetero.pdf",width=5,height=npops*1.25)
	pdf("popassign.bayesian.vshetero.pdf")
	par(cex.axis=1.5,cex.lab=2,mar=c(5,5,1,1))
	#par(mfrow=c(npops,1),mar=c(2,3.5,0.5,0.5),oma=c(2,1,1,1))
	#mymax		<- max(inds$hetero,na.rm=TRUE)
	#mymax		<- max(inds$maf,na.rm=TRUE)
	#mymax		<- max(inds$maf_all,na.rm=TRUE)
	#mymax		<- max(inds$n0,na.rm=TRUE)
	#mymax		<- max(inds$n1,na.rm=TRUE)
	#mymax		<- max(inds$n2,na.rm=TRUE)
	for (j in c(1:npops))
		{
		mypop	<- popnames[j]
		mypr	<- inds[,paste("pr",mypop,sep="")]
		#plot(inds$hetero[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$maf[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$maf_all[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$n0[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$n1[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$n2[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		firstn	<- inds$n1/inds$nsites2
		secondn	<- inds$n2/inds$nsites2
		myxlim	<- c(min(firstn,na.rm=TRUE),max(firstn,na.rm=TRUE))
		myylim	<- c(0,max(secondn,na.rm=TRUE))
		if(j==1)
			{
			plot(firstn[inds$pop==mypop],secondn[inds$pop==mypop],col=mycolours[j],pch=16,cex=2,xlim=myxlim,ylim=myylim,ylab="Proportion minor homozygous sites",xlab="Proportion heterozygous sites")
			points(firstn[inds$pop==mypop&mypr<1],secondn[inds$pop==mypop&mypr<1],pch=17,cex=3,col=mycolours[j])
			}else{
			points(firstn[inds$pop==mypop],secondn[inds$pop==mypop],col=mycolours[j],pch=16,cex=2)
			points(firstn[inds$pop==mypop&mypr<1],secondn[inds$pop==mypop&mypr<1],pch=17,cex=3,col=mycolours[j])
			}
		}
	#mtext("Heterozygosity",side=1,outer=TRUE,line=0.5)
	#mtext("Bayesian probability",side=2,outer=TRUE,line=-0.75)
	legend("topright",legend=c("Pr==1","Pr<1"),pch=c(16,17),cex=2,bty='n')
	dev.off()
	}	

LEAstructureplot<-function(maxdemes=6,colourvector=NULL,export=NULL,shortpop=NULL,popnames=mysambar$populations,addindnr=TRUE,order_on_longitude=FALSE)
	{
	nsamples		<- nrow(inds[inds$filter,])
	if(!is.null(export))
		{
		myheight1	<- maxdemes*1.25+1.5
		myheight2	<- maxdemes*125+150
		mywidth1	<- nsamples*0.1+1.5
		mywidth2	<- nsamples*80+200
		orderlabel	<- ifelse(order_on_longitude,"geo","alphabet")
		indlabel	<- ifelse(addindnr,"indnr","noxaxis")
		if(export=="eps"){postscript(paste("Structureplot.LEA",orderlabel,indlabel,"eps",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		if(export=="pdf"){pdf(paste("Structureplot.LEA",orderlabel,indlabel,"pdf",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		if(export=="png"){png(paste("Structureplot.LEA",orderlabel,indlabel,"png",sep="."),"Structureplot.LEA.indnr.png",family=mysambar$myfont,width=560,height=myheight2)}
		if(export=="wmf"){win.metafile(paste("Structureplot.LEA",orderlabel,indlabel,"wmf",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		}
	if(is.null(colourvector))
		{	
		colourvector	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","deepskyblue","greenyellow","indianred1","gray20")
		}
	if(maxdemes>length(colourvector))
		{
		cat("ERROR: maxdemes exceeds number of colours.",sep="\n")
		return(cat("Redefine the flag maxdemes or the flag colourvector. If running the findstructure() function, redefine the flag K_max or the flag colour_vector.",sep="\n"))
		}else{
		colourvector	<- colourvector[1:length(colourvector)]
		}
	if(is.null(shortpop))
		{
		shortpop		<- substr(popnames,1,2)
		if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
			{
			shortpop	<- substr(popnames,1,3)
			}
		}
	# Export data:
	# First create indstemp file with all samples clustered together per population:
	mymatrixtemp		<- as.matrix(mygenlight)
	if(!order_on_longitude)
		{
		mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
		indstemp			<- inds[order(inds$pop),]
		}else{
		popcoorddf			<- inds[,c("pop","longitude","latitude")]
		poplong 			<- aggregate(popcoorddf$longitude,by=list(popcoorddf$pop),FUN=mean, na.rm=TRUE)
		poplat 				<- aggregate(popcoorddf$latitude,by=list(popcoorddf$pop),FUN=mean, na.rm=TRUE)
		inds$poplong		<<- NA
		inds$poplat			<<- NA
		for(j in c(1:nrow(poplong)))
			{
			mypop			<- poplong$Group.1[j]
			inds$poplong[inds$pop==mypop]	<<- poplong$x[j]
			inds$latlong[inds$pop==mypop]	<<- poplat$x[j]
			}
		mymatrixtemp		<- mymatrixtemp[order(inds$poplong),]
		indstemp			<- inds[order(inds$poplong),]
		popnames			<- popnames[order(poplong$x)]
		shortpop			<- shortpop[order(poplong$x)]
		}
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	mygenlighttemp		<- as.genlight(mymatrixtemp)
	pop(mygenlighttemp)	<- as.factor(indstemp$pop2)
	genlight2ped(exportname="LEAinput",input=mygenlighttemp,in_inds=indstemp,indsfilter=indstemp$filter)
	nsamples		<- nrow(indstemp[indstemp$filter,])
	# get info needed for plot:
	mylocs			<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		mypops		<- indstemp$pop2[indstemp$filter]
		mylocs[i]	<- which(mypops==mypop)[1]-1
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit black line of first population (because not necessary)
	mylocs2		<<- mylocs
	# Reading data:
	LEA_input	<- ped2geno("LEAinput.ped","LEAinput.geno")
	obj.snmf	<- snmf("LEAinput.geno",K=2:maxdemes,ploidy=2,entropy=T,alpha = 100,project="new")
	# plot(obj.snmf, col = "blue4", cex = 1.4, pch = 19)
	mydemes		<- c(2:maxdemes)
	leaqmatrixlist	<- list()
	par(mfrow=c(length(mydemes),1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,5,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
	for(ndemes in mydemes)
		{
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		obj.snmf	<- snmf("LEAinput.geno", K = ndemes, alpha = 100, project = "new")
		qmatrix 	<- Q(obj.snmf, K = ndemes)
		leaqmatrixlist[[ndemes-1]]	<- qmatrix
		mycolours	<- colourvector[1:ndemes]
		if(ndemes==maxdemes&&addindnr)
			{
			mycex		<- ifelse(maxdemes<4,0.5,0.75)
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",names.arg=indstemp$nr[indstemp$filter],cex.names=mycex,las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			}else{
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			if(ndemes==2)
				{
				if(length(popnames)>3)
					{
					# las options: parallel to axis (0, default), horizontal (1), perpendicular (2), vertical (3).
					mylas	<- ifelse(any(table(indstemp$pop[indstemp$filter])<6),3,1)
					if(mylas==1)
						{
						mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)
						}else{
						mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)	# 14-07-2019: can't work out adjustment to the right
						}
					}else{
					if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)}
					}
				}
			}
		mtext(paste("K = ",ndemes,sep=""),side=4,line=-0.75,cex=1.5)
		}
	mtext("Ancestry coefficients",side=2,line=-1.5,outer=TRUE,cex=1.75)
	if(addindnr)
		{
		mtext("Individuals",side=1,line=2.5,outer=TRUE,cex=1.75)
		}else{
		mtext("Individuals",side=1,line=1.5,outer=TRUE,cex=1.75)
		}
	if(!is.null(export)){dev.off()}
	names(leaqmatrixlist)	<- paste("K",mydemes,sep="_")
	leaqmatrixlist			<<- leaqmatrixlist
	# to subsequently create pca:
	# mypc = pca("LEAinput.geno", scale = TRUE)
	# plot(mypc$projections,col=indstemp$popcol[indstemp$filter],pch=16)
	# remove.pcaProject("LEAinput.pcaProject")
	remove.snmfProject("LEAinput.snmfProject")
	# if function above doesn't work, delete directory and files like this:
	unlink("LEAinput.snmf", recursive=TRUE)
	}

maplea<-function(maxdemes=6,radiusratio=30,exporttype=NULL,popnames=mysambar$populations,plotperpop=FALSE,addlabels=FALSE)
	{
	npops			<- length(popnames)
	indstemp		<- inds[order(inds$pop),]
	mycoord			<- indstemp[indstemp$filter,c("longitude","latitude")]
	mypopnames		<- indstemp$pop[indstemp$filter]
	mysamplenrs		<- indstemp$nr[indstemp$filter]
	mydemes			<- c(2:maxdemes)
	for(ndemes in mydemes)
		{
		myqmatrix		<- leaqmatrixlist[[ndemes-1]]
		export_name		<- paste("LEA.qmatrixmap.K",ndemes,sep="")
		my_title		<- paste("K = ",ndemes,sep="")
		mapqmatrix(coord=mycoord,qmatrix=myqmatrix,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mytitle=my_title)
		if(plotperpop&npops>1)
			{
			for(my_pop	in popnames)
				{
				popqmatrix	<- myqmatrix[mypopnames==my_pop,]
				popcoord	<- mycoord[mypopnames==my_pop,]
				if(addlabels)
					{
					export_name	<- paste(paste("LEA.qmatrixmap.K",ndemes,"withlabels",sep=""),my_pop,sep=".")
					}else{
					export_name	<- paste(paste("LEA.qmatrixmap.K",ndemes,sep=""),my_pop,sep=".")
					}
				my_title	<- paste("K = ",ndemes,sep="")
				my_title2	<- my_pop
				if(addlabels)
					{
					my_labels	<- mysamplenrs[mypopnames==my_pop]
					}else{
					my_labels	<- NULL
					}
				if(nrow(unique(popcoord))==1)
					{
					cat(paste("Only one geographical position found for",my_pop,"population. Skipping.",sep=" "),sep="\n")
					}else{
					mapqmatrix(coord=popcoord,qmatrix=popqmatrix,aligncolours=FALSE,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mylabels=my_labels,mytitle=my_title,mytitle2=my_title2)
					}
				}
			}
		}
	}

mapdapc<-function(maxdemes=5,radiusratio=30,exporttype=NULL,popnames=mysambar$populations,plotperpop=FALSE,addlabels=FALSE)
	{
	mycoord			<- inds[inds$filter,c("longitude","latitude")]
	mypopnames		<- inds$pop[inds$filter]
	npops			<- length(mysambar$populations)
	mysamplenrs		<- inds$nr[inds$filter]
	mydemes			<- c(2:maxdemes)
	for(ndemes in mydemes)
		{
		myqmatrix		<- dapcqmatrixlist[[ndemes-1]]
		export_name		<- paste("dapc.qmatrixmap.K",ndemes,sep="")
		export_name		<- paste(export_name,"meta",sep=".")
		my_title		<- paste("K = ",ndemes,sep="")
		mapqmatrix(coord=mycoord,qmatrix=myqmatrix,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mytitle=my_title)
		if(plotperpop&npops>1)
			{
			for(my_pop	in popnames)
				{
				popqmatrix	<- myqmatrix[mypopnames==my_pop,]
				popcoord	<- mycoord[mypopnames==my_pop,]
				if(addlabels)
					{
					export_name	<- paste(paste("dapc.qmatrixmap.K",ndemes,"withlabels",sep=""),my_pop,sep=".")
					}else{
					export_name	<- paste(paste("dapc.qmatrixmap.K",ndemes,sep=""),my_pop,sep=".")
					}
				my_title	<- paste("K = ",ndemes,sep="")
				my_title2	<- my_pop
				if(addlabels)
					{
					my_labels	<- mysamplenrs[mypopnames==my_pop]
					}else{
					my_labels	<- NULL
					}
				popunique	<- unique(popcoord)
				if(nrow(popunique)==1)
					{
					cat(paste("Only 1 geographical position found for",my_pop,"population. Skipping.", sep=" "),sep="\n")
					}else{
					mapqmatrix(coord=popcoord,qmatrix=popqmatrix,aligncolours=FALSE,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mylabels=my_labels,mytitle=my_title,mytitle2=my_title2)
					}
				}
			}
		}
	}
	
mapqmatrix<-function(coord=NULL,qmatrix=NULL,popnames=mysambar$populations,mycols=mysambar$mycolours,radius_ratio=30,doinstall=FALSE,aligncolours=TRUE,export=NULL,exportname="qmatrix.map",mylabels=NULL,mytitle=NULL,mytitle2=NULL,silent=TRUE)
	{
	# radius_ratio is the ratio between radius and either longitude or latitude span (the smaller of the two)
	# e.g: if longitude ranges from 10 to 20, and radius_ratio is set to 40, the radius of the piecharts will equal 10/40 = 0.25. 
	if(is.null(coord))
		{
		return(cat("ERROR: you should input a matrix with geographical coordinates (i.e. longitude and latitude) of your samples to coord flag",sep="\n"))
		}
	if(is.null(qmatrix))
		{
		return(cat("ERROR: you should input a qmatrix to qmatrix flag.",sep="\n"))
		}
	if(doinstall)
		{
		myrepos='http://cran.us.r-project.org'
		# add.pie function is part of package mapplots:
		install.packages("mapplots",repos='http://cran.us.r-project.org')
		library(mapplots)
		# geographical map from rworldmap:
		if("rworldmap" %in% rownames(installed.packages()) == FALSE)	{install.packages("rworldmap",repos=myrepos)}
		if("rworldmap" %in% (.packages()) == FALSE) 					{library(rworldmap)}
		}
	npops		<- length(popnames)
	nclusters	<- ncol(qmatrix)
	ncolours	<- ifelse(nclusters>npops,nclusters,npops)
	# attempt to get colours aligned with population colours:
	if(aligncolours&npops>1&nclusters<=npops)
		{
		mycols			<- mycols[1:ncolours]
		popcoord		<- data.frame(pop=popnames,col=mycols,long=NA,lat=NA)
		for(mypop in popnames)
			{
			popcoord$long[popcoord$pop==mypop]	<- mean(inds$longitude[inds$pop==mypop&inds$filter])
			popcoord$lat[popcoord$pop==mypop]	<- mean(inds$latitude[inds$pop==mypop&inds$filter])
			}
		myqdf				<- as.data.frame(qmatrix)
		myqdf$max			<- apply(qmatrix,1,which.max)	
		myqdf$colour		<- NA
		mycolours			<- vector()
		for(i in c(1:ncol(qmatrix)))
			{
			mylong			<- mean(coord$longitude[myqdf$max==i])
			mylat			<- mean(coord$latitude[myqdf$max==i])
			mycol			<- as.vector(popcoord$col[which.min(abs(mylong-popcoord$long)+abs(mylat-popcoord$lat))])
			myqdf$colour[myqdf$max==i]	<- mycol
			mycolours[i]	<- mycol
			}
		if(any(duplicated(mycolours)))
			{
			cat("No clear agreement between geographic locations of predefined populations and those of the inferred clusters.",sep="\n")
			cat("Defaulting to random colour assignment.",sep="\n")
			mycolours			<- mycols[1:ncolours]
			}
		}else{
		mycolours				<- mycols[1:ncolours]
		}
	# plot:
	newmap 		<- getMap(resolution = "low")
	myratio		<- (max(coord$longitude)-min(coord$longitude))/max((coord$latitude)-min(coord$latitude))
	if(!is.null(export))
		{
		if(myratio<1)
			{
			if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=8/myratio,width=6)}
			}else{
			if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=8,width=6*myratio)}
			}
		if(!silent){cat(paste("Writing pdf file called:", exportname,sep=" "),sep="\n")}
		}
	#testcoord	<<- coord
	plot(coord,xlab="",ylab="",type="n",las=1)
	plot(newmap,add=T,col="grey90",border="grey")
	box()
	longrange	<- max(coord$longitude)-min(coord$longitude)
	latrange	<- max(coord$latitude)-min(coord$latitude)
	if(latrange<longrange)
		{
		myradius	<- latrange/radius_ratio
		}else{
		myradius	<- longrange/radius_ratio
		}
	for (i in 1:nrow(qmatrix))
		{
		add.pie(z=qmatrix[i,],x=coord[i,1],y=coord[i,2],labels="",radius=myradius,col=mycolours)
		}
	if(!is.null(mylabels))
		{
		text(mylabels,x=coord[,1],y=coord[,2],cex=1,col="white")
		}
	mtext("Longitude",side=1,line=2.75,cex=1.5)
	mtext("Latitude",side=2,line=2.75,cex=1.5)
	if(!is.null(mytitle)){mtext(mytitle,side=3,line=0,cex=1.5)}
	if(!is.null(mytitle2)){mtext(mytitle2,side=3,line=1.25,cex=1.5)}
	if(!is.null(export))
		{
		dev.off()
		if(!silent){cat("Closed pdf file.",sep="\n")}
		}
	}	

plotlocations<-function(export=NULL,exportname="sample_locations",mytitle=NULL,mytitle2=NULL,silent=TRUE,margin=0.1,addaxislabels=FALSE)
	{
	coord		<- inds[inds$filter,c("longitude","latitude")]
	mycols		<- inds$popcol[inds$filter]
	newmap 		<- getMap(resolution = "low")
	myratio		<- (max(coord$longitude)-min(coord$longitude))/max((coord$latitude)-min(coord$latitude))
	if(!is.null(export))
		{
		plotname<-ifelse(addaxislabels,paste(exportname,"withaxes",sep="."),paste(exportname,"no_axes",sep="."))
		if(myratio<1)
			{
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=8/myratio,width=6)}
			}else{
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=8,width=6*myratio)}
			}
		if(!silent){cat(paste("Writing pdf file called:", exportname,sep=" "),sep="\n")}
		}
	if(addaxislabels)
		{
		par(cex.axis=1.5)
		plot(coord,xlab="",ylab="",type="n",las=1)
		}else{
		plot(coord,xlab="",ylab="",type="n",las=1,xaxt='n',yaxt='n')
		}
	plot(newmap,add=T,col="grey70",border="white")
	points(coord,col=mycols,cex=5,pch=19)
	box(col="grey70")
	if(addaxislabels)
		{
		mtext("Longitude",side=1,line=2.75,cex=2)
		mtext("Latitude",side=2,line=2.75,cex=2)
		}
	if(!is.null(mytitle)){mtext(mytitle,side=3,line=0,cex=1.5)}
	if(!is.null(mytitle2)){mtext(mytitle2,side=3,line=1.25,cex=1.5)}
	if(!is.null(export))
		{
		dev.off()
		if(!silent){cat("Closed pdf file.",sep="\n")}
		}
	}		
	
	
multi_mantel_plot<-function(popnames=mysambar$populations,doexport=FALSE)
	{
	if("tajdlist_meta" %in% names(mysambar))
		{
		calcpi(pi_per_pop=FALSE)
		}
	# between all populations:
	mantel_plot(pi_df=mysambar$tajdlist_meta[[1]],export=doexport,exportname="Mantel.meta.withlegend",addlegend=TRUE)
	mantel_plot(pi_df=mysambar$tajdlist_meta[[1]],export=doexport,exportname="Mantel.meta",addlegend=FALSE)
	# within each population:
	nrpops	<- length(popnames)
	if(nrpops>1)
		{
		if("tajdlist_pop" %in% names(mysambar))
			{
			calcpi(pi_per_pop=TRUE)
			}
		for(mypopname in popnames)
			{
			mypopdf		<- mysambar$tajdlist_pop[[which(names(mysambar$tajdlist_pop)==mypopname)]]
			export_name	<- paste("Mantel",mypopname,"within",sep=".")
			mantel_plot(pi_df=mypopdf,export=doexport,exportname=export_name,addlegend=FALSE)
			}
		}
	}

# 22_05_2019: depends on output of calcpi (flag 'perpop' can be false I think) 	
seqdivplot<-function(popnames=mysambar$populations,nsites=NULL,export=FALSE)
	{
	if(!("tajdlist_meta" %in% names(mysambar)))
		{
		calcpi(pi_per_pop=FALSE)
		}
	pi_df			<- mysambar$tajdlist_meta[[1]]
	pi_df$nsegsites	<- NA
	nsnps				<- nrow(snps)
	npops				<- length(popnames)
	mycols				<- mysambar$mycolours[1:npops]
	combipoptable		<- combn(popnames,m=2)
	combicoltable		<- combn(mycols,m=2)
	combicolvector		<- vector()
	combipopvector		<- vector()
	npairwise			<- ncol(combicoltable)
	ntotal				<- npops+npairwise
	for(i in c(1:npairwise))
		{
		mycol1				<- combicoltable[1,i]
		mycol2				<- combicoltable[2,i]
		mycolfunc3 			<- colorRampPalette(c(mycol1,mycol2))
		combicolvector[i]	<- mycolfunc3(3)[2]
		combipopvector[i]	<- ifelse(combipoptable[1,i]<combipoptable[2,i],paste(combipoptable[1,i],combipoptable[2,i],sep="_"),paste(combipoptable[2,i],combipoptable[1,i],sep="_"))
		}
	for(i in c(1:nrow(pi_df)))
		{
		mypop1				<- pi_df$pop1[i]
		mypop2				<- pi_df$pop2[i]
		mymaf1				<- snps[,paste("maf",mypop1,sep="_")]
		mymaf2				<- snps[,paste("maf",mypop2,sep="_")]
		pi_df$comparison[i]<-ifelse(pi_df$pop1[i]==pi_df$pop2[i],pi_df$pop1[i],ifelse(pi_df$pop1[i]<pi_df$pop2[i],paste(pi_df$pop1[i],pi_df$pop2[i],sep="\n"),paste(pi_df$pop2[i],pi_df$pop1[i],sep="\n")))
		pi_df$comparison2[i]<-ifelse(mypop1==mypop2,"within","between")
		pi_df$nsegsites[i]	<- length(mymaf1[mymaf1>0|mymaf2>0])
		}
	# plot:
	if(!is.null(nsites))
		{
		if(!is.null(nsites))
			{
			if(length(nsites)>1)
				{
				cat("Length of vector input to nsites flag is greater than 1. This suggests that SNP datasets are derived from different genomic regions.",sep="\n")
				return(cat("Therefore, SambaR will not calculate genome wide sequence divergence.",sep="\n"))
				}
			}
		#pi_df$genomepi	<- pi_df$ndiffpersite*nsnps/nsites*100
		pi_df$genomepi	<- pi_df$ndiffpersite*pi_df$nsegsites/nsites*100
		if(export){pdf("Divergence.betweensamples.genomewide.pdf",width=ntotal*1,height=7.5)}
		layout(matrix(c(rep(1,npops),(rep(2,npairwise))),nrow=1,ncol=ntotal))
		par(oma=c(10,5,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=2)
		mymin					<- min(pi_df$genomepi,na.rm=TRUE)
		mymax					<- max(pi_df$genomepi,na.rm=TRUE)
		boxplot(pi_df$genomepi[pi_df$comparison2=="within"]~pi_df$comparison[pi_df$comparison2=="within"],las=3,ylim=c(mymin,mymax),col=mycols[order(popnames)],ylab="")
		boxplot(pi_df$genomepi[pi_df$comparison2=="between"]~pi_df$comparison[pi_df$comparison2=="between"],las=3,ylim=c(mymin,mymax),col=combicolvector[order(combipopvector)],yaxt='n')
		mtext(side=2,"Sequence dissimilarity (%)",line=2.5,cex=1.75,outer=TRUE,las=0)
		if(export){dev.off()}
		}else{
		if(export){pdf("Divergence.betweensamples.snpsonly.pdf",width=ntotal*1,height=7.5)}
		layout(matrix(c(rep(1,npops),(rep(2,npairwise))),nrow=1,ncol=ntotal))
		par(oma=c(10,5,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=2)
		mymin					<- min(pi_df$ndiffpersite,na.rm=TRUE)
		mymax					<- max(pi_df$ndiffpersite,na.rm=TRUE)
		boxplot(pi_df$ndiffpersite[pi_df$comparison2=="within"]~pi_df$comparison[pi_df$comparison2=="within"],las=3,ylim=c(mymin,mymax),col=mycols,ylab="")
		boxplot(pi_df$ndiffpersite[pi_df$comparison2=="between"]~pi_df$comparison[pi_df$comparison2=="between"],las=3,ylim=c(mymin,mymax),col=combicolvector,yaxt='n')
		mtext(side=2,"SNP dissimilarity",line=2.5,cex=1.75,outer=TRUE,las=0)
		if(export){dev.off()}
		}
	pi_df<<- pi_df
	}
	
mantel_plot<-function(pi_df=tajdlist_meta[[1]],export=FALSE,addlegend=TRUE,exportname="Mantel")
	{
	# extract dataset info:
	popnames			<- as.vector(unique(c(pi_df$pop1,pi_df$pop2)))
	my_inds				<- as.vector(unique(c(pi_df$ind1,pi_df$ind2)))
	npops				<- length(popnames)
	ninds				<- nrow(my_inds)
	mycols				<- mysambar$mycolours[1:npops]
	# prepare matrices:
	colour_matrix		<- pidf2matrix(pidf=pi_df,myinds=my_inds,do_colour=TRUE)
	my_cols				<- colour_matrix[lower.tri(colour_matrix)]
	pi_distmatrix	<- pidf2matrix(pidf=pi_df,myinds=my_inds)
	pi_distmatrix	<- as.dist(pi_distmatrix)
	geo_distmatrix		<- dist(inds[my_inds,c("longitude","latitude")])
	# plot:
	if(export){pdf(paste(exportname,"pdf",sep="."))}
	plot(geo_distmatrix,pi_distmatrix,pch=16,cex=0.75,col=my_cols,ylab="",xlab="")
	mtext("Geographical distance (degrees)",side=1,line=2.5,cex=2)
	mtext("Genetic distance (pi)",side=2,line=2.5,cex=2)
	if(addlegend&npops>1)
		{
		combipoptable	<- combn(popnames,m=2)
		combipopvector		<- paste(combipoptable[1,],combipoptable[2,],sep="_")	
		combicoltable		<- combn(mycols,m=2)
		combicolvector		<- vector()
		for(i in c(1:ncol(combicoltable)))
			{
			mycol1				<- combicoltable[1,i]
			mycol2				<- combicoltable[2,i]
			mycolfunc3 			<- colorRampPalette(c(mycol1,mycol2))
			combicolvector[i]	<- mycolfunc3(3)[2]
			}
		mycex	<- ifelse(ncol(combipoptable)<10,1.25,ifelse(ncol(combitable)>30,ifelse(ncol(combitable)>40,0.4,0.5),0.75))	
		legend("bottomright",legend=c(popnames,combipopvector),fill=c(mycols,combicolvector),cex=mycex,bty='n')
		}
	if(npops==1)
		{
		mtext(popnames,side=3,line=0.25,cex=2)
		}
	if(export){dev.off()}
	#mytest	<- mantel.rtest(geo_distmatrix,pi_distmatrix,nrepet = 9999)
	#abline(lm(pi_distmatrix ~ geo_distmatrix),lty=2,lwd=2)
	}
	
# If you can not install tess with install_github, you might try to install from binary.
# To do so, first download as zip from: "bcm-uga/TESS3_encho_sen"
# Note: this didn't work for me so far:
gettess<-function(myrepos='http://cran.us.r-project.org',noupdates=TRUE,mylib=NULL,mypath="C:/Users/Tatiana/Menno/Programs/TESS3r/TESS3_encho_sen-master.zip")
	{
	install.packages(mypath,repos=NULL,type="binary")
	library(tess3r)
	}
	
# Under construction:
runtess3<-function(myrepos='http://cran.us.r-project.org',mypath="C:/Users/Tatiana/Menno/Programs/Geneland/Geneland_4.0.8.zip")
	{
	# get required packages:
	# if("tess3r" %in% rownames(installed.packages()) == FALSE)		{install.packages(mypath,repos=NULL,type="binary")}
	# if("tess3r" %in% rownames(installed.packages()) == FALSE)  {install_github("bcm-uga/TESS3_encho_sen")}
	# if("rworldmap" %in% rownames(installed.packages()) == FALSE) {install.packages("rworldmap",repos=myrepos)}
	# library(tess3r)
	# library(rworldmap)
	# create TESS3 object:
	# note: input for tess2tess: first column longitude, second column latitude. If you reverse the order, you will eventually get an ERROR when plotting
	mycoord					<- as.matrix(inds[inds$filter,c("longitude","latitude")])	
	# However, in tess3 list it is reversed: first latitude, then longitude
	mytess3					<- list()
	mygeno					<- as.matrix(mygenlight)[inds$filter,c(1:100)]
	mytess3$X				<- mygeno
	mytess3$coord			<- as.matrix(inds[inds$filter,c("latitude","longitude")])	
	# run the analysis:
	tessout  				<- tess3(X = mytess3$X, coord = tesscoord,K = 1:7, ploidy = 2, openMP.core.num = 4)
	#
	# Cluster plot: the best choice for the K value is mostly (but not strictly) when the cross-validation curve exhibits a plateau or starts increasing.
	graphics.off()
	if(!is.null(export))
		{
		if(export=="pdf"){pdf("Tess.numberofclusters.pdf")}
		}
	plot(tessout, pch = 19, col = "blue",xlab = "Number of ancestral populations",ylab = "Cross-Validation score")
	if(!is.null(export)){dev.off()}
	# other plots still to be incorporated
	}

# Generate dummy longitude and latitude data, needed to run tess3r:
dummycoord<-function(new_coord=TRUE,plot_coord=TRUE,indsfilter=inds$filter,range=3)
	{
	if(new_coord)
		{
		inds$longitude	<<- NA
		inds$latitude	<<- NA
		inds$longitude[inds$pop=="Busen"]	<<- 4.9+runif(nrow(inds[inds$pop=="Busen",]))*range
		inds$longitude[inds$pop=="Barff"]	<<- 6.9+runif(nrow(inds[inds$pop=="Barff",]))*range
		inds$longitude[inds$pop=="Norway"]	<<- 8.9+runif(nrow(inds[inds$pop=="Norway",]))*range
		inds$latitude[inds$pop=="Busen"]	<<- 52.3+runif(nrow(inds[inds$pop=="Busen",]))*range
		inds$latitude[inds$pop=="Barff"]	<<- 50.3+runif(nrow(inds[inds$pop=="Barff",]))*range
		inds$latitude[inds$pop=="Norway"]	<<- 48.3+runif(nrow(inds[inds$pop=="Norway",]))*range
		}
	if(plot_coord)
		{
		plot(inds$longitude[indsfilter],inds$latitude[indsfilter])
		points(inds$longitude[inds$pop=="Busen"&indsfilter],inds$latitude[inds$pop=="Busen"&indsfilter],col="blue")
		points(inds$longitude[inds$pop=="Barff"&indsfilter],inds$latitude[inds$pop=="Barff"&indsfilter],col="green")
		points(inds$longitude[inds$pop=="Norway"&indsfilter],inds$latitude[inds$pop=="Norway"&indsfilter],col="red")
		}
	}

getgeneland<-function(myrepos='http://cran.us.r-project.org',noupdates=TRUE,mylib=NULL,mypath="C:/Users/Tatiana/Menno/Programs/Geneland/Geneland_4.0.8.zip")
	{
	if(is.null(mylib))
		{
		if("devtools" %in% rownames(installed.packages()) == FALSE)		{install.packages("devtools",repos=myrepos)}
		if("rworldmap" %in% rownames(installed.packages()) == FALSE)	{install.packages("rworldmap",repos=myrepos)}
		if("coda" %in% rownames(installed.packages()) == FALSE)			{install.packages("coda",repos=myrepos)}
		if("Geneland" %in% rownames(installed.packages()) == FALSE)		{install.packages(mypath,repos=NULL,type="binary")}
		}else{
		if("rworldmap" %in% rownames(installed.packages()) == FALSE)	{install.packages("rworldmap",repos=myrepos,lib=mylib)}
		if("coda" %in% rownames(installed.packages()) == FALSE)			{install.packages("coda",repos=myrepos,lib=mylib)}
		if("Geneland" %in% rownames(installed.packages()) == FALSE)		{install.packages(mypath,repos=NULL,type="source",lib=mylib)}
		}
	if("rworldmap" %in% (.packages()) == FALSE) 						{library(rworldmap)}
	if("coda" %in% (.packages()) == FALSE) 								{library(coda)}
	if("Geneland" %in% (.packages()) == FALSE) 							{library(Geneland)}
	library(coda)
	library(Geneland)
	newmap <<- getMap(resolution = "low")
	# I wrote a function to convert from genlight to structure format.
	# Originally, I used dartR to do this conversion. This package depends on several other packages:
	# if("directlabels" %in% rownames(installed.packages()) == FALSE)		{install.packages("directlabels",repos=myrepos)}
	# if("PopGenReport" %in% rownames(installed.packages()) == FALSE)		{install.packages("PopGenReport",repos=myrepos)}
	# if("leaflet" %in% rownames(installed.packages()) == FALSE)			{install.packages("leaflet",repos=myrepos)}
	# if("pca3d" %in% rownames(installed.packages()) == FALSE)			{install.packages("pca3d",repos=myrepos)}
	# if("rrBLUP" %in% rownames(installed.packages()) == FALSE)			{install.packages("rrBLUP",repos=myrepos)}
	# if("dartr" %in% rownames(installed.packages()) == FALSE)			{install.packages("dartr",repos=myrepos)}
	# or from binary:
	# install.packages("C:/Users/Tatiana/Menno/Programs/dartr/dartR_1.1.11.zip",repos=NULL,type="binary")
	# library(dartR)
	}

# When running Geneland, I have to subset the data because of memory allocation limits.
# You could argue to select loci with high minor allele frequencies (more informative), but I am afraid this is a biased representation of the dataset, which might affect the outcome
# So instead I sample randomly.	
# 10000 iterations for 1000 loci does not resolve population structure correctly according to my trials.
# I assigned to my Busen, Barff and Norway samples random geographical locations, clustered per population but with slight overlap
# The overlapping samples were wrongly assigned. 
# 100000 iterations with 1000 loci is not possible on my computer (memory allocation ERROR)
# 100000 iterations with 100 loci does not find the right structure (not even close)   
# 100000 iterations with 450 loci is not possible on my computer (memory allocation ERROR)
# 100000 iterations with 400 loci ... memory allocation ERROR when outputting results
# 100000 iterations with 200 loci does not resolve population structure correctly (not even closely)
# 1000 iterations with 1000 loci does not resolve population structure correctly either
# 10000 iterations with 2000 loci overclusters
# 10000 iterations with 2000 loci and correlated set to FALSE, underclusters
runandplotgeneland<-function(my_iter=10000,burnin_fraction=0.2,my_thin=100,doanalysis=TRUE,doplots=TRUE,initK=5,Kmax=8,nloci=1000,correlation=FALSE)
	{
	# mysambar$mycolours has 8 default colours, hence Kmax=8 
	if(!("latitude" %in% colnames(inds)&"longitude" %in% colnames(inds)))
		{
		return(cat("ERROR: No longitude and/or latitude column present in inds dataframe.",sep="\n"))
		}
	savediter	<- my_iter/my_thin
	myburn		<- savediter*burnin_fraction
	cat(paste("Number of iterations before thinning:",my_iter,sep=" "),sep="\n")
	cat(paste("Number of iterations after thinning:",savediter,sep=" "),sep="\n")	
	cat(paste("Burn-in (after thinning):",myburn,sep=" "),sep="\n")
	myfolder	<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	if(doanalysis)
		{
		rungeneland(myiter=my_iter,var_npop=TRUE,n_init=initK,popmax=Kmax,mythinning=my_thin,myburn=myburn,nloc=nloci,correlated=correlation)
		checkconvergence(myburnin=myburn,export="pdf")
		}
	if(doplots)
		{
		cat("Creating plots using Geneland functions...",sep="\n")
		genelandplotting(myburnin=myburn)
		cat("Creating additional plots using SambaR functions...",sep="\n")
		scattergeneland(myiter=my_iter,myburnin=myburn,gradient=FALSE,export="pdf",makeplots=TRUE)
		scattergeneland(myiter=my_iter,myburnin=myburn,gradient=TRUE,export="pdf",makeplots=TRUE)
		cat("Analysis finished.",sep="\n")
		myendtime	<- Sys.time()
		exportname	<- paste(myfolder,"endtime.txt",sep="")
		write.table(myendtime,exportname,quote=FALSE,col.names=FALSE)
		}
	}	

rungeneland<-function(myiter=10000,var_npop=TRUE,n_init=5,popmax=8,mythinning=100,myburnin=2,nloc=1000,correlated=FALSE)
	{
	# since we filter on maf, we can be sure that all loci have 2 alleles per loci, and so 2 columns per locus once we converted from genlight to structure.
	nind					<- nrow(inds[inds$filter,])
	genlight2structure(snpsfilter=snps$filter,indsfilter=inds$filter)
	geno					<- mysambar$mystructure[,c(3:ncol(mysambar$mystructure))]
	# subsample:
	#mysample				<- sample(c(1:(ncol(geno)-1)),nloc,replace=FALSE)
	#mysample2				<- c(mysample,(mysample+1))
	#mysample				<- mysample2[order(mysample2)]
	geno					<- geno[,c(1:(nloc*2))]
	coord					<- inds[inds$filter,c("longitude","latitude")]
	myfolder				<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	dir.create(myfolder)
	cat("Running MCMC analyses...",sep="\n")
	myfreqmodel				<- ifelse(correlated,"Correlated","Uncorrelated")
	MCMC(coordinates=coord,delta.coord=0,geno.dip.codom=geno,varnpop=var_npop,npopinit=n_init,spatial=TRUE,freq.model=myfreqmodel,nit=myiter,thinning=mythinning,rate.max=nind,npopmax=popmax,nb.nuclei.max=3*nind,path.mcmc=myfolder)
	PostProcessChain(coordinates=coord,path.mcmc=myfolder,nxdom=100,nydom=100,burnin=myburnin)
	}
		
# as of 26_03_2019 depreciated:	
rungeneland_old<-function(myiter=10000,var_npop=TRUE,n_init=6,popmax=10,mythinning=100,myburnin=2)
	{
	nind					<- nrow(inds[inds$filter,])
	cat("Converting from genlight to structure format...",sep="\n")
	# since we filter on maf, we can be sure that all loci have 2 alleles per loci.
	mymatrix				<- as.matrix(mygenlight[inds$filter,snps$filter])
	#mymatrix				<- mymatrix[,c(1:1000)]
	nloci					<- ncol(mymatrix)
	tempgl					<- as.genlight(mymatrix)
	mycoorddf				<- as.matrix(cbind(inds$latitude[1:ninds],inds$longitude[1:ninds]))
	colnames(mycoorddf)		<- c("lat","lon")
	tempgl$other$latlong	<- mycoorddf
	gl2structure(tempgl,outfile="mydata.stru",outpath=mysambar$inputfilesdir,v=0)
	mystructure				<- read.structure("mydata.stru",n.ind=nind,n.loc=nloci,onerowperind=FALSE,col.lab=0,col.pop=0,col.others=2,row.marknames=1)
	geno					<- as.matrix(mystructure)
	coord					<- inds[inds$filter,c("longitude","latitude")]
	myfolder				<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	dir.create(myfolder)
	cat("Running MCMC analyses...",sep="\n")
	MCMC(coordinates=coord,delta.coord=0,geno.dip.codom=geno,varnpop=var_npop,npopinit=n_init,spatial=TRUE,freq.model="Correlated",nit=myiter,thinning=mythinning,rate.max=nind,npopmax=popmax,nb.nuclei.max=3*nind,path.mcmc=myfolder)
	PostProcessChain(coordinates=coord,path.mcmc=myfolder,nxdom=100,nydom=100,burnin=myburnin)
	}

checkconvergence<-function(myburnin=2,export=NULL)
	{
	myfolder		<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	conver			<- read.table(paste(myfolder,"log.posterior.density.txt",sep=""),header=FALSE)
	colnames(conver)<-"posterior"
	conver$nr		<-c(1:nrow(conver))
	# plot myway:
	# plot(conver$nr,conver$posterior,type='l',ylab="Log posterior density",xlab="Iteration (x 1000)")
	# abline(v=myburnin,lty=2)
	# plot with coda:
	mychain			<- conver$posterior[c(myburnin:nrow(conver))]
	myconver		<- as.mcmc.list(lapply(as.data.frame(mychain), mcmc))	# convert to mcmc object
	if(!is.null(export))
		{
		exportname	<- paste(myfolder,"Traceplot.pdf",sep="")
		if(export=="pdf"){pdf(exportname)}
		}
	plot(myconver)
	if(!is.null(export)){dev.off()}
	# test:
	mydf			<- as.data.frame(matrix(nrow=4,ncol=4))
	colnames(mydf)	<- c("frac1","frac2","Z","p")
	mydf$frac1		<- c(0.1,0.2,0.3,0.5)
	mydf$frac2		<- c(0.5,0.6,0.7,0.1)
	for(i in c(1:4))
		{
		myfrac1			<- mydf$frac1[i]
		myfrac2			<- mydf$frac2[i]	
		gewekeout		<- geweke.diag(myconver,frac1=myfrac1,frac2=myfrac2)
		myzvalue		<- gewekeout$mychain[[1]]
		mypvalue 		<- pnorm(-abs(myzvalue))
		mydf$Z[i]		<- myzvalue
		mydf$p[i]		<- mypvalue
		}
	exportname	<- paste(myfolder,"Geweke.diag.output.txt",sep="")
	write.table(mydf,exportname,quote=FALSE,col.names=FALSE,row.names=TRUE)
	# if you have done multiple runs, you can use gelman diagnostics (which compares chains of each run)
	# gelmanout		<- gelman.diag(myconver,confidence = 0.95,transform=FALSE,autoburnin=TRUE,multivariate=TRUE)
	}

genelandplotting<-function(myburnin=2)
	{
	coord		<- inds[inds$filter,c("longitude","latitude")]
	myfolder	<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	setwd(myfolder)
	# Geneland built in plotting functions:
	# Plot number of clusters:
	Plotnpop(path.mcmc=myfolder,burnin=myburnin,printit=TRUE,file="Number_of_Clusters.pdf",format="pdf")
	# Map clusters geographically:
	PosteriorMode(coordinates=coord,path.mcmc=myfolder,printit=TRUE,file="Genelandmap.pdf",format="pdf") 
	PlotTessellation(coordinates=coord,path.mcmc=myfolder,printit=TRUE,path=myfolder)
	graphics.off()
	}	

scattergeneland<-function(myiter=1000,myburnin=2,gradient=TRUE,export=NULL,makeplots=TRUE,mapresolution="low")
	{
	myfolder	<- paste(mysambar$structure,"Genelandoutput/",sep="/")
	newmap 		<- getMap(resolution = mapresolution)
	sampledata	<- read.table(paste(myfolder,"proba.pop.membership.indiv.txt",sep=""),header=FALSE)
	nK			<- ncol(sampledata)-2
	colnames(sampledata)<-c("longitude","latitude",(paste("c",c(1:nK),sep="")))
	nbins		<- length(table(sampledata$c1,sampledata$c2))
	nsamples	<- nrow(sampledata)
	myxlim		<- c(min(sampledata$longitude),max(sampledata$longitude))
	myylim		<- c(min(sampledata$latitude),max(sampledata$latitude))
	myratio		<- (max(sampledata$longitude)-min(sampledata$longitude))/max((sampledata$latitude)-min(sampledata$latitude))
	# set mapping colours:
	sampledata$col	<- NA
	for(i in c(1:nsamples))
		{
		sampledata$col[i]	<- rgb(sampledata$c1[i],sampledata$c2[i],sampledata$c3[i])
		}
	# How many clusters identified?
	temp		<- sampledata[,c(3:9)]	
	temp2		<- sapply(temp,sum)
	nclusters	<- length(temp2[temp2>0])
	# col2 is generated kind of the same, but allowing for more colours (although difference between the other colours not very clear:)
	sampledata$col2	<- NA
	sampledata$col3	<- NA
	sampledata$blend<- NA
	colourvector	<- mysambar$mycolours
	for(i in c(1:nsamples))
		{
		myrow				<- sampledata[i,c(3:9)]
		mymax1				<- order(myrow)[length(myrow)]
		mysecond1			<- order(myrow)[length(myrow)-1]
		mymax2				<- as.vector(unlist(myrow[mymax1]))
		mysecond2			<- as.vector(unlist(myrow[mysecond1]))
		mycol1				<- colourvector[mymax1]
		mycol2				<- colourvector[mysecond1]
		#mycolfunc1 		<- colorRampPalette(c(mycol2,mycol1))
		mycolfunc1 			<- colorRampPalette(c("black",mycol1))
		mycolramp			<- mycolfunc1(nbins)
		mybin				<- mymax2*(nbins-1)+1
		sampledata$col2[i]	<- mycolramp[mybin]
		sampledata$blend[i]	<- ifelse(mymax2==1,FALSE,TRUE)
		sampledata$col3[i]	<- mycol1
		}
	if(gradient)
		{
		mycols	<- sampledata$col2
		}else{
		mycols	<- sampledata$col3	
		}
	myqmatrix2	<<- sampledata
	#
	if(makeplots)
		{
		# Plot:
		# Multitile plot:
		if(!is.null(export))
			{
			if(gradient)
				{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.multitile.gradient.scatter.pdf",sep=".")
				}else{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.multitile.scatter.pdf",sep=".")
				}
			exportname2	<- paste(myfolder,exportname,sep="")
			if(nclusters==2){pdf(exportname2,height=6,width=6*2*myratio)}
			if(nclusters==3){pdf(exportname2,height=6,width=6*3*myratio)}
			if(nclusters==4){pdf(exportname2,height=12,width=6*2*myratio)}
			if(nclusters==5){pdf(exportname2,height=12,width=6*3*myratio)}
			if(nclusters==6){pdf(exportname2,height=12,width=6*3*myratio)}
			if(nclusters==7){pdf(exportname2,height=12,width=6*4*myratio)}
			if(nclusters==8){pdf(exportname2,height=12,width=6*4*myratio)}
			}
		if(nclusters==2){layout(matrix(c(1:2),1,2,byrow = TRUE))}
		if(nclusters==3){layout(matrix(c(1:3),1,3,byrow = TRUE))}
		if(nclusters==4){layout(matrix(c(1:4),2,2,byrow = TRUE))}
		if(nclusters==5){layout(matrix(c(1:5),2,3,byrow = TRUE))}
		if(nclusters==6){layout(matrix(c(1:6),2,3,byrow = TRUE))}
		if(nclusters==7){layout(matrix(c(1:7),2,4,byrow = TRUE))}
		if(nclusters==8){layout(matrix(c(1:8),2,4,byrow = TRUE))}
		par(mar=c(1.5,1.5,1,1),oma=c(3,3,1.5,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
		for(i in c(1:nclusters))	
			{
			mycluster	<- sampledata[,i+2]
			select		<- mycluster>0.5
			plot(sampledata$longitude[select],sampledata$latitude[select],col=mycols[select],pch=16,cex=1.5,ylim=myylim,xlim=myxlim)
			plot(newmap,add=T,col="grey90",border="grey")
			points(sampledata$longitude[select],sampledata$latitude[select],col=mycols[select],pch=16,cex=1.5)
			box()
			}
		mtext(text="Latitude",cex=2,side=2,line=1,outer=TRUE)
		mtext(text="Longitude",cex=2,side=1,line=1.5,outer=TRUE)
		if(!is.null(export)){dev.off()}
		#
		# Singletile plot:
		if(!is.null(export))
			{
			if(gradient)
				{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.singletile.gradient.scatter.pdf",sep=".")
				}else{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.singletile.scatter.pdf",sep=".")
				}
			exportname2	<- paste(myfolder,exportname,sep="/")
			pdf(exportname2,height=6,width=6*myratio)
			}
		par(mar=c(0.5,0.5,0.5,0.5),oma=c(1,1,1,1),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		plot(newmap, xlim=myxlim, ylim=myylim,col="grey85",border="grey")
		points(sampledata$longitude,sampledata$latitude,pch=16,cex=1.5,col=mycols)
		if(!is.null(export)){dev.off()}
		}
	# export results as qmatrix
	myqmatrix3            		<- cbind(inds$name[inds$filter],inds$longitude[inds$filter],inds$latitude[inds$filter],myqmatrix2)
	colnames(myqmatrix3)[1:3]	<- c("name","longitude","latitude") 
	write.table(myqmatrix3,paste(myfolder,"myqmatrix.txt",sep=""),quote=FALSE,col.names=TRUE,row.names=TRUE)
	}

	
# End of population structure analyses 
###############################################################################################################





###############################################################################################################
# Population differentiation analyses

# This function executes all genetic distance analyses at once:
calcdistance<-function(silent=TRUE)
	{
	if(length(mysambar$populations)==1)
		{
		return(cat("At present only 1 population defined. No need to calculate genetic distance between populations. Execution halted.",sep="\n"))
		}
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
	setwd(mysambar$divergencedir)
	# Execute analyses:
	# myamova()
	cat("Calculating Nei's genetic distance...",sep="\n")
	pop_neimatrix(export="eps")
	pop_neimatrix(export="pdf")
	pop_neimatrix(export="png")
	pop_neimatrix(export="wmf")
	cat("Calculating Pearson's correlation coefficient...",sep="\n")
	mafcorr(export="eps")
	mafcorr(export="pdf")
	mafcorr(export="png")
	mafcorr(export="wmf")
	cat("Calculating pairwise Wright Fst...",sep="\n")
	locusWrightFst()
	cat("Calculating pairwise Weir & Cockerham Fst...",sep="\n")
	run_locusWCfst(export="pdf")	# histogram, depends on locusWCfst	
	run_locusWCfst(export="wmf")
	if(!silent){cat("Fdist_multiplot",sep="\n")}
	Fdist_multiplot(export="eps")	# He-Fst scatterplot, depends on Fdist_plot
	Fdist_multiplot(export="pdf")
	Fdist_multiplot(export="png")
	Fdist_multiplot(export="wmf")
	cat("Calculating pairwise Weir & Cockerham 1983 multilocus Fst...",sep="\n")
	multiLocusWeirFst(export="eps")
	multiLocusWeirFst(export="pdf")
	multiLocusWeirFst(export="png")
	multiLocusWeirFst(export="wmf")
	cat("Outputting summary table...",sep="\n")
	mypopdivergencetable()
	cat("Analysis finished.",sep="\n")
	setwd(mysambar$inputdatadir)
	}

# AMOVA
# Depends on package StamPP'
myamova<-function(permutations=10)
	{
	nei 			<- stamppNeisD(mygenlight[inds$filter,snps$filter],pop=FALSE)
	amovaresults	<- stamppAmova(nei,mygenlight[inds$filter,snps$filter],perm=permutations)	
	return(amovaresults)
	}

mafsd<-function(popnames=mysambar$populations)
	{
	npops				<- length(popnames)
	if(npops>1)
		{
		popmafs 			<- snps[,grep("maf_",colnames(snps))]
		snps$sd_popmaf		<<- apply(popmafs,1,function(x) sd(x))
		}else{
		snps$sd_popmaf		<<- NA
		}
	}
	
# Correlation between allele frequencies:
mafcorr	<- function(popnames=mysambar$populations,export=NULL)
	{
	if(length(popnames)==1)
		{
		return(cat("At present only 1 population defined. No need to calculate Nei's genetic distance. Execution halted."))
		}
	npops			<- length(popnames)
	combitable		<- combn(popnames,m=2)
	pearsonvector	<- vector()
	for(i in 1:ncol(combitable))
		{
		pop1	<- combitable[1,i]
		pop2	<- combitable[2,i]
		#cat(paste(pop1,pop2,sep="_"),sep="\n")
		if(paste("maf",pop1,sep="_")%in%colnames(snps))
			{
			maf1	<- as.vector(snps[,paste("maf",pop1,sep="_")])
			}else{
			return(cat(paste("No maf vector present for ",pop1,".",sep=""),sep="\n"))
			}
		if(paste("maf",pop2,sep="_")%in%colnames(snps))
			{
			maf2	<- as.vector(snps[,paste("maf",pop2,sep="_")])
			}else{
			return(cat(paste("No maf vector present for ",pop2,".",sep=""),sep="\n"))
			}
		missfilter			<- !(is.na(maf1)|is.na(maf2))
		pearsonvector[i]	<- round(cor(maf1[missfilter],maf2[missfilter],method="pearson"),2)
		}
	m2					<- matrix(NA,nrow=npops,ncol=npops)
	m2[lower.tri(m2, diag=FALSE)] <- pearsonvector
	mymatrix 			<- t(m2)
	rownames(mymatrix)	<- popnames
	colnames(mymatrix)	<- popnames
	mymatrix[lower.tri(mymatrix, diag=TRUE)] <-	0
	mymatrix	<<- mymatrix
	#
	# plot:
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(mymatrix,na.rm=TRUE),1)
	mymax		<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
	myBreaks	<- seq(mymin,mymax,(mymax-mymin)/5)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	graphics.off()
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript("Mafcorr.pop.eps",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf("Mafcorr.pop.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png("Mafcorr.pop.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile("Mafcorr.pop.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(mymatrix==0,NA,mymatrix),
	notecol="black",notecex=2.5,labCol=popnames,labRow=popnames,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	#mtext("population", side = 1, cex = 2, line = 3.5)
	#mtext("population", side = 4, cex = 2, line = 0.5)
	mtext("Pearson's correlation coefficient", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	popneivector	<<- mymatrix[upper.tri(mymatrix)]
	}
	
# Nei's genetic distance
pop_neimatrix<-function(popnames=mysambar$populations,export=NULL)
	{
	npops		<- length(popnames)
	if(length(popnames)==1)
		{
		return(cat("At present only 1 population defined. No need to calculate Nei's genetic distance. Execution halted."))
		}
	mymatrix	<- stamppNeisD(mygenlight[inds$filter,snps$filter],pop=TRUE)
	colnames(mymatrix)<-rownames(mymatrix)
	mymatrix	<- mymatrix[popnames,popnames]
	mymatrix[lower.tri(mymatrix, diag=FALSE)] <-	0
	mymatrix	<- round(mymatrix,3)
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(mymatrix,na.rm=TRUE),1)
	mymax		<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
	myBreaks	<- seq(mymin,mymax,(mymax-mymin)/5)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	graphics.off()
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript("Neimatrix.pop.eps",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf("Neimatrix.pop.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png("Neimatrix.pop.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile("Neimatrix.pop.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(mymatrix==0,NA,mymatrix),
	notecol="black",notecex=2.5,labCol=popnames,labRow=popnames,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	#mtext("population", side = 1, cex = 2, line = 3.5)
	#mtext("population", side = 4, cex = 2, line = 0.5)
	mtext("Nei's genetic distance", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	popneivector	<<- mymatrix[upper.tri(mymatrix)]
	}

# Wright_Fst
locusWrightFst<-function(popnames=mysambar$populations,histo=FALSE,export=NULL)
	{
	combitable		<- combn(popnames,m=2)
	# Prepare plot:
	graphics.off()
	if(histo)
		{
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Wright_Fst.eps",family=mysambar$myfont,width=10,height=7)}
			if(export=="pdf"){pdf("Wright_Fst.pdf",family=mysambar$myfont,width=10,height=7)}
			if(export=="png"){png("Wright_Fst.png",family=mysambar$myfont,width=1000,height=720)}
			if(export=="wmf"){win.metafile("Wright_Fst.wmf",family=mysambar$myfont,width=10,height=7)}
			}
		par(mfrow=c(1,ncol(combitable)),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		}
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		maf2pops		<- glMean(mygenlight[inds$filter&inds$pop2==combitable[1,i]|inds$pop2==combitable[2,i],])		
		expHt			<- 2*maf2pops*(1-maf2pops)
		mafpop1			<- snps[names(snps) == paste("maf",combitable[1,i],sep="_")]
		mafpop2			<- snps[names(snps) == paste("maf",combitable[2,i],sep="_")]
		expHs			<- 0.5*((2*mafpop1[,1]*(1-mafpop1[,1]))+(2*mafpop2[,1]*(1-mafpop2[,1])))		# I included [,1] to avoid problems when snps-dataset contain multiple column with the same name
		snps$WrightFst	<<- (expHt-expHs)/expHt 
		# Names of both populations combined:
		combiname		<- paste(combitable[1,i],combitable[2,i],sep="_")
		# Plot:
		if(histo)
			{
			hist(snps$WrightFst[snps$filter],50,main=combiname,xlab="Wright Fst")
			}
		# Change name of column in snps dataset:
		names(snps)[names(snps) == "WrightFst"] <<- paste("WrightFst",combiname,sep = "_")			
		}
	if(histo)
		{
		if(!is.null(export)){dev.off()}
		}
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

# Weir and Cockerham Fst: 	
locusWCfst<-function(my_dataset="Busen_Norway",mycol="grey",do_plot=TRUE)
	{
	if(my_dataset=="pheno")
		{
		pop_1		<- "pheno1" 
		pop_2		<- "pheno2"
		}else{
		pop_1		<- unlist(strsplit(my_dataset, split="_"))[1]
		pop_2		<- unlist(strsplit(my_dataset, split="_"))[2]
		}
	mafpop1			<- snps[names(snps) == paste("maf",pop_1,sep="_")]	
	mafpop2			<- snps[names(snps) == paste("maf",pop_2,sep="_")]
	# I included [,1] to avoid problems when snps dataset contain multiple columns with the same name.
	pop1f0			<- (mafpop1[,1]*mafpop1[,1])+((1-mafpop1[,1])*(1-mafpop1[,1]))
	pop2f0			<- (mafpop2[,1]*mafpop2[,1])+((1-mafpop2[,1])*(1-mafpop2[,1]))
	f1				<- (mafpop1[,1]*mafpop2[,1])+((1-mafpop1[,1])*(1-mafpop2[,1]))	
	snps$WeirHe		<<- 1-f1 
	snps$WeirFst	<<- (0.5*(pop1f0+pop2f0)-f1)/snps$WeirHe
	my_dataset2		<- paste(pop_1,pop_2,sep="\n")
	# Plot:
	if(do_plot)
		{
		hist(snps$WeirFst[snps$filter],50,main=my_dataset2,col=mycol,xlim=c(0,1),breaks=seq(0,1,0.02),ylim=c(0,(nrow(snps[snps$filter,])/6)),xlab="")
		}
	# Change names of columns in snps dataset:
	names(snps)[names(snps) == "WeirHe"] <<- paste("WeirHe",my_dataset,sep = "_")		
	names(snps)[names(snps) == "WeirFst"] <<- paste("WeirFst",my_dataset,sep = "_")			
	# If the function has been run multiple times, duplicated columns can arise. 
	# This is not only redundant, but can also lead to ERRORs. To remove duplicated columns:
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]	
	}

# requires locusWCfst
run_locusWCfst<-function(popnames=mysambar$populations,export=NULL)
	{
	npops			<- length(mysambar$populations)
	if(npops==1)
		{
		return(cat("Currently only 1 population defined. Not possible to calculate Fst measures.",sep="\n"))
		}
	combitable		<- combn(popnames,m=2)
	ncombi			<- ncol(combitable)
	mycolours		<- as.vector(unique(inds$popcol))
	combicoltable	<- combn(mycolours,m=2)	
	npops			<- length(mysambar$populations)
	#
	# Prepare histogram plot:
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("WC_Fst.eps",family=mysambar$myfont,width=5*ncombi+2,height=7)}
		if(export=="pdf"){pdf("WC_Fst.pdf",family=mysambar$myfont,width=5*ncombi+2,height=7)}
		if(export=="png"){png("WC_Fst.png",family=mysambar$myfont,width=200*ncombi+75,height=700)}
		if(export=="wmf"){win.metafile("WC_Fst.wmf",family=mysambar$myfont,width=5*ncombi+2,height=7)}
		}
	par(mfrow=c(1,ncol(combitable)+1),mai=c(0.75,1,0.75,0.25),oma=c(1,1,2,1),cex.main=2,cex.lab=2,cex.axis=1.5)
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		mypop_1		<- combitable[1,i]
		mypop_2		<- combitable[2,i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		mypoppair	<- paste(my_pops[1],my_pops[2],sep="_")
		# cat(mypoppair,sep="\n")
		# As colour we are going to use a blend of the two population colours:
		mycol1			<- combicoltable[1,i]
		mycol2			<- combicoltable[2,i]
		mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
		mycol3			<- mycolfunc3(3)[2]
		locusWCfst(my_dataset=mypoppair,mycol=mycol3)
		mtext("WC Fst",cex=2,side=1,line=3)
		}
	#mtext("Weir & Cockerham Fst",cex=2,side=1,line=-1.5,outer=TRUE)	# not handy if user wants to subselect tiles
	#
	# WeirHe_meta:
	if(npops==2)
		{
		mypop_1		<- combitable[1,1]
		mypop_2		<- combitable[2,1]
		myhe		<- snps[,paste("WeirHe",my_pops[1],my_pops[2],sep="_")]
		snps$WeirHe_metapop			<<- myhe
		}else{
		snps2		<- snps
		if("WeirHe_pheno" %in% colnames(snps2))
			{
			snps2$WeirHe_pheno	<- NULL
			}
		if("WeirHe_metapop" %in% colnames(snps2))
			{
			snps2$WeirHe_metapop	<- NULL
			}
		snpstemp					<- snps2[,grep("WeirHe_",colnames(snps2))]
		snps$WeirHe_metapop			<<- apply(snpstemp,1,function(x){mean(x,na.rm=TRUE)})
		}
	# WeirFst_meta:
	if(npops==2)
		{
		mypop_1		<- combitable[1,1]
		mypop_2		<- combitable[2,1]
		myfst		<- snps[,paste("WeirFst",mypop_1,mypop_2,sep="_")]
		snps$WeirFst_metapop		<<- myfst
		}else{
		snps2		<- snps
		if("WeirFst_pheno" %in% colnames(snps2))
			{
			snps2$WeirFst_pheno	<-NULL
			}
		if("WeirFst_metapop" %in% colnames(snps2))
			{
			snps2$WeirFst_metapop<-NULL
			}
		snpstemp	<- snps2[,grep("WeirFst_",colnames(snps2))]
		snps$WeirFst_metapop		<<- apply(snpstemp,1,function(x){mean(x,na.rm=TRUE)})
		}
	hist(snps$WeirFst_metapop[snps$filter],50,main="metapop",col="white",xlim=c(0,1),breaks=seq(0,1,0.02),ylim=c(0,(nrow(snps[snps$filter,])/6)),xlab="")
	mtext("WC Fst",cex=2,side=1,line=3)
	if(!is.null(export)){dev.off()}
	# If the function has been run multiple times, duplicated columns can arise. 
	# This is not only redundant, but can also lead to ERRORs. To remove duplicated columns:
	snps 		<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}	
	
Fdist_plot<-function(my_dataset="Busen_Norway",showlegend=FALSE,showlabels=TRUE,exporttype=NULL,axislabels=TRUE,add_borders=FALSE,add_outliers=FALSE,y_axis='s',x_axis='s',my_labels=NULL,dothin=TRUE,silent=TRUE)
	{
	#cat(my_dataset,sep="\n")
	WeirHe		<- snps[,names(snps) == paste("WeirHe",my_dataset,sep="_")]
	WeirFst		<- snps[,names(snps) == paste("WeirFst",my_dataset,sep="_")]
	nsnps		<- nrow(snps[snps$filter,])
	mycex		<- ifelse(nsnps>10000,0.5,ifelse(nsnps>5000,1,1.25))
	if(dothin)
		{
		# This is to make plot lighter: no need to plot overlapping points.
		mydf		<- as.data.frame(cbind(WeirHe,WeirFst))
		mydf		<- unique(mydf[snps$filter2,])
		WeirHe2		<- mydf$WeirHe
		WeirFst2	<- mydf$WeirFst
		}
	if(!is.null(exporttype))
		{
		myplotlabels<- ifelse(is.null(my_labels),my_dataset,paste(my_labels[1],my_labels[2],sep="_"))
		plotname	<- ifelse(add_outliers,paste("WC_Fst.outliers",myplotlabels,sep="."),paste("WC_Fst",myplotlabels,sep="."))
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=7,height=7)}
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=7,height=7)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=700,height=700)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=7,height=7)}
		}
	plot(WeirHe2,WeirFst2,main="",xlim=c(0,1),ylim=c(0,1),pch=16,cex=mycex,xlab="",ylab="",yaxt=y_axis,xaxt=x_axis,las=1)
	if(add_borders)
		{
		# Boundaries of He-Fst space:
		wche				<- seq(0,1,0.01)
		wcfst1				<- (2*wche-1)/wche
		wcfst1[wcfst1<0]	<- NA
		wcfst2				<- wche
		points(wche,wcfst1,type='l',col="grey")
		points(wche,wcfst2,type='l',col="grey")
		points(WeirHe2,WeirFst2,pch=16,cex=mycex)
		if(!showlegend&my_dataset!="pheno") 
			{
			text(x=0.4,y=0.5,"Left border:\nMAFpop1 = 0\n| MAFpop2 = 0",adj=1,cex=2)
			text(x=0.6,y=0.2,"Right border:\nMAFpop1 =\n1 - MAFpop2",adj=0,cex=2)
			}
		}
	if(add_outliers)
		{
		snpcolnames		<- colnames(snps)
		if(!silent){cat("OutFLANK",sep="\n")}
		mycolumn		<- paste("OutFLANK",my_dataset,sep="_")
		add_outflankout	<- mycolumn%in%snpcolnames
		if(add_outflankout)	
			{
			outlierfilter	<- snps[,names(snps) == paste("OutFLANK",my_dataset,sep="_")]
			points(WeirHe[outlierfilter],WeirFst[outlierfilter],col="orange",pch=15,cex=1.5)
			}
		if(!silent){cat("Bayescan",sep="\n")}
		mycolumn		<- paste("bayescanout",my_dataset,sep="_")
		addbayescanout	<- mycolumn%in%snpcolnames
		if(addbayescanout)	
			{
			outlierfilter	<- snps[,names(snps) == paste("bayescanout",my_dataset,sep="_")]
			points(WeirHe[outlierfilter],WeirFst[outlierfilter],col="red",pch=17,cex=1.5)
			}
		if(!silent){cat("Fsthet",sep="\n")}
		mycolumn		<- paste("fsthetout",my_dataset,sep="_")
		addfsthetout	<- mycolumn%in%snpcolnames
		if(addfsthetout)	
			{
			outlierfilter	<- snps[,names(snps) == paste("fsthetout",my_dataset,sep="_")]
			points(WeirHe[outlierfilter],WeirFst[outlierfilter],col="darkorchid4",pch=20,cex=1.5)
			}
		if(!silent){cat("GWDS",sep="\n")}
		mycolumn		<- paste("rfisherout",my_dataset,sep="_")
		addgwds			<- mycolumn%in%snpcolnames
		if(addgwds)	
			{
			outlierfilter	<- snps[,names(snps) == paste("rfisherout",my_dataset,sep="_")]
			points(WeirHe[outlierfilter],WeirFst[outlierfilter],col="blue",pch=16,cex=1.5)
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with fisher test logp values for population pair ",my_dataset,".",sep=""),sep="\n")
			}
		if(!silent){cat("pcadapt",sep="\n")}
		mycolumn		<- paste("PCadaptout",my_dataset,sep="_")
		addpcadapt		<- mycolumn%in%snpcolnames
		if(addpcadapt)		
			{
			outlierfilter	<- snps[,names(snps) == paste("PCadaptout",my_dataset,sep="_")]
			points(WeirHe[outlierfilter],WeirFst[outlierfilter],col="darkgreen",pch=18,cex=1.5)
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with PCadapt logp values for population pair ",my_dataset,".",sep=""),sep="\n")
			}
		}
	if(my_dataset=="pheno"|showlegend)
		{
		mylegend1	<- ifelse(addbayescanout,"Bayescan","nolegend")
		mylegend2	<- ifelse(addfsthetout,"Fsthet","nolegend")
		mylegend3	<- ifelse(addgwds,"GWDS","nolegend")
		mylegend4	<- ifelse(add_outflankout,"OutFLANK","nolegend")
		mylegend5	<- ifelse(addpcadapt,"PCadapt","nolegend")
		mylegend	<- c(mylegend1,mylegend2,mylegend3,mylegend4,mylegend5)
		mylegend	<- mylegend[!mylegend=="nolegend"]
		#
		mycolour1	<- ifelse(addbayescanout,"red","nocolour")
		mycolour2	<- ifelse(addfsthetout,"darkorchid4","nocolour")
		mycolour3	<- ifelse(addgwds,"blue","nocolour")
		mycolour4	<- ifelse(add_outflankout,"orange","nocolour")
		mycolour5	<- ifelse(addpcadapt,"darkgreen","nocolour")
		mycolour	<- c(mycolour1,mycolour2,mycolour3,mycolour4,mycolour5)
		mycolour	<- mycolour[!mycolour=="nocolour"]
		#
		legend(x=0,y=0.95,legend=mylegend,fill=mycolour,bty='n',cex=2)
		}
	if(showlabels)
		{
		if(my_dataset=="pheno"|my_dataset=="assoc1_assoc2")
			{
			if(is.null(my_labels))
				{
				mtext("typeA_typeB",side=3,line=-3,cex=2)
				}else{
				mtext(paste(my_labels[1],my_labels[2],sep="_"),side=3,line=-3,cex=2)
				}
			}else{
			mtext(my_dataset,side=3,line=-3,cex=2)
			}
		}
	if(axislabels)
		{
		mtext("Weir & Cockerham Fst", side = 2, cex = 2, line = 2.5)
		mtext("Weir & Cockerham He", side = 1, cex = 2, line = 3)
		}
	if(!is.null(exporttype)){dev.off()}
	}	
	
# requires Fdist_plot
Fdist_multiplot<-function(popnames=mysambar$populations,export=NULL)
	{
	combitable	<- combn(popnames,m=2)
	npairwise	<- ncol(combitable)
	ntiles		<- ifelse(npairwise==1,1,ifelse((npairwise==2||npairwise==3||npairwise==4),3,5))
	ntabs		<- ceiling(ncol(combitable)/ntiles)
	for (n in c(1:ntabs))
		{ 	
		graphics.off()
		if(n<ntabs)
			{
			combisubtable	<- as.matrix(combitable[,c(((n-1)*ntiles+1):(n*ntiles))])		# 17-5-2019: as.matrix is needed in case we select one column only
			}else{
			combisubtable	<- as.matrix(combitable[,c(((n-1)*ntiles+1):ncol(combitable))]) # 17-5-2019: as.matrix is needed in case we select one column only
			}
		ncomparisons		<- ncol(combisubtable)
		myheight1			<- ntiles*8
		myheight2			<- ntiles*500
		if(!is.null(export))
			{
			if(export=="eps"){postscript(paste("Fdist",n,"eps",sep="."),family=mysambar$myfont,width=10,height=myheight1)}
			if(export=="pdf"){pdf(paste("Fdist",n,"pdf",sep="."),family=mysambar$myfont,width=10,height=myheight1)}
			if(export=="png"){png(paste("Fdist",n,"png",sep="."),family=mysambar$myfont,width=720,height=myheight2)}
			if(export=="wmf"){win.metafile(paste("Fdist",n,"wmf",sep="."),family=mysambar$myfont,width=10,height=myheight1)}
			}
		# If multiple plots (multiple pairwise comparisons), divide the screen:
		par(mfrow=c(ntiles,1),oma=c(5,7,1,1),mar=c(1,1,1,1),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		for (i in c(1:ncomparisons))
			{
			combiname	<- paste(combisubtable[1,i],combisubtable[2,i],sep="_")
			addborders	<- ifelse(i==1,TRUE,FALSE)
			Fdist_plot(my_dataset=combiname,axislabels=FALSE,add_borders=addborders)
			if(n<ntabs)
				{
				if(i==ntiles)
					{
					mtext("Weir & Cockerham He", side = 1, cex = 2.75, line = 4)
					}
				}else{
				if(i==(ncol(combisubtable)))
					{
					mtext("Weir & Cockerham He", side = 1, cex = 2.75, line = 4)
					}
				}
			}
		mtext("Weir & Cockerham Fst", side = 2, cex = 3, line = 3.5,outer=TRUE)
		if(!is.null(export)){dev.off()}
		}
	}	

# Multilocus Weir and Cockerham Fst
multiLocusWeirFst<-function(popnames=mysambar$populations,export=NULL)
	{
	# duplicated columns in snps dataframe will lead to ERRORs, so therefore we first execute: 
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	combitable			<- combn(popnames,m=2)
	multilocusweirfstvector		<- vector()
	npops				<- length(popnames)
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		pop1			<- combitable[1,i]
		pop2			<- combitable[2,i]
		# select columns with minor allele frequencies:
		mafpop1			<- snps[names(snps) == paste("maf",pop1,sep="_")]	
		temp			<- colnames(mafpop1)
		mafpop1			<- mafpop1[[temp]]
		mafpop2			<- snps[names(snps) == paste("maf",pop2,sep="_")]
		temp			<- colnames(mafpop2)
		mafpop2			<- mafpop2[[temp]]
		#test1			<<- mafpop1
		#test2			<<- mafpop2
		# filter:
		mafpop1			<- mafpop1[snps$filter]
		mafpop2			<- mafpop2[snps$filter] 	
		## first define the required variables:
		r				<- 2							# number of pops
		npop1			<- length(inds$name[inds$pop2==pop1])
		npop2			<- length(inds$name[inds$pop2==pop2])
		nmean			<- mean(npop1,npop2)					# mean sample size per pop
		nloci			<- length(mafpop1)					# number of loci
		nvar			<- (npop1^2)/(r*nmean)+(npop2^2)/(r*nmean)
		nc				<- (r*nmean - nvar)/(r-1)
		mafavg			<- 1/2*(mafpop1+mafpop2)	
		mafvarmat		<- matrix(nrow=3,ncol=nloci)
		for (j in c(1:nloci))
			{
			mafvarmat[1,j]	<- (npop1*(mafpop1[j]-mafavg[j])^2)/((r-1)*nmean)
			mafvarmat[2,j]	<- (npop2*(mafpop1[j]-mafavg[j])^2)/((r-1)*nmean)	
			mafvarmat[3,j]	<- mafvarmat[1,j]+mafvarmat[2,j]
			}
		mafvar			<- mafvarmat[3,]	
		# For he, assuming Hardy-Weinberg:
		he			<- 1/2*((2*mafpop1*(1-mafpop1))+(2*mafpop2*(1-mafpop2))) 
		## now we can calculate a, b and c:
		a			<- (nmean/nc)*(mafvar-(1/(nmean-1))*(mafavg*(1-mafavg)-mafvar*((r-1)/r)-1/4*he))
		b			<- (nmean/(nmean-1))*((mafavg*(1-mafavg))-(((r-1)/r)*mafvar)-((2*he*nmean-1)/(4*nmean)))  
		weirc			<- 1/2*he
		# now we can calculate the multilocus-Fst:
		multilocusweirfstvector[i]	<- round(sum(a)/(sum(a)+sum(b)+sum(weirc)),3)
		}
	# Visualize using heatmap
	myfstmatrix	<<- matrix(0,npops,npops)
	myfstmatrix[lower.tri(myfstmatrix, diag=FALSE)] <<- multilocusweirfstvector	# in two steps, to get the order right (we want it by row, rather than by column)
	myfstmatrix <<- t(myfstmatrix)						# in two steps, to get the order right (we want it by row, rather than by column)
	myfstmatrix	<<- round(myfstmatrix,3)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(myfstmatrix,na.rm=TRUE),1)
	mymax		<- ceiling_dec(max(myfstmatrix,na.rm=TRUE),1)
	myBreaks	<- seq(mymin,mymax,(mymax-mymin)/10)
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript("WeirFst.multilocus.eps",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf("WeirFst.multilocus.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png("WeirFst.multilocus.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile("WeirFst.multilocus.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(myfstmatrix,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(myfstmatrix==0,NA,myfstmatrix),
	notecol="black",notecex=2.5,labCol=popnames,labRow=popnames,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	mtext("Weir & Cockerham 1983 multilocus Fst", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	# return a table:
	myfstmatrix				<<- rbind(combitable,multilocusweirfstvector)
	rownames(myfstmatrix)	<<- c("pop1","pop2","fst")
	myfstmatrix				<<- as.data.frame(myfstmatrix,stringsAsFactors = FALSE)
	colnames(myfstmatrix)	<<- c(1:ncol(myfstmatrix))
	}

mypopdivergencetable<-function()
	{
	mydf				<- rbind(myfstmatrix,popneivector)
	rownames(mydf)[4]	<- "nei's D"
	write.table(mydf,"SambaR.popdivergence.stats.txt",row.names=TRUE,col.names=TRUE,quote=FALSE,sep="\t")
	}	

pidf2matrix<-function(pidf=tajdlist_meta[[1]],myinds=inds$nr[inds$filter],do_colour=FALSE)
	{
	ninds									<- length(myinds)
	m2										<- matrix(NA,nrow=ninds,ncol=ninds)
	if(do_colour)
		{
		m2[lower.tri(m2)]					<- pidf[(ninds+1):nrow(pidf),"colour"]
		diag(m2)							<- pidf[(1:ninds),"colour"]
		}else{
		m2[lower.tri(m2)]					<- pidf[(ninds+1):nrow(pidf),"ndiffpersite"]
		diag(m2)							<- pidf[(1:ninds),"ndiffpersite"]
		}
	colnames(m2)							<- myinds
	rownames(m2)							<- myinds
	pimatrix								<- t(m2)
	if(do_colour)
		{
		pimatrix[lower.tri(pimatrix)]		<- pidf[(ninds+1):nrow(pidf),"colour"]
		}else{
		pimatrix[lower.tri(pimatrix)]		<- pidf[(ninds+1):nrow(pidf),"ndiffpersite"]
		}
	return(pimatrix)
	}	
	
plotrelatedness<-function(infile="plink.genome",popnames=mysambar$populations,export=NULL,shortpop=NULL)
	{
	setwd(mysambar$inputfilesdir)
	ibd			<<- read.table(infile,header=TRUE)
	setwd(mysambar$divergencedir)
	ibd$bothpops	<<- paste(ibd$FID1,ibd$FID2,sep="_")
	ibd$bothpops2	<<- paste(ibd$FID1,ibd$FID2,sep="\n")
	ibd$diffpop		<<- ibd$FID1!=ibd$FID2
	# mypairwise	<- as.vector(unique(ibd$bothpops[ibd$diffpop]))
	# mypairwise2	<- as.vector(unique(ibd$bothpops2[ibd$diffpop]))
	mypairwise	<- combn(mysambar$populations,m=2)
	mypairwise2	<- paste(combitable[1,],combitable[2,],sep="_")
	mypairwise3	<- paste(combitable[2,],combitable[1,],sep="_")
	mypairwise4	<- paste(combitable[1,],combitable[2,],sep="\n")
	npairwise	<- length(mypairwise2)
	# create combicolours colours:
	#mypops		<- as.vector(unique(inds$pop2))	
	mypops		<- mysambar$populations
	npops		<- length(mypops)
	# mycolours	<- as.vector(unique(inds$popcol))
	mycolours	<- mysambar$mycolours[1:npops]
	mypopcols	<- cbind(mypops,mycolours)
	combicoltable	<- combn(mycolours,m=2)	
	combitable		<- combn(mypops,m=2)
	combivector		<- paste(combitable[1,],combitable[2,],sep="_")	
	mycombitable	<- rbind(combivector,combitable,combicoltable)	
	mycolvector	<- vector()
	# define short population names:
	if(is.null(shortpop))
		{
		shortpop<-substr(mypops,1,2)
		}
	for(i in c(1:npairwise))
		{
		mycol1		<- mycombitable[4,i]
		mycol2		<- mycombitable[5,i]
		mycolfunc 	<- colorRampPalette(c(mycol1,mycol2))
		mycolvector[i]	<- mycolfunc(3)[2]
		}
	myvector		<- rep(NA,ncol(mycombitable))
	mycombitable	<- rbind(mycombitable,myvector)
	#
	# Plot relatedness between populations:
	cat("Plotting relatedness between populations...",sep="\n")	
	# Prepare plotting:
	if("vioplot" %in% rownames(installed.packages()) == FALSE){install.packages("vioplot",repos='http://cran.us.r-project.org')}
	library(vioplot)
	# Plot relatedness between different populations:	
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Relatedness.between.pdf",width=npairwise*2.75,height=7)}	
		if(export=="pdf"){pdf("Relatedness.between.pdf",width=npairwise*2.75,height=7)}
		if(export=="png"){png("Relatedness.between.png",width=npairwise*200,height=720)}
		if(export=="wmf"){win.metafile("Relatedness.between.wmf",width=npairwise*2.75,height=7)}
		}
	par(mar=c(7,5,2,2),cex.axis=1.75)
	plot(c(1:5),c(1:5),main="",xlim=c(0.5,npairwise+0.5),col="white",ylim=c(min(ibd$PI_HAT),max(ibd$PI_HAT)),xaxt="n",xlab="",ylab="")
	for (i in c(1:npairwise))
		{
		mypair		<- mypairwise2[i]
		mypair_rev	<- mypairwise3[i]
		mypair_label<- mypairwise4[i]
		mycol	<- mycolvector[which(combivector==mypair)]
		# cat(mypair,sep="\n")
		if(sum(ibd$PI_HAT[ibd$bothpops==mypair])==0)
			{
			boxplot(ibd$PI_HAT[ibd$bothpops==mypair|ibd$bothpops==mypair_rev],at=i,add=TRUE,names="",col=mycol,ylab="",yaxt='n')
			}else{
			vioplot(ibd$PI_HAT[ibd$bothpops==mypair|ibd$bothpops==mypair_rev],at=i,add=TRUE,names="",col=mycol)
			}
		}
	axis(side=1,at=seq(1,npairwise),labels=mypairwise4,lty=1,las=1,mgp=c(3,3,0))
	mtext("Pairwise population comparison",1,line=5,cex=2)
	mtext("proportion IBD",2,line=3,cex=2)
	if(!is.null(export)){dev.off()}	
	#
	# Plot relatedness within populations:
	cat("Plotting relatedness within populations...",sep="\n")	
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Relatedness.within.pdf",width=npops*2.5,height=7)}	
		if(export=="pdf"){pdf("Relatedness.within.pdf",width=npops*2.5,height=7)}
		if(export=="png"){png("Relatedness.within.png",width=npops*120,height=720)}
		if(export=="wmf"){win.metafile("Relatedness.within.wmf",width=npops*2.5,height=7)}
		}
	par(mar=c(4,5,2,2),cex.axis=1.75)
	plot(c(1:5),c(1:5),main="",xlim=c(0.5,npops+0.5),col="white",ylim=c(min(ibd$PI_HAT),max(ibd$PI_HAT)),xaxt="n",xlab="",ylab="")
	for (i in c(1:npops))
		{
		mypop	<- mypops[i]
		mycol	<- mycolours[i]
		if(sum(ibd$PI_HAT[ibd$FID1==mypop&!ibd$diff])==0)
			{
			boxplot(ibd$PI_HAT[ibd$FID1==mypop&!ibd$diff],at=i,add=TRUE,names=mypop,col=mycol,ylab="",yaxt='n')
			}else{
			vioplot(ibd$PI_HAT[ibd$FID1==mypop&!ibd$diff],at=i,add=TRUE,names=mypop,col=mycol)
			}
		}
	axis(side=1,at=seq(1,npops),labels=mypops,lty=1,las=1,mgp=c(3,1,0))
	mtext("Population",1,line=2.5,cex=2)
	mtext("proportion IBD",2,line=3,cex=2)
	if(!is.null(export)){dev.off()}	
	#
	# Plot relatedness per sample:
	cat("Plotting relatedness per sample...",sep="\n")
	indstemp	<- inds[order(as.character(inds$pop)),]
	mycols	<- as.vector(indstemp$popcol[indstemp$filter])
	myinds	<- as.vector(indstemp$name[indstemp$filter])
	myindnrs<- indstemp$nr[indstemp$filter]
	ninds	<- length(myinds)
	#mypops	<- as.vector(unique(inds$pop2[indstemp$filter]))
	mypops	<- mysambar$populations
	mypops2<- as.vector(indstemp$pop2[indstemp$filter])
	npops	<- length(mypops)
	mylocs	<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		temppop		<- indstemp$pop2[indstemp$filter]
		mylocs[i]	<- which(temppop==mypop)[1]-0.5
		}
	mylocs2	<- mylocs[2:length(mylocs)]
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Relatedness.persample.pdf",width=14,height=10)}	
		if(export=="pdf"){pdf("Relatedness.persample.pdf",width=14,height=10)}
		if(export=="png"){png("Relatedness.persample.png",width=14,height=720)}
		if(export=="wmf"){win.metafile("Relatedness.persample.wmf",width=14,height=10)}
		}
	par(mfrow=c(npops,1),mar=c(0.5,5,0.5,0.5),oma=c(5,1,3,2),cex.lab=2.5,cex.main=2.5)
	for(j in c(1:npops))
		{
		mypop	<- mypops[j]
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,ninds+0.5),col="white",ylim=c(min(ibd$PI_HAT),max(ibd$PI_HAT)),xaxt="n",xlab="",ylab="")
		for (i in c(1:ninds))
			{
			myind	<- myinds[i]
			mynr	<- myindnrs[i]
			mypop2	<- mypops2[i] 
			mycol	<- mycols[i]
			myibd	<- ibd[(ibd$IID1==myind|ibd$IID2==myind),]
			myibd	<- myibd[(myibd$FID1==mypop&myibd$FID2==mypop2)|(myibd$FID1==mypop2&myibd$FID2==mypop),]
			boxplot(myibd$PI_HAT,at=i,add=TRUE,names=mynr,col=mycol,border=mycol,ylab="",yaxt='n')
			}
		abline(v=mylocs2,lwd=1)
		if(npops>5)
			{
			mtext(shortpop[j],side=4,line=1,cex=1.5)
			}else{
			mtext(popnames[j],side=4,line=1,cex=1.5)
			}
		if(j==1)
			{
			if(npops>5)
				{
				mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)
				}else{
				mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)
				}
			}
		}
	mtext("proportion IBD",side=2,line=-2,outer=TRUE,cex=2)
	axis(side=1,at=seq(1,ninds),labels=myindnrs,lty=1,las=1,mgp=c(3,1,0),cex=0.75,las=2)
	mtext("Individuals",side=1,line=3,outer=TRUE,cex=2)
	if(!is.null(export)){dev.off()}
	setwd(mysambar$inputdatadir)
	}
	
# Migration analyses:	
create_bayesass_input<-function(nind=NULL,maxlines=36000,exportname="Bayesassinput")
	{
	# bayesinput can have maximum just over 36000 lines, as far as I know.
	# each line represents a locus for a single individual
	# therefore, the total number of loci equals 36000/nind.
	if(is.null(nind))
		{
		nind	<- nrow(inds[inds$filter,])
		}
	nloci	<- floor(maxlines/nind) 
	subselectdata(nrsnps=nloci,export=exportname)
	}

# plot bayesass output: 
plotmigration<-function(myinputmatrix="bayesassmatrix.txt",mycolours=NULL,export=NULL,addaxis=FALSE,addlabels=TRUE,use_current_dir=FALSE)
	{
	if(!use_current_dir)
		{
		if(exists("mysambar"))
			{
			setwd(mysambar$inputfilesdir)
			}else{
			return(cat("ERROR: Inputfilesdir not defined. First run the importdata() function, or alternatively run the plotmigration function with the flag 'use_current_dir' set to TRUE.",sep="\n"))
			}
		}
	if(!file.exists(myinputmatrix))
		{
		cat(paste("ERROR: SambaR expects to find the file '",myinputmatrix,"' in the directory:",sep=""),sep="\n")
		mypath	<- ifelse(use_current_dir,getwd(),mysambar$inputfilesdir)
		return(cat(mypath,sep="\n"))
		}
	# this function expects to find in sambardir directory a file containing a matrix defining migration rates, like:
	# EastAnglia m[0][0]: 0.8973(0.0348) m[0][1]: 0.0066(0.0028) m[0][2]: 0.0554(0.0209)
	# Ayrshire m[1][0]: 0.0138(0.0086) m[1][1]: 0.8262(0.0610) m[1][2]: 0.1110(0.0575)
	# Wurttemberg m[2][0]: 0.0016(0.0012) m[2][1]: 0.0043(0.0031) m[2][2]: 0.9895(0.0036)
	# So the first column contains population names and the other columns comprise the matrix outputted by Bayesass.
	m 			<- read.table(myinputmatrix,stringsAsFactors=FALSE)
	populations	<- m[,1]
	m			<- m[,(2:ncol(m))]
	m2			<- m[,c(FALSE,TRUE)]
	n			<- nrow(m)
	m			<- m2
	for(i in c(1:ncol(m2)))
		{
		m[,i]<- as.numeric(substr(m2[,i],1,6))
		}
	# 29-01-2019:
	# The following commands assumes migration flow is from i to j. (i = row number, j = column number)
	# However, in the Bayesass output table, migration flow is from j to to i.
	# From the Bayesass manual:
	# "Note that m[i][j] is the fraction of individuals in population i that are migrants derived from population j (per generation)."	
	# So we have to transpose the table:
	m	<- t(m)
	# create colours:
	# define colours:
	npops	<- length(mysambar$populations)
	if(npops!=nrow(m))
		{
		cat("ERROR: Number of populations in input file does not correspond to the expected number of populations.",sep="\n")
		cat(paste("Number of populations in input file (i.e. number of rows in Bayesass output file): ",nrow(m),".",sep=""),sep="\n")
		cat(paste("Number of expected populations (i.e. length(mysambar$populations)): ",npops,".",sep=""),sep="\n")
		}
	if(is.null(mycolours))
		{
		#mycolours	<- as.vector(unique(inds$popcol))
		mycolours	<- mysambar$mycolours[1:npops]
		}
	# make df1:
	df1			<- as.data.frame(cbind(c(1:n),populations))
	names(df1)	<- c("order","region")
	df1			<- arrange(df1, order)
	df1$region 	<- factor(df1$region, levels=df1$region) 
	# install packages:
	if("migest" %in% rownames(installed.packages()) == FALSE) {install.packages("migest",repos='http://cran.us.r-project.org')}
	if("plyr" %in% rownames(installed.packages()) == FALSE) {install.packages("plyr",repos='http://cran.us.r-project.org')}
	if("circlize" %in% rownames(installed.packages()) == FALSE) {install.packages("circlize",repos='http://cran.us.r-project.org')}
	if("gplots" %in% rownames(installed.packages()) == FALSE) {install.packages("gplots",repos='http://cran.us.r-project.org')}
	library("migest")
	library("plyr")
	library("circlize")
	library("gplots")
	# edit m:
	df1			<- as.data.frame(cbind(c(1:n),populations))
	names(df1)	<- c("order","region")
	df1			<- arrange(df1, order)
	df1$region 	<- factor(df1$region, levels=df1$region) 
	# edit df1:
	df1$xmin 	<- 0
	df1$xmax 	<- rowSums(m)+colSums(m)
	myrgbs		<- t(col2rgb(mycolours, alpha = FALSE))
	df1			<- as.data.frame(cbind(df1,myrgbs))
	names(df1)[5:7]	<- c("r","g","b")
	df1$rgb		<- paste(df1$r,df1$g,df1$b,sep=",")
	df1$rcol	<- col2hex(mycolours)
	df1$lcol	<- paste(df1$rcol,"C8",sep="")			# lighter colour. If you want to use, set as option in panel.fun
	df1			<<- df1
	# create df2 (needed to add migration rates):
	df1$sum1 	<- colSums(m)
	df1$sum2 	<- numeric(n)
	rownames(m)	<- populations
	df2			<- cbind(as.data.frame(m),orig=rownames(m), stringsAsFactors=FALSE)
	df2			<- reshape(df2, idvar="orig", varying=list(1:n),direction="long",timevar="dest", time=rownames(m),v.names = "m")
	df2			<- arrange(df2,desc(m))
	df2			<<- df2
	# df2		<- subset(df2, m>quantile(m,0.5))	# optionally ignore small migration rates
	# create circos plot:
	graphics.off()
	if(!use_current_dir){if(exists("mysambar$demographydir")){setwd(mysambar$demographydir)}}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Migration.circosplot.eps",family=mysambar$myfont,width=7,height=7)}
		if(export=="pdf"){pdf("Migration.circosplot.pdf",family=mysambar$myfont,width=7,height=7)}
		}
	par(mar=rep(0,4))
	circos.clear()
	circos.par(cell.padding=c(0,0,0,0),track.margin=c(0,0.15),start.degree=90,gap.degree=4,points.overflow.warning=FALSE)
	circos.initialize(factors=df1$region,xlim=cbind(df1$xmin, df1$xmax))
	circos.trackPlotRegion(ylim = c(0, 1), factors=df1$region, track.height=0.1, 
	panel.fun = function(x, y) 
		{
		name 	= get.cell.meta.data("sector.index")
		i 		= get.cell.meta.data("sector.numeric.index")
		xlim 	= get.cell.meta.data("xlim")
		ylim 	= get.cell.meta.data("ylim")
		pi 	= circlize(mean(xlim), 1.3)[1, 1] %% 360
		dd 		= ifelse(pi < 90 || pi > 270,"clockwise", "reverse.clockwise")
		aa 		= c(1,0.5)	
		if(pi < 90 || pi > 270)  aa =c(1,0.5)
		# if you want to add region labels:
		if(addlabels)
			{
			circos.text(x=max(xlim), y=1.9,labels=populations[i], facing = "bending", cex=2.5,  adj = aa)
			}
		circos.rect(xleft=xlim[1], ybottom=ylim[1],xright=xlim[2], ytop=ylim[2],col = df1$rcol[i], border=df1$rcol[i])
		circos.rect(xleft=xlim[1], ybottom=ylim[1],xright=xlim[2]-sum(df2$m)[i], ytop=ylim[1]+0.3,col = "white", border = "white")
		circos.rect(xleft=xlim[1], ybottom=0.3,	xright=xlim[2], ytop=0.32, col = "white", border = "white")
		# if you want to add region axes:
		if(addaxis)
			{
			circos.axis(labels.cex=0.6, direction="outside", major.at=seq(from=0, to=floor(df1$xmax)[i],by=5), minor.ticks=1, labels.away.percentage = 0.15)
			}
		})
	# add migration routes:
	for(k in 1:nrow(df2))
		{
		i<-match(df2$orig[k],df1$region)
		j<-match(df2$dest[k],df1$region)
		if(is.na(i)|is.na(j)){return(cat(paste("ERROR: no match between df2$orig and df1$region for k =",k,sep = " ")))}
		circos.link(
			sector.index1=df1$region[i], 
			point1=c(df1$sum1[i],df1$sum1[i] + abs(m[i,j])),
			sector.index2=df1$region[j], 
			point2=c(df1$sum2[j],df1$sum2[j] + abs(m[i,j])), 
			col = df1$lcol[i])
		df1$sum1[i] = df1$sum1[i] + abs(m[i,j])
		df1$sum2[j] = df1$sum2[j] + abs(m[i,j])
		}
	if(!is.null(export)){dev.off()}
	if(!use_current_dir)
		{
		if(exists("mysambar$sambardir")){setwd(sambardir)}
		cat("Circos plot with migration rates has been exported to demography directory",sep="\n")
		}else{
		cat("Circos plot with migration rates has been exported to working directory",sep="\n")
		}
	}	
	
# End of population differentiation analyses 
###############################################################################################################





###############################################################################################################
# Genetic diversity analyses

# This function executes all genetic distance analyses at once:
# I decided not to include calcLD, because it only calculates LD for adjacent snps (otherwise it takes too long).
# What's more, SambaR provides excellent plotting function for PLINK output. 

calcdiversity<-function(nrsites=NULL,nrsegsites=NULL,nrsnps=NULL,legend_cex=2.5,silent=TRUE)
	{
	# nrsites must be a vector of length of either 1 or length of vector mysambar$populations
	# nrsegsites must be vector of length of either 1 or length of vector mysambar$populations
	# nrsnps must be a vector of length of either 1 or length of nrow(inds)
	#
	# nrsites: total number of sequenced sites
	# nrsegsites: 	inds$nsegsites3		# number of segregating sites per population (not filtered)
	# nrsnps: 		inds$nsegsites4		# number of segregating sites per individual (not filtered)
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
	setwd(mysambar$diversitydir)
	cat("Hardy Weinberg calculations...",sep="\n")
	hwe(export="pdf")
	# plot_F(export=TRUE)				# 26-09-2019: incorrect at the moment, needs to be improved	
	if(length(mysambar$populations)==1)
			{
			cat("Currently only 1 population defined. Most plots won't be generated, as they are meant to compare diversity between populations.",sep="\n")
			}
	npops	<- length(mysambar$populations)
	if(is.null(nrsites))
		{
		cat("You didn't provide the total number of sequenced sites (i.e.: nsites=NULL).",sep="\n")
		cat("You miss out on various interesting analyses! See SambaR manual for more details.",sep="\n")
		}else{
		if(length(nrsites)==1)
			{
			inds$allseqsites	<<- nrsites
			}else{
			if(length(nrsites)!=npops)
				{
				return(cat("ERROR: length of vector input to nrsites flag should be either 1 or equal to number of populations.",sep="\n"))
				}else{
				inds$allseqsites		<<- NA
				for(i in c(1:nrow(inds)))
					{
					inds$allseqsites[i]	<<- nrsites[which(mysambar$populations==inds$pop2[i])]
					}
				}
			}
		inds$S			<<- inds$nsegsites3/inds$allseqsites
		}
	if(length(mysambar$populations)>1)
		{
		cat("Counting number of private alleles...",sep="\n")
		private_hist(snpsfilter=NULL,export="eps")
		private_hist(snpsfilter=NULL,export="pdf")
		private_hist(snpsfilter=NULL,export="png")
		private_hist(snpsfilter=NULL,export="wmf")
		private_hist(snpsfilter=snps$filter,export="eps")
		private_hist(snpsfilter=snps$filter,export="pdf")
		private_hist(snpsfilter=snps$filter,export="png")
		private_hist(snpsfilter=snps$filter,export="wmf")
		}else{
		cat("Only 1 population defined. Skipping count of private alleles.")
		}
	cat("Generating site frequency spectra...",sep="\n")
	plotgenocounts(addlabels=FALSE,export=TRUE)
	plotgenocounts(addlabels=TRUE,export=TRUE)
	if(!silent){cat("getfoldedsfs",sep="\n")}
	getfoldedsfs()
	if(!silent){cat("barplotsfs",sep="\n")}
	barplotsfs(export="eps")
	barplotsfs(export="pdf")
	barplotsfs(export="png")
	barplotsfs(export="wmf")
	if(!silent){cat("plotsfs",sep="\n")}
	plotsfs(export="eps",silent=TRUE,legendcex=legend_cex)										# without barplot showing number of segregating sites
	plotsfs(export="pdf",silent=TRUE,legendcex=legend_cex)
	plotsfs(export="png",silent=TRUE,legendcex=legend_cex)
	plotsfs(export="wmf",silent=TRUE,legendcex=legend_cex)
	plotsfs(export="eps",silent=TRUE,addlegend=FALSE)										
	plotsfs(export="pdf",silent=TRUE,addlegend=FALSE)
	plotsfs(export="png",silent=TRUE,addlegend=FALSE)
	plotsfs(export="wmf",silent=TRUE,addlegend=FALSE)
	if(length(mysambar$populations)>1)
		{
		if(!silent){cat("plot2Dsfs",sep="\n")}
		plot2Dsfs(export="eps")	
		plot2Dsfs(export="pdf")
		plot2Dsfs(export="png")
		plot2Dsfs(export="wmf")		
		}
	cat("Calculating pi and tajima's D per population...",sep="\n")
	#calcpi(pi_per_pop=TRUE)	# Has been run by findstructure() function.								
	if(length(mysambar$populations)>1)
		{
		seqdivplot(export=TRUE)
		if(!silent){cat("plottajd",sep="\n")}
		plottajd(export=TRUE,insetbarplot=TRUE,legendcex=legend_cex)
		}
	plottajd(export=TRUE,insetbarplot=FALSE,legendcex=legend_cex)
	if(!is.null(nrsites))
		{
		cat("Plotting proportion of segregating sites...",sep="\n")
		plotsfs(nsites=nrsites,addbarplot=TRUE,nsegsites=nrsegsites,export="eps",silent=TRUE,legendcex=legend_cex)	# with barplot with number of segregating sites is included
		plotsfs(nsites=nrsites,addbarplot=TRUE,nsegsites=nrsegsites,export="pdf",silent=TRUE,legendcex=legend_cex)
		plotsfs(nsites=nrsites,addbarplot=TRUE,nsegsites=nrsegsites,export="png",silent=TRUE,legendcex=legend_cex)
		plotsfs(nsites=nrsites,addbarplot=TRUE,nsegsites=nrsegsites,export="wmf",silent=TRUE,legendcex=legend_cex)
		cat("Plotting genome wide heterozygosity and pi...",sep="\n")
		getgenomepi(nsites=inds$allseqsites,nsnps=nrsnps)
		if(!silent){cat("plotHe_perind",sep="\n")}
		plotHe_perind(export="eps",genomehe=TRUE)
		plotHe_perind(export="pdf",genomehe=TRUE)
		plotHe_perind(export="png",genomehe=TRUE)
		plotHe_perind(export="wmf",genomehe=TRUE)
		if(!silent){cat("plotgenomehe",sep="\n")}
		plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="eps")
		plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="pdf")
		plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="png")
		plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="wmf")
		if(!silent){cat("plotpi_vs_he",sep="\n")}
		plotpi_vs_he(export="eps")
		plotpi_vs_he(export="pdf")
		plotpi_vs_he(export="png")
		plotpi_vs_he(export="wmf")
		if(length(mysambar$populations)>1)
			{
			if(!silent){cat("seqdivplot",sep="\n")}
			seqdivplot(nsites=nrsites,export=TRUE)
			if(!silent){cat("plottajd",sep="\n")}
			plottajd(export=TRUE,insetbarplot=TRUE,genome_wide=TRUE,legendcex=legend_cex)
			}
		if(!silent){cat("plottajd",sep="\n")}
		plottajd(export=TRUE,insetbarplot=FALSE,genome_wide=TRUE)
		cat("Generating summary statistics...",sep="\n")	
		popstats(nsites=nrsites)			
		}else{
		cat("Generating summary statistics...",sep="\n")
		popstats()
		}
	# plotstats()
	if("dist" %in% colnames(snps))
		{
		homorun(export="pdf")
		if(!silent){cat("multimafdiff",sep="\n")}
		multimafdiff(export=TRUE,do_boxplot=FALSE,do_scatterplot=TRUE,addoutliers=FALSE)
		}
	# reset working directory:
	setwd(mysambar$inputdatadir)
	cat("Analysis finished.",sep="\n")
	}

private_hist<-function(popnames=mysambar$population,snpsfilter=NULL,export=NULL)
	{
	npops		<- length(popnames)
	snpstemp	<- snps[,paste("maf",popnames,sep="_")]
	mafsum		<- rowSums(snpstemp)
	privatevec	<- vector()
	for(j in c(1:npops))
		{
		mypop			<- popnames[j]
		mymaf			<- snps[,paste("maf",mypop,sep="_")]
		if(is.null(snpsfilter))
			{
			privatevec[j]	<- length(mymaf[mymaf==mafsum&mafsum!=0]) 
			}else{
			privatevec[j]	<- length(mymaf[mymaf==mafsum&snpsfilter&mafsum!=0]) 
			}
		mymaf			<<- mymaf
		mafsum			<<- mafsum
		}
	if(!is.null(export))
		{
		plotname	<- ifelse(is.null(snpsfilter),"Private_alleles_unfiltered","Private_alleles_filtered")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=npops*2+1,width=14)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=npops*2+1,width=14)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=npops*250+100,width=1400)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=npops*2+1,width=14)}
		}
	par(mar=c(6,20,3,0),cex.axis=3)
	privatevec2	<- privatevec/1000
	xx<-barplot(privatevec2,las=1,col=mysambar$mycolours,border=NA,space=0.1,names.arg=mysambar$populations,horiz=TRUE,xlim=c(0,max(privatevec2)*1.3))
	text(x=privatevec2,y=xx,privatevec2,pos=4,cex=3)
	mtext("# private alleles (k)",side=1,line=3.5,cex=3)
	snpstotal	<- ifelse(!is.null(snpsfilter),nrow(snps[snpsfilter&mafsum!=0,]),nrow(snps[mafsum!=0,]))
	mtext(paste("# SNPs:",snpstotal/1000,"k",sep=" "),side=3,line=0.75,cex=3)
	if(!is.null(export)){dev.off()}
	}
	
snp_sim<-function(snp1=NULL,snp2=NULL)
	{
	# how similar are genotype scores of two snps?
	# expects genotype scores of two biallelic snps (e.g 0,1,2) 
	# output is stored in scalar 'snpsim'
	# The similarity roughly indicates whether snps have same distribution of a minor and a major allele. 
	nodata	<- is.na(snp1)|is.na(snp2)
	if(sum(nodata)==length(nodata))
		{
		snpsim <<- NA
		}else{
		snp1	<- snp1[!nodata]	
		snp2	<- snp2[!nodata]	
		onediff	<- sum(abs(snp2-snp1)==1)
		twodiff	<- sum(abs(snp2-snp1)==2)
		snpsim	<<- 1-((onediff+2*twodiff)/(2*length(snp1)))	
		}
	#cat(paste("Similarity score:",snpsim,sep=" "),sep="\n")
	}
	
# This function calculates LD only for adjacent snps.	
# 27-03-2019: To do for more than just adjacent snps takes a long time, so better to use PLINK.
calcLD<-function(mypop=NULL,add_snpsim=FALSE)
	{
	cat("Calculating LD estimates for unphased data (squared pearson correlation coefficients)...",sep="\n")
	if(is.null(mypop))
		{
		indfilter	<- inds$filter
		}else{
		indfilter	<- inds$filter&inds$pop==mypop
		}
	# This function outputs LD values (squared pearson correlation coefficients) between adjacent snps: 
	# It generates NA if a SNP contains no variation (so only 0's, 1's or 2's (except from NA))
	mymatrix	<- as.matrix(mygenlight)[indfilter,snps$filter2]
	mysnps		<- as.vector(snps$name[snps$filter2])
	mychr		<- snps$chr[snps$filter2]
	mypos		<- snps$pos[snps$filter2]
	myld		<- vector()
	myld[1]		<- NA
	# to suppress warnings:
	op 			<- options(warn = (-1))
	ldmatrix	<- as.data.frame(matrix(NA,ncol=8,nrow=length(mysnps)))
	colnames(ldmatrix)	<- c("snp1","snp2","chr1","chr2","pos1","pos2","ld","sim")
	ldmatrix$sim<- NA
	#for (k in c(2:ncol(mymatrix)))	# replacement has 37 rows, data has 36
	for (k in c(2:nrow(ldmatrix)))	# replacement has 36 rows, data has 175
		{
		ldmatrix$snp1[k]	<- mysnps[k-1]
		ldmatrix$snp2[k]	<- mysnps[k]
		ldmatrix$chr1[k]	<- mychr[k-1]
		ldmatrix$chr2[k]	<- mychr[k]	
		ldmatrix$pos1[k]	<- mypos[k-1]
		ldmatrix$pos2[k]	<- mypos[k]	
		mypair				<- mymatrix[,c((k-1),k)]
		mycorr				<- cor(mypair,method="pearson",use="na.or.complete")
		myld[k]				<- mycorr[2,1]
		ldmatrix$ld[k]		<- mycorr[2,1]
		# Note: this has nothing to do with LD, but just to see how similar the snps are:
		if(add_snpsim)
			{
			snp_1				<- mypair[,1]
			snp_2				<- mypair[,2]
			snp_sim(snp1=snp_1,snp2=snp_2)
			ldmatrix$sim[k]		<- snpsim
			}
		}
	# ldmatrix$ld will have NA if at least one of both snps has identical genotype scores for all individuals (so all individuals are either 0,1,2)
	# this is ignoring individuals with NA scores (note: NA in either the individual itself, or NA in the other individual)
	# enable warnings again:
	ldmatrix				<<- ldmatrix
	options(op)
	snps$ldtemp				<<-	NA 				# this NA values can be discriminated from NA values mentioned above by using snps$filter
	snps$ldtemp[snps$filter]<<- round(myld^2,4)
	if(is.null(mypop))
		{
		names(snps)[names(snps)=="ldtemp"]	<<- "ld_meta"
		}else{
		names(snps)[names(snps)=="ldtemp"]	<<- paste("ld",mypop,sep="_")
		}
	snps 		<<- snps[, !duplicated(colnames(snps),fromlast=TRUE)]
	}	

calcpopLD<-function(popnames=mysambar$populations)
	{
	for (my_pop in popnames)
		{
		cat(my_pop,sep="\n")
		calcLD(mypop=my_pop)
		}
	snps 		<<- snps[, !duplicated(colnames(snps),fromlast=TRUE)]
	}
	
# depends on wintajd:	
wintajd_multiplewinsizes<-function(my_chr=25,doexport=TRUE)
	{
	if(doexport){pdf(paste("TajimaD",my_chr,"multiple_windowsizes.pdf",sep="."),height=16,width=12)}
	par(mfrow=c(4,1),oma=c(3,3,2,3))
	wintajd(my_chrom=my_chr,winsize=500000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	wintajd(my_chrom=my_chr,winsize=1000000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	wintajd(my_chrom=my_chr,winsize=1500000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	wintajd(my_chrom=my_chr,winsize=2000000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	mtext("Position (Mb)",side=1,line=0,outer=TRUE,cex=2)
	mtext("Tajima's D",side=2,line=-1,outer=TRUE,cex=2)
	mtext(paste("Chromosome",my_chr,sep=" "),side=3,line=-2.5,outer=TRUE,cex=2)
	mtext("Number of SNPs per window",side=4,line=-0.5,outer=TRUE,cex=2)
	if(doexport){dev.off()}
	# and separate plots:
	wintajd(my_chrom=my_chr,winsize=500000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	wintajd(my_chrom=my_chr,winsize=1000000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	wintajd(my_chrom=my_chr,winsize=1500000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	wintajd(my_chrom=my_chr,winsize=2000000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	}

# depends on function wintajd()	
wintajd_multiplechroms<-function(mycomparisons=NULL,popnames=mysambar$populations,ntiles=18,mychroms=NULL,windowsize=50000000,windowstep=30000000,export=NULL,addX=TRUE,myyrange=c(-3,3),my_lwd=1.5)
	{
	myxmax	<- max(snps$pos[snps$filter],na.rm=TRUE)
	my_xlim	<- c(0,myxmax/1000000)
	setwd(mysambar$selectiondir)
	# run windowfst function recursively:
	if(is.null(mycomparisons))
		{
		mycomparisons=seq(1:ncol(combn(popnames,m=2)))
		}
	if(is.null(mychroms))
		{
		mychroms<-sort(as.numeric(as.vector(unique(snps$chr[as.vector(snps$autosomal)]))))
		}
	nchroms		<- length(mychroms)
	ntabs		<- ceiling(nchroms/ntiles)
	for (n in c(1:ntabs))
		{ 
		if(!is.null(export))
			{
			if(export=="eps"){postscript(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"eps",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="pdf"){pdf(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"pdf",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="png"){png(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"png",sep="."),family=mysambar$myfont,width=540,height=720)}
			if(export=="wmf"){win.metafile(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"wmf",sep="."),family=mysambar$myfont,width=6,height=8)}
			}
		layout(matrix(c(c(c(1:(ntiles/2)),ntiles+1),c((ntiles/2+1):(ntiles+1))),nrow=(ntiles/2+1),ncol=2,byrow=FALSE))
		#layout(matrix(c(1:ntiles),(ntiles/2),2,byrow=FALSE))
		par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,2,2))
		if(n<ntabs)
			{
			chromset	<- mychroms[((n-1)*ntiles+1):(ntiles*n)]
			}else{
			chromset	<- mychroms[((n-1)*ntiles+1):length(mychroms)]
			}
		for (chromname in chromset)
			{
			# cat(chromname,sep="\n")
			if(chromname%%(ntiles/2)==0)
				{
				wintajd(my_chrom=chromname,winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addinfo=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
				#windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
				}else{
				if(mychroms[nchroms]==chromname&&addX==FALSE)
					{
					wintajd(my_chrom=chromname,winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addlab=FALSE,addinfo=FALSE,addxaxis=FALSE,subtitlepos=-2)
					#windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
					}else{
					wintajd(my_chrom=chromname,winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addlab=FALSE,addinfo=FALSE,addxaxis=FALSE,subtitlepos=-2)
					#windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=FALSE,mylwd=my_lwd)
					}
				}
			}
		if(addX&n==ntabs)
			{
			wintajd(my_chrom="X",winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addlab=FALSE,addinfo=FALSE,addxaxis=TRUE,subtitlepos=-2)
			#windowfst(chrom="X",selectcombi=mycomparisons,width=windowsize,yrange=c(0.025,0.225),yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
			}
		mtext("Tajima's D", side=2, line=0, outer=TRUE,cex=1.5)
		mtext("Position along chromosome (Mb)", side=1, line=-3.5, outer=TRUE,cex=1.25)
		# addlegend:
		if(n==ntabs)
			{
			nempty	<- ifelse(addX,(ntabs*ntiles-length(mychroms)-1+1),(ntabs*ntiles-length(mychroms)+1))
			for(mycounter in c(1:(nempty)+1))
				{
				plot(1,type ="n",axes=FALSE,xlab="",ylab="")	
				}
			}else{
			plot(1,type= "n",axes=FALSE,xlab="",ylab="")
			}
		legend(x="bottom",legend=popnames,horiz=T,fill=mysambar$mycolours[1:length(popnames)],cex=1.25,bty="n")
		if(!is.null(export)){dev.off()}
		}
	setwd(mysambar$inputdatadir)
	}		
	
# depends on calcpi:
wintajd<-function(my_chrom=25,winsize=1000000,winstep=200000,popnames=mysambar$populations,do_analysis=TRUE,export=FALSE,addlab=TRUE,addinfo=TRUE,addxaxis=TRUE,subtitlepos=-1.5,myxlim=NULL)
	{
	npops			<- length(popnames)
	mycols			<- mysambar$mycolours[1:npops]
	if(do_analysis)
		{
		mymax		<- max(snps$pos[snps$chr==my_chrom],na.rm=TRUE)
		mystarts	<- seq(0,winsize,winstep)
		mywindows	<- vector() 
		for(mystart in mystarts)
			{
			mywindow	<- seq(mystart,mymax,winsize)
			mywindows	<- c(mywindows,mywindow)
			}
		windowstart	<- sort(as.vector(unique(mywindows)))
		windowend	<- windowstart+winsize
		nwin		<- length(windowstart)
		cat(paste("Calculating Tajima's D for",nwin,"windows of",winsize/1000000,"Mb width on contig/chromosome",my_chrom,"...",sep=" "),sep="\n")
		for(k in c(1:nwin))
			{
			cat(k,sep="\n")
			mywindow	<- c(windowstart[k],windowend[k])
			calcpi(mychrom=my_chrom,myrange=mywindow,silent=TRUE,pi_per_pop=TRUE)
			if(k==1)
				{
				wintaj	<<- tajd
				}else{
				wintaj	<<- rbind(wintaj,tajd)
				}
			}
		mymean	<- round(mean(wintaj$mean_nsites,na.rm=TRUE),1) 
		cat(paste("Average number of SNPs per window:",mymean,sep=" "),sep="\n")
		cat(paste("Results have been written to a dataframe called wintaj."),sep="\n")
		mymax	<- max(wintaj$TajimaD,na.rm=TRUE)
		mymin	<- min(wintaj$TajimaD,na.rm=TRUE)
		mymax	<- ifelse(mymax< 3, 3, mymax)
		mymin	<- ifelse(mymax> -3,-3, mymin)
		}
	# plot:
	if(export){pdf(paste("TajimaD",my_chrom,"winsize",winsize/1000000,"Mb.pdf",sep="."),height=5,width=12)}
	if(addinfo)
		{
		par(mar=c(4,4.5,3,5),cex.axis=1.5)		# par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,2,2))		
		}
	myxaxt		<- ifelse(addxaxis,'s','n')
	mypop		<- popnames[1]
	plot(wintaj$mid[wintaj$pop==mypop]/1000000,wintaj$TajimaD[wintaj$pop==mypop],type='l',las=1,lwd=2,col=mycols[1],xaxt=myxaxt,ylim=c(mymin,mymax),xlim=myxlim,ylab="",xlab="",main="")
	if(npops>1)
		{
		for(i in c(2:npops))
			{	
			mypop	<- popnames[i]
			points(wintaj$mid[wintaj$pop==mypop]/1000000,wintaj$TajimaD[wintaj$pop==mypop],type='l',lwd=2,col=mycols[i])
			}
		}
	if(addlab)
		{
		mtext("Tajima's D",side=2,line=2.5,cex=2)
		mtext("Position (Mb)",side=1,line=2.5,cex=2)
		mytitle		<- paste("chromosome",my_chrom,sep=" ")
		mtext(mytitle,side=3,line=0,cex=2)
		}else{
		mtext(my_chrom,side=3,line=-1,cex=0.75)
		}
	if(addinfo)
		{
		mysubtitle	<- paste("window size:",winsize/1000000,"Mb",sep=" ")
		mtext(mysubtitle,side=3,line=subtitlepos,cex=1.5)
		}
	# plot number of snps per window:
	if(addinfo)
		{
		par(new=TRUE)
		mymin2	<- min(wintaj$mean_nsites,na.rm=TRUE)
		mymax2	<- max(wintaj$mean_nsites,na.rm=TRUE)
		myrange2<- mymax2-mymin2
		myrange1<- mymax-mymin
		mypop	<- popnames[1]
		plot(wintaj$mid[wintaj$pop==mypop],wintaj$mean_nsites[wintaj$pop==mypop],col="white",type='l',yaxt='n',xaxt=myxaxt,ylab="",xlab="",xaxt='n',ylim=c(mymin2,myrange1*mymax2))
		polygon(x=c(wintaj$mid[wintaj$pop==mypop],rev(wintaj$mid[wintaj$pop==mypop])),y=c(rep(0,length(wintaj$mean_nsites[wintaj$pop==mypop])),rev(wintaj$mean_nsites[wintaj$pop==mypop])),col="grey",border=NA)
		axis(side=4,las=1)
		if(addlab)
			{
			mtext("SNPs per window",side=4,cex=2,line=3.5)
			}
		par(new=TRUE)
		plot(wintaj$mid[wintaj$pop==mypop]/1000000,wintaj$TajimaD[wintaj$pop==mypop],col=mycols[1],type='l',ylim=c(mymin,mymax),xaxt=myxaxt,ylab="",xlab="",main="",yaxt='n',xaxt='n')
		# last two lines are needed to add outlier borders
		}
	# add Tajima's D outlier borders:
	abline(h=c(2,-2),lty=2)
	if(addinfo)
		{
		text(x=0,y=-2,"positive selection",adj=c(0,1.25),cex=1)
		text(x=0,y=2,"balancing selection",adj=c(0,-0.5),cex=1)
		}
	if(export){dev.off()}
	}

# depends on output of calcpi with flag pi_per_pop set to TRUE:
plottajd<-function(tajdtable=NULL,genome_wide=FALSE,nsites=NULL,nsegsites=NULL,popnames=mysambar$populations,export=TRUE,insetbarplot=TRUE,legendcex=2)
	{
	# if genome_wide is set to FALSE, nucleotide diversity (pi) and Watterson theta are for snp dataset only 
	# if genome_wide is set to TRUE, nucleotide diversity (pi) and Watterson theta are genome wide (i.e. * segregating/sequenced sites)
	if(insetbarplot&length(popnames)==1)
		{
		return(cat("Only 1 population defined. No space in plot for inset. Set insetbarplot to FALSE.",sep="\n"))
		}
	npops	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npops]
	if(!is.null(tajdtable))
		{
		if(nrow(tajdtable)!=length(popnames))
			{
			return(cat("ERROR: Number of rows in input tajdtable does not equal number of populations.",sep="\n"))
			}else{
			tajd	<- tajdtable	# else: tajd should be in environment, created by calcpi(pi_per_pop=TRUE)
			}
		}
	if(!exists("tajd"))
		{
		calcpi(pi_per_pop=TRUE)
		}
	if(nrow(tajd)!=length(popnames))
		{
		calcpi(pi_per_pop=TRUE)
		}
	mywatt	<- tajd$Watterson_scaled		# tajd$Watterson/tajd$mean_nsites	
	mypi	<- tajd$pi_scaled			# tajd$mean_pi/tajd$mean_nsites
	mytajd	<- tajd$TajimaD_scaled			# tajd$TajimaD/tajd$mean_nsites
	if(genome_wide)
		{
		if(is.null(nsegsites))
			{
			indstemp	<- inds[,c("pop2","nsegsites3")]
			aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop2),FUN=mean, na.rm=TRUE)
			myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
			}else{
			if(length(nsegsites)!=npops)
				{		
				return(cat("The length of vector input to nsegsites does not equal the number of populations. SambaR can not generate Tajima's D plot.",sep="\n"))
				}else{
				myseg		<- nsegsites			
				}
			}
		if(is.null(nsites))
			{
			indstemp	<- inds[,c("pop2","allseqsites")]
			aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop2),FUN=mean, na.rm=TRUE)
			allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
			}else{
			allsites	<- nsites
			}
		mywatt	<- mywatt*myseg/allsites*100
		mypi	<- mypi*myseg/allsites*100
		mytajd	<- mytajd*myseg/allsites*100
		myscores	<<- cbind(mywatt,mypi,mytajd)
		}
	mymin	<- min(mywatt,mypi)-0.02
	mymax	<- max(mywatt,mypi)+0.02
	myrange	<- c(mymin,mymax)
	if(export)
		{
		if(genome_wide)
			{
			plotname	<- ifelse(insetbarplot,"Wattersontheta_vs_pi.withTajima.genomewide.pdf","Wattersontheta_vs_pi.genomewide.pdf")
			}else{
			plotname	<- ifelse(insetbarplot,"Wattersontheta_vs_pi.withTajima.snpdata.pdf","Wattersontheta_vs_pi.snpdata.pdf")
			}
		pdf(plotname,height=8,width=8)		
		}
	par(fig = c(0,1,0,1),cex.axis=1.5,cex.lab=2,mar=c(5,6,2,1))
	plot(mywatt,mypi,xlim=myrange,ylim=myrange,las=1,col=mycols,pch=16,cex=2,ylab="",xlab="")
	lines(x=c(0,1),y=c(0,1),lty=2)
	#text(0.11,0.105,"Excess of rare alleles",srt=45,adj=c(0,1),cex=1.5) 	
	#text(0.105,0.11,"Lack of rare alleles",srt=45,adj=c(0,0),cex=1.5) 
	mymin2<-mymin+0.0075
	text(mymin2,mymin2-0.00375,"Excess of rare alleles",srt=45,adj=c(0,1),cex=1.5) 	
	text(mymin2-0.00375,mymin2,"Lack of rare alleles",srt=45,adj=c(0,0),cex=1.5) 
	mtext("Nucleotide diversity (%)",side=2,line=4,cex=2)
	mtext("Watterson's theta (%)",side=1,line=3,cex=2)
	legend("topleft",popnames,fill=mycols,cex=legendcex,bty='n')
	if(insetbarplot)
		{
		barwidth	<- 0.3/npops 
		myx			<- 1-(npops*barwidth)-0.025
		myx			<- ifelse(myx<0.1,0.1,myx)
		par(fig=c(myx,0.975,0.025,0.425),new=TRUE)
		mymin2	<- min(mytajd)-0.002
		mymax2	<- max(mytajd)+0.002
		myrange2<- c(mymin2,mymax2)
		barplot(mytajd,col=mycols,las=1,ylim=myrange2,border=mycols,space=0.1)
		if(npops>2)		# with less populations, the title doesn't fit
			{
			mtext(side=3,"Tajima's D",line=0.5,cex=1.5)
			}
		}
	if(export){dev.off()}
	#
	# separate barplot Tajima's D:
	if(!insetbarplot)
		{
		graphics.off()
		if(export)
			{
			if(genome_wide)
				{
				pdf("TajimaD.barplot.genomewide.pdf")
				}else{
				pdf("TajimaD.barplot.snpdata.pdf")
				}
			}
		par(mar=c(4,8,2.5,2.5))
		barplot(mytajd,col=mycols,border=mycols,space=0.1,horiz=TRUE,main="Tajima's D",names.arg=popnames,las=2)
		if(export){dev.off()}
		}
	}

# 15-03-19: new version to calculate pi: 
calcpi<-function(pi_per_pop=FALSE,myinput=mygenlight,indselection=inds$filter,snpselection=snps$filter,popnames=mysambar$populations,samplesize=NULL,mychrom=NULL,myrange=NULL,corrected=TRUE,silent=TRUE)
	{
	# This function calculates pi: the average number of variant sites when randomly drawing 2 sequences from a population.
	## pi is calculated as follows:
	# Say genlight object is as follows (3 individuals, 2 snps):
	# 0 1
	# 2 NA
	# 1 0
	# First NA is converted into 3, because R sometimes counts NA as 1.
	#
	# Second we calculate the number of differences between and within individuals, and take into account that each pairwise (diploid) individual comparison entails 4 haplotype comparisons (AB,Ab,aB,ab)
	# comparison	snp1	snp2	total			meanpairwise
	# ind1-ind2: 	4 + 	NA = 	4		/4 =	1	
	# ind1-ind3: 	2 + 	2 = 	4		/4 =	1
	# ind2-ind3: 	2 + 	NA = 	2		/4 =	0.5
	# ind1: 		0 + 	1 = 	1				1
	# ind2: 		0 + 	NA = 	0				0
	# ind3: 		1 + 	0 = 	1				1
	# total:						12				4.5
	# average:										0.75		
	# So we find that on average 0.75 sites differ between two haplotypes. This is the observed pi. 
	#
	# Third we calculate the number of missing data:
	# comparison	snp1	snp2	total			meanpairwise	meannonmissing
	# ind1-ind2: 	0 + 	4 = 	4		/4 =	1				1
	# ind1-ind3: 	0 + 	0 = 	0		/4 =	0				2
	# ind2-ind3: 	0 + 	4 = 	4		/4 =	1				1
	# ind1: 		0 + 	0 = 	0				0				2
	# ind2: 		0 + 	1 = 	1				1				1
	# ind3: 		0 + 	0 = 	0				0				2
	# total:						9				3				9
	# average:										0.5				1.5		
	# So we find that on average we have data for 1.5 sites per haplotype, rather than for 2 sites.
	# The corrected pi therefore equals: 0.75/2*1.5 = 0.5625 differences per haplotype (of 2 bp length). 
	# The default is to use the corrected pi. Set corrected to FALSE, to use uncorrected pi. 
	#
	# 18-03-2019: I don't understand why the following reasoning doesn't give the same outcomes as above for uncorrected and corrected pi:
	# Total number of differences: 				12
	# Total snp comparisons: 					4*(choose(nind,2))+nind)*nsnp 	= 	15*2 = 30
	# Total number of missing datapoints: 		9
	# Total number of non-missing datapoints:	30-9 = 21
	# Uncorrected pi:						12/30 = 0.4
	# Corrected pi: 							12/21 = 0.5714
	# Just to avoid confusion: this is just a consideration. Not used for actual calculations. 
	#
	## Watterson's estimate of theta is calculated as follows (corrected for missing data):
	# The per snp average number of inds with data:	(3 + 2)/2 = 2.5
	# The average number of haplotypes: 			nind*2 = 2.5*2 = 5 			# 6 haplotypes for first SNP, 4 haplotypes for second SNP
	# n-1: 											5-1 = 4  
	# Number of snps with maf>0 (S):				2 
	# Corrected Watterson's estimate of theta:		S/(sum(1/(1/1+...+1/(n-1))) = 2/(1/1+1/2+1/3+1/4) = 2/2.083 = 0.96
	# This number is telling us that for each pairwise comparison of haplotypes (of 2 bp length) we expect 0.96 sites to differ between both haplotypes.  
	# Uncorrected Watterson's estimate of theta:	2/(1/1+1/2+1/3+1/4+1/5) = 2/2.28 = 0.87  
	# 
	## Tajima's D is calculated as follows:
	# Observed uncorrected pi minus corrected Watterson's estimate:
	# Tajima's D: 0.75 - 0.96 = -0.21 
	#
	# I first tried by the way to calculate sliding window with snpR, using the following steps, but that resulted in an ERROR: 
	# options(repos=c(CRAN='http://cran.us.r-project.org'))
	# install_github("hemstrow/snpR")
	# library(snpR)
	# mymatrix	<- as.matrix(mygenlight[inds$filter,snps$filter2])
	# mymatrix	<- cbind(inds$nr[inds$filter],inds$pop[inds$filter],mymatrix)
	# newmat		<- format_snps(mymatrix, ecs=2, output = 1, input_form = "0_geno") 
	# but then I got an ERROR it couldn't find 'm'
	#
	# define which snps to be included in analysis:
	if(is.null(mychrom)&!is.null(myrange)){return(cat("ERROR: not allowed to define a range (myrange flag) without defining chromosome/contig (mychrom flag)",sep="\n"))}
	if(!is.null(mychrom)&!is.null(myrange))	{snpselection	<- snpselection&snps$chr==mychrom&snps$pos>=myrange[1]&snps$pos<=myrange[2]}
	if(!is.null(mychrom)&is.null(myrange))	{snpselection	<- snpselection&snps$chr==mychrom}
	if(!is.null(mychrom)&!is.null(myrange))
		{
		# cat(paste("chrom =",mychrom,sep=" "),sep="\n")
		# cat(paste("range =",myrange,sep=" "),sep="\n")
		nsnps	<- nrow(snps[snps$chr==mychrom&snps$pos>myrange[1]&snps$pos<myrange[2]&snps$filter,])
		if(nsnps<1){return(cat("No snps in specified range.",sep="\n"))}
		}
	# Prepare output table:
	if(pi_per_pop)
		{
		popnames		<- popnames
		}else{
		popnames		<- "metapop"
		}
	npops			<- length(popnames)
	ninds			<- nrow(inds[inds$filter,])
	outmat			<- as.data.frame(matrix(NA,ncol=13,nrow=npops))
	colnames(outmat)<- c("pop","chrom","start","end","mid","mean_nsites","mean_pi","mean_maf","expected_pi","S","harmonic_number","Watterson","TajimaD")
	outmat$pop		<- popnames
	tajdlist		<- list()
	if(!is.null(mychrom)&!is.null(myrange))
		{
		outmat$chrom<- mychrom
		outmat$start<- myrange[1]
		outmat$end	<- myrange[2]
		outmat$mid	<- round(mean(myrange))
		}
	if(!is.null(mychrom)&is.null(myrange))	{outmat$chrom<- mychrom}
	# Run calculation:
	if(any(snpselection))
		{
		mymatrix		<- as.matrix(myinput[,snpselection]) 
		for (p in c(1:npops))
			{
			mypop		<- popnames[p]
			mypopcol	<- mysambar$mycolours[p]
			# cat(mypop,sep="\n")
			if(!pi_per_pop)
				{
				myinds		<- inds$nr[indselection]
				mymaf		<- snps$maf[snpselection]
				}else{
				myinds		<- inds$nr[inds$pop==mypop&indselection]
				mymaf		<- snps[snpselection,paste("maf",mypop,sep="_")]
				}
			if(!is.null(samplesize))
				{
				myinds		<- sample(myinds,samplesize,replace=FALSE)
				}
			## compare haplotypes between individuals (4 possible combinations per pair):
			combitable	<- combn(myinds,m=2)
			ndiffvec	<- vector() 
			ndatavec	<- vector()
			nnavec		<- vector()
			for (i in c(1:ncol(combitable)))
				{
				ind1		<- combitable[1,i]
				ind2		<- combitable[2,i]
				geno1		<- mymatrix[ind1,]
				geno2		<- mymatrix[ind2,]
				# To avoid that NA is included when stating geno==1, we change NA to 3:
				geno1[is.na(geno1)]	<- 3
				geno2[is.na(geno2)]	<- 3
				## we have 4 combinations of haplotypes between individuals: 
				## If both individuals are homozygous, but for different allele:
				mybool		<- (geno1==0&geno2==2)|(geno1==2&geno2==0)
				ndiff1		<- 4*length(mybool[mybool])
				# If one individual is homozygous and the other heterozygous:
				mybool		<- (geno1==0&geno2==1)|(geno1==2&geno2==1)|(geno1==1&geno2==0)|(geno1==1&geno2==2)
				ndiff2		<- 2*length(mybool[mybool])		
				# If both individuals are heterozygous: 
				mybool		<- geno1==1&geno2==1
				ndiff3		<- 2*length(mybool[mybool])
				## combine:
				ndiffvec[i]	<- ndiff1+ndiff2+ndiff3
				## datapoints:
				mybool		<- (geno1!=3)&(geno2!=3)
				ndata		<- length(mybool[mybool])
				ndatavec[i]	<- ndata
				mybool		<- (geno1==3)|(geno2==3)
				nna			<- 4*length(mybool[mybool])
				nnavec[i]	<- nna
				}
			## compare haplotypes within individuals (1 possible combination per individual:
			nhevec			<- vector() 
			ninddatavec		<- vector()
			nindnavec		<- vector()
			for (i in c(1:length(myinds)))
				{
				myind					<- myinds[i]
				mygeno					<- mymatrix[myind,]
				# To avoid that NA is included when stating mygeno==1, we change NA to 3:
				mygeno[is.na(mygeno)]	<- 3				
				nhevec[i]				<- length(mygeno[mygeno==1]) 
				ninddatavec[i]			<- length(mygeno[mygeno!=3]) 
				nindnavec[i]			<- length(mygeno[mygeno==3]) 
				}
			## store info in dataframe:
			mycomp1					<- as.data.frame(cbind(combitable[1,],combitable[2,],4,ndatavec,nnavec/4,ndatavec*4,nnavec,ndiffvec))
			colnames(mycomp1)		<- c("ind1","ind2","npairwise","nsites","nnasites","ncomp","nnacomp","ndiff")
			mycomp2					<- as.data.frame(cbind(myinds,myinds,1,ninddatavec,nindnavec,ninddatavec,nindnavec,nhevec))
			colnames(mycomp2)		<- c("ind1","ind2","npairwise","nsites","nnasites","ncomp","nnacomp","ndiff")
			mycomp					<- as.data.frame(rbind(mycomp2,mycomp1)) 
			mycomp$ndiffperhaplo	<- round(mycomp$ndiff/mycomp$npairwise,3)
			mycomp$ndiffpersite		<- mycomp$ndiffperhaplo/mycomp$nsites
			mycomp$ndiffpersite[!is.finite(mycomp$ndiffpersite)]	<- NA	
			mycomp$totalsites		<- mycomp$nsites+mycomp$nnasites
			mycomp$pop1				<- mypop
			mycomp$pop2				<- mypop
			mycomp$colour			<- mypopcol
			tajdlist[[p]]			<- mycomp
			# how many individuals (and therefore haplotypes) per snp on average? (Only individuals with non-missing data)
			popmatrix				<- mymatrix[myinds,]
			popmatrix				<<- popmatrix
			if(is.null(ncol(popmatrix)))
				{
				# counting NA is fine (counting 1's cause problems, because NA's are regarded 1s, but the other way around does not cause problems)
				nind		<- length(popmatrix[is.na(popmatrix)])
				}else{
				nind		<- mean(apply(popmatrix,2,function(x){sum(!is.na(x))}),na.rm=TRUE)
				}
			nhaplotypes		<- 2*nind
			# Number of (segregating) sites:
			nseg			<- length(mymaf[mymaf>0])
			nsitesall		<- length(mymaf)
			# Now we calculate observed pi, watterson's theta, and based on those two numbers Tajima's D:
			outmat[p,6]		<- round(mean(mycomp$nsites,na.rm=TRUE),1)		# nsites with data
			#outmat[p,7]	<- round(mean(mycomp$ndiffperhaplo,na.rm=TRUE),2)		# pi (mean number of differences between 2 sequences)
			uncorrected_pi<- round(mean(mycomp$ndiffperhaplo,na.rm=TRUE),2)
			corrected_pi	<- round(uncorrected_pi/nsitesall*outmat[p,6],2)
			outmat[p,7]		<- ifelse(corrected,corrected_pi,uncorrected_pi)
			outmat[p,10]	<- nseg											# segregating sites						
			outmat[p,8]		<- round(mean(mymaf[mymaf>0],na.rm=TRUE),2)		# mean maf of segregating sites
			outmat[p,9]		<- round((2*outmat[p,8]*(1-outmat[p,8])*outmat[p,10]),1)	# expected nucleotide diversity (pi) based on minor allele frequency
			outmat[p,11]	<- round(sum(1/(1:(nhaplotypes-1))),2)			# harmonic number
			outmat[p,12]	<- round(outmat[p,10]/outmat[p,11],2)			# watterson's theta
			outmat[p,13]	<- round(outmat[p,7]-outmat[p,12],2)			# tajima's d
			}
		}else{
		outmat$mean_nsites	<- 0
		}
	# add population names and colours:
	if(!pi_per_pop)
		{
		pop_names			<- mysambar$populations
		n_pops				<- length(pop_names)
		mycols				<- mysambar$mycolours[1:n_pops]
		pi_df				<- tajdlist[[1]]
		pi_df$pop1 			<- NA
		pi_df$pop2 			<- NA
		pi_df$colour		<- NA
		for (i in c(1:nrow(pi_df)))
			{
			myindnr1			<- pi_df$ind1[i]
			myindnr2			<- pi_df$ind2[i]
			if(n_pops>1)
				{
				pop1			<- as.vector(inds$pop)[inds$nr==myindnr1]
				pop2			<- as.vector(inds$pop)[inds$nr==myindnr2]
				pi_df$pop1[i]	<- pop1
				pi_df$pop2[i]	<- pop2
				mycol1			<- mycols[which(pop_names==pop1)]
				mycol2			<- mycols[which(pop_names==pop2)]
				mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
				pi_df$colour[i]	<- mycolfunc3(3)[2]
				}else{
				pi_df$colour[i]	<- mycols	
				}
			}
		tajdlist[[1]]	<- pi_df 
		}
	# output tajdlist:
	names(tajdlist)			<- popnames
	if(pi_per_pop)
		{
		mysambar$tajdlist_pop	<<- tajdlist
		}else{
		mysambar$tajdlist_meta	<<- tajdlist		
		}
	outmat$pi_scaled		<- outmat$mean_pi/outmat$mean_nsites
	outmat$Watterson_scaled	<- outmat$Watterson/outmat$mean_nsites
	outmat$TajimaD_scaled	<- outmat$TajimaD/outmat$mean_nsites
	outmat$rare_alleles		<- ifelse(outmat$TajimaD< -2,"many_rare",ifelse(outmat$TajimaD>2,"lack_of_rare","neutral"))
	outmat$demography		<- ifelse(outmat$TajimaD< -2,"expansion_after_bottleneck",ifelse(outmat$TajimaD>2,"contraction","neutral"))
	outmat$selection		<- ifelse(outmat$TajimaD< -2,"selective_sweep",ifelse(outmat$TajimaD>2,"balancing","neutral"))	
	if(!is.null(mychrom)&!is.null(myrange))	{tajd			<<- outmat}
	if(!is.null(mychrom)&is.null(myrange))	{tajd			<<- outmat[,c(1,2,6:19)]}	
	if(is.null(mychrom)&is.null(myrange))	{tajd			<<- outmat[,c(1,6:19)]}	
	if(pi_per_pop)
		{
		write.table(tajd,paste(mysambar$diversitydir,"TajimaD.statistics.perpop.txt",sep="/"),col.names=TRUE,quote=FALSE,row.names=FALSE,sep="\t")
		}else{
		write.table(tajd,paste(mysambar$diversitydir,"TajimaD.statistics.metapop.txt",sep="/"),col.names=TRUE,quote=FALSE,row.names=FALSE,sep="\t")
		}
	if(!silent)
		{
		cat("Summary table has been written to a dataframe called tajd.",sep="\n")
		cat("All scores for comparisons within and between individuals has been written to a list called tajdlist.",sep="\n")
		}
	if(pi_per_pop)
		{
		myinds							<- inds$nr[inds$filter]
		nsnps							<- nrow(snps)
		ninds							<- nrow(inds[inds$filter,])
		inds$hetero_all2				<<- NA
		# add data heterozygosity to inds dataframe:
		for(i in c(1:ninds))
			{
			myind								<- myinds[i]
			mypop								<- inds$pop[inds$nr==myind]	
			pidf								<- mysambar$tajdlist_pop[[which(names(mysambar$tajdlist_pop)==mypop)]]
			inds$hetero_all2[inds$nr==myind]	<<- pidf$ndiffpersite[pidf$ind1==myind&pidf$ind2==myind]
			}
		# add data pi to inds dataframe:
		inds$pi						<<- NA 
		for(i in c(1:ninds))
			{
			myind						<- myinds[i]
			mypop						<- inds$pop[inds$nr==myind]	
			npoly						<- inds$nsegsites1[inds$nr==myind]
			pidf						<- mysambar$tajdlist_pop[[which(names(mysambar$tajdlist_pop)==mypop)]]
			inds$pi[inds$nr==myind]	<<- mean(pidf$ndiffpersite[(pidf$ind1==myind|pidf$ind2==myind)&!(pidf$ind1==myind&pidf$ind2==myind)],na.rm=TRUE)
			}
		# add autozygosity to inds dataframe:
		inds$autozygosity				<<- inds$hetero_all/inds$pi 
		# add TajimaD scores:
		inds$pi2					<- NA
		inds$harmonic_number		<- NA
		inds$Watterson				<- NA
		inds$TajimaD				<- NA
		inds$pi2_scaled			<- NA
		inds$Watterson_scaled		<- NA
		inds$TajimaD				<- NA
		inds$rare_alleles			<- NA
		for (mypop in popnames)
			{
			myselection							<- inds$filter&inds$pop==mypop
			inds$pi2[myselection]			<- tajd$mean_pi[tajd$pop==mypop]
			inds$harmonic_number[myselection]	<- tajd$harmonic_number[tajd$pop==mypop]
			inds$Watterson[myselection]			<- tajd$Watterson[tajd$pop==mypop]
			inds$TajimaD[myselection]			<- tajd$TajimaD[tajd$pop==mypop]
			inds$pi2_scaled[myselection]		<- tajd$pi_scaled[tajd$pop==mypop]
			inds$Watterson_scaled[myselection]	<- tajd$Watterson_scaled[tajd$pop==mypop]
			inds$TajimaD_scaled[myselection]	<- tajd$TajimaD_scaled[tajd$pop==mypop]
			inds$rare_alleles[myselection]		<- tajd$rare_alleles[tajd$pop==mypop]
			}
		}
	# 
	# remove duplicate columns		
	inds 							<<- inds[, !duplicated(colnames(inds),fromlast=TRUE)]
	}	

#get genome wide heterozygosity and pi:
getgenomepi<-function(nsites=NULL,nsnps=NULL)
	{
	if(is.null(nsites))
		{
		cat("Warning: you did not provide the total number of sequenced sites to the nsites argument.",sep="\n")
		cat("As a result, SambaR will not calculate genome wide estimates.",sep="\n") 
		cat("Instead, the columns 'genomehe' and 'genomepi' are set to NA.",sep="\n")
		inds$genomepi			<<- NA
		inds$genomehe				<<-	NA
		}else{
		if(is.null(nsnps))
			{
			n_snps					<- inds$nsegsites4		# 08072019: instead of: nrow(snps)
			}else{
			n_snps					<- nsnps
			}
		inds$genomepi			<<- inds$pi*n_snps/nsites
		inds$genomehe				<<-	inds$hetero_all*n_snps/nsites
		# Two possibilities:
		# genomepi				<<- (pi * length(snps[i,]))/allsites
		# genomepi2				<<- (pi * length(snps[i,snps$popmaf>0]))/allsites
		# You could argue in favour of both, but I got the impression genomepi gives me more credible estimates than genomepi2, so I went with genomepi.
		}
	}

# old version (which calculates pi based on a sample of individuals (4) rather than all individuals):	
getpi<-function(nsites=NULL,nsample=4,popnames=mysambar$populations)
	{
	# This function calculates pi: the average number of variant sites when randomly drawing 2 sequences from a population.
	# We calculate two versions:
	# pi						(hetero * length(snps[i,]))/allsites
	# pi2					(hetero * length(snps[i,snps$popmaf>0]))/allsites
	# You could argue in favour of both, but I think pi gives me more credible estimates than pi2.
	if(is.null(nsites))
		{
		return(cat("ERROR: you need to provide the total number of sequenced sites to the nsites argument.",sep="\n"))
		}
	# Create matrix
	nsnps					<- nrow(snps)
	npops					<- length(popnames)
	for(j in c(1:npops))
		{
		mypop				<- popnames[j]
		myinds				<- inds$nr[inds$pop2==mypop]
		ninds				<- length(myinds)
		for (i in c(1:ninds))
			{
			myind1			<- myinds[i]
			myind2			<- rep(myind1,nsample)
			otherinds1		<- inds$nr[inds$pop2==mypop&inds$filter]
			otherinds2		<- otherinds1[!(otherinds1 == myind1)]
			otherinds3		<- sample(otherinds2,nsample,replace=FALSE)
			combitabletemp	<- rbind(myind2,otherinds3)
			if(i==1&&j==1)
				{
				combitable	<- combitabletemp
				}else{
				combitable	<- cbind(combitable,combitabletemp)
				}
			}
		}
	npairs					<- ncol(combitable)
	mydiffmatrix			<<- as.data.frame(matrix(NA,nrow=npairs,ncol=9))
	colnames(mydiffmatrix)	<<- c("ind1","ind2","pop1","pop2","diff","nsites","allsites","pi","pi2")
	# to find number of clusters, maybe try the R package modes?
	# modes(data,nmore=2)[1,][rev(order(modes(data,nmore=2)[2,]))]
	for (i in c(1:npairs))
		{
		# cat(paste(i,"out of",npairs,"pairwise comparisons",sep =" "),sep="\n")
		myind1				<- combitable[1,i]
		myind2				<- combitable[2,i]
		mygeno				<- as.matrix(mygenlight[inds$nr==myind1|inds$nr==myind2,snps$filter])
		genosum				<- !is.na(colSums(mygeno))
		ngeno				<- length(genosum[genosum])
		ndiff				<- vector() 
		for (j in c(1:ncol(mygeno)))
			{
			geno1			<- mygeno[1,j]
			geno2			<- mygeno[2,j]
			ndiff[j]		<- ifelse((!genosum[j]),0,ifelse(((geno1==0&&geno2==0)||(geno1==2&&geno2==2)),0,ifelse((geno1==0&&geno2==2)||(geno1==2&&geno2==0),1,0.5)))
			}
		mymeandiff			<- round((sum(ndiff,na.rm=TRUE)/ngeno),3)
		npoly				<- inds$nsegsites1[inds$nr==myind1]
		mydiffmatrix[i,1]	<<- myind1
		mydiffmatrix[i,2]	<<- myind2
		mydiffmatrix[i,3]	<<- inds$pop2[inds$nr==myind1]
		mydiffmatrix[i,4]	<<- inds$pop2[inds$nr==myind2]
		mydiffmatrix[i,5]	<<- mymeandiff
		mydiffmatrix[i,6]	<<- ngeno
		mydiffmatrix[i,7]	<<- nsites
		mydiffmatrix[i,8]	<<- mymeandiff*nsnps/nsites	
		mydiffmatrix[i,9]	<<- mymeandiff*npoly/nsites	
		# you might wonder: why not multiply with ngeno rather than nsnps? 
		# ngeno is nsnps - nmissing		# with nmissing being number of missing data points
		# missing data points are not considered in calculation (as we divide by ngeno, and as non missing data points are set to 0)																
		# so meandiff is truly the probability of heterozygous site if you compare two 2 randomly drawn sequences (after all: it is an average, not a sum) 
		# this is the probability over the entire snp data set (polymorphic sites in retained reads)
		# we want to rescale to all sites (also non-polymorphic sites in retained reads)  
		# hence we multiply with nsnps (and more specifically: all polymorphic sites, also the ones which don't meet filter criteria)									 
		}
	pitemp				<- aggregate(mydiffmatrix$pi,list(mydiffmatrix$ind1),mean)
	colnames(pitemp)		<- c("nr","pi")
	pitemp2				<- aggregate(mydiffmatrix$pi2,list(mydiffmatrix$ind1),mean)
	colnames(pitemp2)	<- c("nr","pi")
	inds$pi				<<- pitemp$pi
	# inds$pi2			<<- pitemp2$pi
	inds$autozygosity		<<- inds$genomehe/inds$pi
	}
	
plotpi_vs_he<-function(export=NULL,mycolours=mysambar$mycolours,popnames=mysambar$populations,adddiscarded=FALSE)
	{	
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("he_vs_pi.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("he_vs_pi.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("he_vs_pi.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("he_vs_pi.wmf",family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=2.5)	
	mymin					<- 0.95*100*min(c(min(inds$genomepi[inds$filter],min(inds$genomehe[inds$filter]))))
	mymax					<- 1.05*100*max(c(max(inds$genomepi[inds$filter],max(inds$genomehe[inds$filter]))))
	mypi					<- inds$genomepi*100
	mygenomehe				<- inds$genomehe*100
	plot(mypi[inds$filter],mygenomehe[inds$filter],xlim=c(mymin,mymax),ylim=c(mymin,mymax),xlab="Nucleotide diversity (%)",ylab="Genome wide heterozygosity (%)",cex=2,col="white")
	npops					<- length(popnames)
	mycolours				<- mycolours[1:npops]
	for (j in c(1:npops))
		{
		mypop				<- popnames[j]
		points(mypi[inds$pop2==mypop&inds$filter],mygenomehe[inds$pop2==mypop&inds$filter],col=mycolours[j],pch=16,cex=2)
		if(adddiscarded)
			{
			points(mypi[inds$pop2==mypop&!inds$filter],mygenomehe[inds$pop2==mypop&!inds$filter],col=mycolours[j],cex=2)
			}
		}
	lines(c(0,1),c(0,1))
	if(!is.null(export)){dev.off()}
	# boxplot(inds$autozygosity[inds$filter]~inds$pop2[inds$filter])
	}	
	
# requires package vioplot
plotsampleHe<-function(popnames=mysambar$populations,yrange=c(0,0.55),yrange2=c(0.0005,0.0025),mycolours=mysambar$mycolours,shortpop=NULL,allsites=FALSE)
	{
	if(is.null(shortpop))
		{
		shortpop<-substr(popnames,1,2)
		}
	x 			<- rnorm(100)
	y 			<- rnorm(100)
	npop		<- length(popnames)
	mycolours	<- mycolours[1:npop]
	if(allsites)
		{
		#cat("You have set nsites=TRUE. Plot will show genome wide heterozygosity (inds$genomehe) which you calculated when setting nsites=TRUE with the function 'pophetero'.",sep="\n")
		#myyrange <- yrange2	# 21052019: flag 'yrange2' can probably be removed
		myyrange <- c(min(inds$genomehe[inds$filter]),max(inds$genomehe[inds$filter]))
		}else{
		#myyrange <- yrange		# 21052019: flag 'yrange' can probably be removed
		myyrange <- c(min(inds$hetero[inds$filter]),max(inds$hetero[inds$filter]))
		}	
	plot(x, y, xlim=c(0.5,npop+0.5),ylim=myyrange,col="white",xaxt="n",xlab="",ylab="")	
	par(cex.axis=2.5,cex.lab=3,cex.main=3.5)
	for (i in c(1:npop))
		{
		mypop			<- popnames[i]
		if(allsites)
			{
			myhetero	<- inds$genomehe[inds$pop2==mypop&inds$filter]
			}else{
			myhetero	<- inds$hetero[inds$pop2==mypop&inds$filter]
			}
		vioplot(myhetero,at=i,add=TRUE,names=popnames[i],col=mycolours[i])
		}
	axis(side=1,at=seq(1,npop),labels=shortpop,lty=1,las=1)
	# mtext("Population",1,line=2.5,cex=1.25)
	mtext("Proportion of heterozygote sites",2,line=3.5,cex=2.5)
	if(allsites)
		{
		mtext("For all sites",3,line=-2.5,cex=2)
		}else{
		mtext("For segregating sites only",3,line=-2.5,cex=2)
		}
	}

# This function uses the plotsampleHe function
plotgenomehe<-function(popnames=mysambar$populations,shortpop=NULL,nsites=NULL,nsegsites=NULL,mycolours=mysambar$mycolours,export=NULL,dofilter=FALSE)
	{
	npops		<- length(popnames)
	mycolours	<- mycolours[1:npops]
	if(is.null(shortpop))
		{
		shortpop<- substr(popnames,1,2)
		}
	# derive proportion of segregating sites:
	if(is.null(nsegsites))
		{
		indstemp	<- inds[,c("pop2","nsegsites3")]
		aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop2),FUN=mean, na.rm=TRUE)
		myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
		}else{
		if(length(nsegsites)!=npops)
			{		
			return(cat("The length of vector input to nsegsites does not equal the number of populations",sep="\n"))
			}else{
			myseg		<- nsegsites			
			}
		}
	if(is.null(nsites))
		{
		indstemp	<- inds[,c("pop2","allseqsites")]
		aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop2),FUN=mean, na.rm=TRUE)
		allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
		myseg		<- myseg/allsites
		}else{
		myseg		<- myseg/nsites
		}
	# Plot:
	if(!is.null(export))
		{
		if(export=="eps"){postscript("pi.pop.eps",family=mysambar$myfont,width=25,height=10)}
		if(export=="pdf"){pdf("pi.pop.pdf",family=mysambar$myfont,width=25,height=10)}
		if(export=="png"){png("pi.pop.png",family=mysambar$myfont,width=1800,height=720)}
		if(export=="wmf"){win.metafile("pi.pop.wmf",family=mysambar$myfont,width=25,height=10)}
		}
	par(mfrow=c(1,3),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	# layout(matrix(c(1,2,3),1,3))
	# Plot proportion of segregating sites:
	xx<-barplot(myseg,names.arg=shortpop,col=mycolours,ylab=NULL,ylim=c(0,max(myseg)+1/10*max(myseg)),xpd = FALSE)
	text(x = xx, y = myseg,label=round(myseg,4),pos=3,cex=2.5,col="black")
	mtext("Proportion of segregating sites",side=2,line=3.5,cex=2.5)
	# Plot he for segregating sites:
	plotsampleHe(allsites=FALSE)
	# Plot pi:
	plotsampleHe(allsites=TRUE)
	mtext("Nucleotide diversity",3,line=-3.5,cex=3,outer=TRUE)
	mtext("Population",1,line=-1.5,cex=2.5,outer=TRUE)
	if(!is.null(export)){dev.off()}
	}

# summary statistics:
# 19032019: is this table still correct? Why NA for S?
popstats<-function(popnames=mysambar$populations,nsites=NULL)
	{
	npops				<- length(popnames)
	mystats				<- as.data.frame(matrix(NA,nrow=npops+1,ncol=14))
	colnames(mystats)	<- c("pop","n","maf_all","ho_all","he_all","F_all","perc_He_deficit","perc_He_surplus","maf_seg","ho_seg","he_seg","F_seg","S","genomehe")
	mystats$pop[1]		<- "Metapop"
	mystats$n[1]		<- nrow(inds[inds$filter,])
	mystats$maf_all[1]	<- round(mean(inds$maf_all[inds$filter]),3)  
	mystats$ho_all[1]	<- round(mean(inds$hetero_all[inds$filter]),3)  
	mystats$he_all[1]	<- round(mean(inds$expHe_all[inds$filter]),3)  
	mystats$F_all[1]	<- round(mean(inds$F_all[inds$filter]),3) 
	mystats$perc_He_deficit[1]<-hwetable[1,3]
	mystats$perc_He_surplus[1]<-hwetable[1,4]
	mystats$maf_seg[1]	<- round(mean(inds$maf[inds$filter]),3)  
	mystats$ho_seg[1]	<- round(mean(inds$hetero[inds$filter]),3) 
	mystats$he_seg[1]	<- round(mean(inds$expHe[inds$filter]),3) 
	mystats$F_seg[1]	<- round(mean(inds$F[inds$filter]),3)  
	myvector			<- snps$maf
	nsegsites			<- length(myvector[myvector>0])
	if(!is.null(nsites))
		{
		if(length(nsites)==1)
			{
			mystats$S[1]		<- round(nsegsites/nsites,4)
			}else{
			mystats$S[1]		<- round(nsegsites/max(nsites),4)
			}
		mystats$genomehe[1]	<- round(mean(inds$genomehe),4)
		}else{
		mystats$S[1]			<- NA
		mystats$genomehe[1]		<- NA
		}
	for (i in c(1:npops))
		{
		mypop				<- popnames[i]
		mystats$pop[i+1]	<- mypop
		mystats$n[i+1]		<- nrow(inds[inds$filter&inds$pop2==mypop,])
		mystats$maf_all[i+1]<- round(mean(inds$maf_all[inds$filter&inds$pop2==mypop]),3)  
		mystats$ho_all[i+1]	<- round(mean(inds$hetero_all[inds$filter&inds$pop2==mypop]),3)  
		mystats$he_all[i+1]	<- round(mean(inds$expHe_all[inds$filter&inds$pop2==mypop]),3)  
		mystats$F_all[i+1]	<- round(mean(inds$F_all[inds$filter&inds$pop2==mypop]),3)
		mystats$perc_He_deficit[i+1]<-hwetable[i+1,3]
		mystats$perc_He_surplus[i+1]<-hwetable[i+1,4]	
		mystats$maf_seg[i+1]<- round(mean(inds$maf[inds$filter&inds$pop2==mypop]),3)  
		mystats$ho_seg[i+1]	<- round(mean(inds$hetero[inds$filter&inds$pop2==mypop]),3) 
		mystats$he_seg[i+1]	<- round(mean(inds$expHe[inds$filter&inds$pop2==mypop]),3) 
		mystats$F_seg[i+1]	<- round(mean(inds$F[inds$filter&inds$pop2==mypop]),3)  
		myvector			<- snps[,names(snps) == paste("maf",mypop,sep="_")]
		nsegsites			<- length(myvector[myvector>0])
		if(!is.null(nsites))
			{
			if(length(nsites)==1)
				{
				mystats$S[i+1]			<- round(nsegsites/nsites,4)
				}else{
				mystats$S[i+1]			<- round(nsegsites/nsites[i],4)
				}
			mystats$genomehe[i+1]	<- round(mean(inds$genomehe[inds$filter&inds$pop2==mypop]),4) 
			}else{
			mystats$S[i+1]			<- NA
			mystats$genomehe[i+1]	<- NA
			}
		} 
	mystats	<- t(mystats)
	write.table(mystats,"SambaR.popdiversity.stats.txt",row.names=TRUE,col.names=FALSE,quote=FALSE,sep="\t")
	}

plotstats<-function(myfilter=inds$filter,popnames=mysambar$populations)
	{
	layout(matrix(c(1:8),4,2,byrow=FALSE))
	par(mar=c(2,4.0,0.5,0.5),oma=c(3,2,2,2))
	# segregating sites only:
	boxplot(maf[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="MAF",xlab="Population",main="Segregating sites only")
	boxplot(hetero[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="Ho",xlab="Population")
	boxplot(expHe[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="He",xlab="Population")
	boxplot(F[myfilter]~pop[myfilter],data=inds,frame.plot=F,notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="F (1-Ho/He)",xlab="Population",names=popnames)
	# all sites:
	boxplot(maf_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population",names=rep("",length(popnames)),main="All sites")
	boxplot(hetero_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population")
	boxplot(expHe_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population")
	boxplot(F_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population",names=popnames)
	mtext("Population",side=1,line=1,outer=TRUE)
	}

getfoldedsfs<-function(popnames=mysambar$populations,histo=FALSE,yrange=c(0,nrow(snps)/4),dofilter=FALSE)
	{
	foldedsfs		<- list()
	misscount		<- glNA(mygenlight[inds$filter,],alleleAsUnit=FALSE)
	nonmissallelecount 	<- 2*(nInd(mygenlight[inds$filter,])-misscount)
	mymac			<- as.vector(glSum(mygenlight[inds$filter,]))
	mymac			<- ifelse(mymac>0.5*nonmissallelecount,nonmissallelecount-mymac,mymac)
	if(histo)
		{
		graphics.off()
		par(mfrow=c(1,length(popnames)+1))
		hist(mymac[mymac!=0],ylim=yrange,main="Metapop",xlab=NULL,breaks=seq(0,nrow(inds[inds$filter,]),1))
		}
	nind			<- nrow(inds[inds$filter,])
	if(dofilter)
		{
		mymac		<- mymac[snps$filter]
		}
	myindnr				<- c(1:nind)
	temp1				<- vector()
	for (j in myindnr)
		{
		temp1[j]		<- length(which(mymac==j))
		}
	foldedsfs[[1]]		<- temp1
	if(length(temp1)!=nind)
		{
		cat("WARNING: Length of the SFS-vector does not equal the number of retained individuals in the overall dataset. Contact developer of SambaR.",sep="\n")
		}
	for (i in (1:length(popnames)))
		{
		nind				<- nrow(inds[inds$filter&inds$pop2==popnames[i],])
		misscount			<- glNA(mygenlight[inds$filter&inds$pop2==popnames[i],],alleleAsUnit=FALSE)
		nonmissallelecount 	<- 2*(nInd(mygenlight[inds$filter&inds$pop2==popnames[i],])-misscount)
		snps$mactemp		<<- as.vector(glSum(mygenlight[inds$filter&inds$pop2==popnames[i],]))
		snps$mactemp		<<- ifelse(snps$mactemp>0.5*nonmissallelecount,nonmissallelecount-snps$mactemp,snps$mactemp)
		if(histo)
			{
			hist(snps$mactemp[snps$mactemp!=0],ylim=yrange,main = popnames[i],xlab=NULL,breaks=seq(0,nrow(inds[inds$filter&inds$pop2==popnames[i],]),1))
			}
		myindnr				<- c(1:nind)
		if(dofilter)
			{
			mymac			<- snps$mactemp[snps$filter]
			}else{
			mymac			<- snps$mactemp
			}
		temp1				<- vector()
		for (j in myindnr)
			{
			temp1[j]		<- length(which(mymac==j))
			}
		foldedsfs[[i+1]]	<- temp1
		#write.table(temp1,file=paste("SFSvector",popnames[i],"txt",sep="."),sep="\n",quote=FALSE,col.names=FALSE,row.names=FALSE)
		cat(temp1,file=paste("SFSvector",popnames[i],"txt",sep="."),sep=" ")
		names(snps)[names(snps) == "mactemp"] <<- paste("mac",popnames[i],sep = "_")
		if(length(temp1)!=nind)
			{
			cat(paste("WARNING: Length of the SFS-vector does not equal the number of retained individuals in ",popnames[i],". Contact developer of SambaR.",sep=""),sep="\n")
			}
		}
	snps 				<<- snps[, !duplicated(colnames(snps),fromlast=TRUE)]
	names(foldedsfs)	<- c("Metapop",popnames) 
	# cat("Site Frequency Spectrum per population (i.e. number of zerotons, singletons, doubletons, etc, of the minor allele)",sep="\n")
	foldedsfstable		<<- foldedsfs
	}

barplotsfs<-function(popnames=mysambar$populations,export=NULL)
	{
	npops	<- length(popnames)
	maxn	<- lengths(foldedsfstable[-1])[which(lengths(foldedsfstable[-1])==max(lengths(foldedsfstable[-1])))]
	if(!exists("foldedsfstable"))
		{
		return(cat("ERROR: Object 'foldedsfstable' missing. Please first (re)run getfoldedsfs() function.",sep="\n"))
		}
	if(npops+1!=length(foldedsfstable))
		{
		return(cat("ERROR: Unexpected number of populations in 'foldedsfstable' object. Please first (re)run getfoldedsfs() function.",sep="\n"))
		}
	graphics.off()
	if(!is.null(export))
		{
		myheight	<- 8
		myheight2	<- 1000
		mywidth		<- 7
		mywidth2	<- 700
		if(export=="eps"){postscript("SFSbarplot.eps",family=mysambar$myfont,width=mywidth*npops+2,height=myheight)}
		if(export=="pdf"){pdf("SFSbarplot.pdf",family=mysambar$myfont,width=mywidth*npops+2,height=myheight)}
		if(export=="png"){png("SFSbarplot.png",family=mysambar$myfont,width=mywidth2*npops+200,height=myheight2)}
		if(export=="wmf"){win.metafile("SFSbarplot.wmf",family=mysambar$myfont,width=mywidth*npops+2,height=myheight)}
		}
	par(mfrow=c(1,npops),mar=c(2,4.0,0.5,0.5),oma=c(5,5.5,2,2),cex.axis=2.5)
	mymax	<- max(unlist(foldedsfstable[-1]))
	for (i in (1:npops))
		{
		mypop	<- popnames[i]
		mysfs	<<- unlist(foldedsfstable[names(foldedsfstable)==mypop])
		ninds	<- length(mysfs)
		if(ninds<35)
			{
			barplot(mysfs,col=mysambar$mycolours[i],border=NA,names.arg=c(1:ninds),las=2,ylim=c(0,mymax))
			}else{
			barplot(mysfs,col=mysambar$mycolours[i],border=NA,names.arg=NA,las=2,ylim=c(0,mymax))
			}
		mtext(mypop,side=3,line=-3.5,cex=2)
		if(i==1){mtext("Number of sites",side=2,line=6.5,cex=2.5)}
		}
	mtext("Number of minor allele copies",side=1,line=3.5,cex=2.5,outer=TRUE)
	if(!is.null(export)){dev.off()}	
	}
	
### SFS ###
extractmafdata<-function(mypops=mysambar$populations)
	{
	npops		<- length(mypops)
	for(j in c(1:npops))
		{
		mypop			<- mypops[j]
		maftemp			<- snps[,c(paste("maf2",mypop,sep="_"),"filter")]
		colnames(maftemp)<- c("maf","filter")
		maftemp$species	<- mypop
		if(j==1)
			{
			mymaf		<- maftemp
			}else{
			mymaf		<- rbind(mymaf,maftemp) 
			}
		}
	return(mymaf)
	}

nonshared_plots<-function()
	{
	# SFS:
	cat("Generating sfs plot...",sep="\n")
	mysfstable			<- read.table(paste(mysambar$diversitydir,"SFS.binned.percentages_nonsharedsnps.txt",sep="/"),header=TRUE)
	mysfstable			<- as.matrix(mysfstable)
	plotsfs(mafbincounts=mysfstable,export="pdf",nsites=c(5607250,8196980,8196980,8196980),nsegsites=c(29396,33236,25439,46110),addbarplot=TRUE)
	plotsfs(mafbincounts=mysfstable,export="pdf",nsites=c(5607250,8196980,8196980,8196980),nsegsites=c(29396,33236,25439,46110),addbarplot=FALSE)
	plotsfs(mafbincounts=mysfstable,export="pdf",nsites=c(5607250,8196980,8196980,8196980),nsegsites=c(29396,33236,25439,46110),addbarplot=TRUE,addlegend=FALSE)
	plotsfs(mafbincounts=mysfstable,export="pdf",nsites=c(5607250,8196980,8196980,8196980),nsegsites=c(29396,33236,25439,46110),addbarplot=FALSE,addlegend=FALSE)
	# Tajima's D:
	cat("Generating Tajima's D plot...",sep="\n")
	mytajdtable			<- read.table(paste(mysambar$diversitydir,"TajimaD.statistics.perpop_nonsharedsnps.txt",sep="/"),header=TRUE)
	mytable				<- mytajdtable[,c(2:ncol(mytajdtable))]
	plottajd(tajdtable=mytable,export=TRUE,insetbarplot=TRUE)
	plottajd(tajdtable=mytable,export=TRUE,insetbarplot=FALSE)
	plottajd(tajdtable=mytable,export=TRUE,insetbarplot=TRUE,genome_wide=TRUE,nsites=c(5607250,8196980,8196980,8196980),nsegsites=c(29396,33236,25439,46110))
	plottajd(tajdtable=mytable,export=TRUE,insetbarplot=FALSE,genome_wide=TRUE,nsites=c(5607250,8196980,8196980,8196980),nsegsites=c(29396,33236,25439,46110))
	cat("Generation Fis-plots...",sep="\n")
	myfvalues2	<- roefrance$snps[roefrance$snps$filter,paste("F",roefrance$populations,sep="_")]
	myfvalues1	<- roemain$snps[roemain$snps$filter,paste("F",roemain$populations,sep="_")]
	myfvalues1	<- myfvalues1[1:length(myfvalues2),]
	myfvals		<- cbind(myfvalues2,myfvalues1)
	names(myfvals)[1]	<- "F_Aurignac"
	myfvals		<- myfvals[,order(colnames(myfvals))]
	plot_F(export=TRUE,popnames=mysambar$populations,addlabels=TRUE,myfvalues=myfvals)
	}
	
# this function expects output produced by 'getfoldedsfs'-function, and maf2 column, generated by getpopmaf-function.
plotsfs<-function(nbins=5,mafbincounts=NULL,addbarplot=FALSE,mypops=mysambar$populations,nsites=NULL,nsegsites=NULL,export=NULL,shortpop=NULL,mycolours=mysambar$mycolours,silent=FALSE,legendcex=2.5,addlegend=TRUE)
	{
	# You can choose to provide to the mafbincounts argument, a table from which SFS plot will be drawn.
	# This should be a matrix with npop rows and 5 columns with percentages of number of snps in maf bins 0-0.1,0.1-0.2,0.2-0.3,0.3-0.4,0.4-0.5
	# If not provided (default), this function will generate this table.  
	if(is.null(shortpop))
		{
		shortpop<-substr(mypops,1,2)
		}
	npops		<- length(mypops)
	mycolours	<- mysambar$mycolours[1:npops]
	### SFS ###
	if(is.null(mafbincounts))
		{
		mymaf			<- extractmafdata()
		temp1			<- mymaf
		colnames(mymaf)	<- c("maf","filter","species")
		mymaf			<- mymaf[mymaf$maf!=0,]
		if(nbins==5)
			{
			mylabels		<- seq(0.05,0.45,0.1)
			mymaf$binned	<- cut(mymaf$maf,5, include.lowest=TRUE,labels=mylabels)
			}
		if(nbins==10)
			{
			mylabels		<- seq(0.025,0.475,0.05)
			mymaf$binned	<- cut(mymaf$maf,10, include.lowest=TRUE,labels=mylabels)
			}
		mymafcounts 	<- table(mymaf$species,mymaf$binned)
		# restore order (to order of populations vector):
		temp1			<- rownames(mymafcounts)
		temp2			<- match(temp1,mypops)
		mymafcounts		<- mymafcounts[order(temp1),] 
		write.table(mymafcounts,"SFS.binned.counts.txt",sep="\t",quote=FALSE)
		mypops			<- mypops[temp2]	
		mycolours		<- mycolours[temp2]	
		if(npops==1)
			{
			write.table(mymafcounts,"SFS.binned.counts.txt",sep="\t",quote=FALSE,col.names=FALSE)
			mymafcounts		<-  mymafcounts/sum(mymafcounts)*100
			write.table(mymafcounts,"SFS.binned.percentages.txt",sep="\t",quote=FALSE,col.names=FALSE)
			}else{
			write.table(mymafcounts,"SFS.binned.counts.txt",sep="\t",quote=FALSE)
			for(j in c(1:length(mypops)))
				{
				mymafcounts[j,]	<- mymafcounts[j,]/sum(mymafcounts[j,])*100
				}
			write.table(mymafcounts,"SFS.binned.percentages.txt",sep="\t",quote=FALSE)
			}
		}else{
		mymafcounts		<- mafbincounts
		mylabels		<- seq(0.05,0.45,0.1)
		}
	### SEGREGATING SITES ###
	if(addbarplot)
		{
		if(is.null(nsegsites))
			{
			indstemp	<- inds[,c("pop2","nsegsites3")]
			aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop2),FUN=mean, na.rm=TRUE)
			myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
			}else{
			if(length(nsegsites)!=npops)
				{		
				return(cat("The length of vector input to nsegsites does not equal the number of populations",sep="\n"))
				}else{
				myseg		<- nsegsites			
				}
			}
		if(is.null(nsites))
			{
			indstemp	<- inds[,c("pop2","allseqsites")]
			aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop2),FUN=mean, na.rm=TRUE)
			allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
			myseg		<- myseg/allsites
			}else{
			myseg		<- 100*myseg/nsites
			}
		}
	### PLOT ###
	graphics.off()
	if(!is.null(export))
		{
		mywidth		<- ifelse(addbarplot,12,10)
		mystring	<- ifelse(addbarplot,ifelse(addlegend,"with_barplot","with_barplot.no_legend"),ifelse(addlegend,"no_barplot","no_barplot.no_legend"))
		if(export=="eps"){postscript(paste("SFS.binned",mystring,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		if(export=="pdf"){pdf(paste("SFS.binned",mystring,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		if(export=="png"){png(paste("SFS.binned",mystring,"png",sep="."),family=mysambar$myfont,width=864,height=720)}
		if(export=="wmf"){win.metafile(paste("SFS.binned",mystring,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		}
	if(addbarplot)
		{
		layout(matrix(c(1,1,1,1,1,2,2,2),1,8))
		par(mar=c(4,7,0.5,2),oma=c(5,4,4,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		}else{
		par(mar=c(4,6,0.5,2),oma=c(5,4,4,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		}
	# SFS:
	if(npops>1)
		{
		plot(as.vector(mymafcounts[1,]),log="x",type="b",col="white",lwd=4,ann=FALSE,xaxt="n",xlab=NULL,ylab=NULL,ylim=c(0,max(mymafcounts)),las=1)
		for(j in c(1:length(mypops)))
			{
			mypop	<- mypops[j]
			npopinds<- nrow(inds[inds$filter&inds$pop2==mypop,])
			#cat(mypop,sep="\n")
			#cat(npopinds,sep="\n")
			if(npopinds<5)
				{
				cat(paste("Less than 5 individuals in",mypop,"population. Excluded from plot, because snps with maf<0.1 will be underrepresented."),sep="\n")
				}else{
				points(as.vector(mymafcounts[j,]),type="b",col=mycolours[j],lwd=4)
				}
			}
		if(addlegend)
			{
			legend("topright",legend=mypops,fill=mycolours,box.lty=0,cex=legendcex)
			}
		}else{
		plot(as.vector(mymafcounts),log="x",type="b",col=mycolours[1],lwd=4,ann=FALSE,xaxt="n",xlab=NULL,ylab=NULL,ylim=c(0,max(mymafcounts)),las=1)
		}
	axis(side=1, at=seq(1,length(mylabels),1), labels=mylabels,las=2)
	mtext("MAF class midpoint",side=1,line=7.5,cex=2.5)
	mtext("Polymorphic sites (%)",side=2,line=4.5,cex=2.5)
	mtext("Folded SFS",side=3,line=0.5,cex=2.5)
	# SEGREGATING SITES:
	if(addbarplot)
		{
		# Segregating sites:
		xx<-barplot(myseg,names.arg=shortpop,col=mycolours,las=2,ylab=NULL,ylim=c(0,max(myseg)+0.05),cex.names=3)
		text(x = xx, y = myseg,label=round(myseg,2),pos=3,cex=2.5,col="black")
		mtext("Segregating sites (%)",side=2,line=5.75,cex=2.5)
		}else{
		if(!silent)
			{
			cat("The flag 'addbarplot' is set to FALSE. Therefore, a separate barplot is created with number of segregating sites.",sep="\n")
			}
		}
	if(!is.null(export)){dev.off()}	
	}

plot2Dsfs_multi<-function(export=NULL,exportname="SFS.2D.all",mylist=sfslist,inverse=FALSE)
	{
	# export can be pdf or png or jpeg
	# depends on ggplot2
	# library(grid)
	# install.packages("gridGraphics")
	# library(gridGraphics)
	# library(gridExtra)
	gl <- lapply(1:length(mylist), function(i){
		pop1		<- sfscombitable[1,i]
		pop2		<- sfscombitable[2,i]
		mymatrix	<- unclass(mylist[[i]])
		myBreaks	<- sfsbreaks[[i]]
		myColours	<- sfscolours[[i]]
		mytitle		<- names(sfsmatrix)[i]
		my_margins=c(2.5,2.5)	# under/above,right/left
		heatmap.2(mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=0,srtCol=90,key=FALSE,margins=my_margins,adjCol=c(1,0.5),adjRow=c(0,NA),offsetRow = -0.5,offsetCol=-0.5)
		#mtext(myylab, side = 4, line = 1, cex = 2, las=2)
		#mtext(myxlab, side = 1, line = 3.25, cex = 2)
		mtext(pop1, side=2, line = 0.5, cex = 3)
		mtext(pop2, side = 3, line = 0.5, cex = 3)
		grid.echo()
		grid.grab()})
	graphics.off()
	if(!is.null(export))
		{
		#if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=8,width=24,onefile=FALSE)}	# 3 columns
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=24,width=8,onefile=FALSE)}		# 1 column
		if(export=="png"){png(paste(exportname,"png",sep="."),height=1325,width=975)}
		if(export=="jpeg"){jpeg(paste(exportname,"jpeg",sep="."),height=1325,width=975)}
		}
	grid.newpage()
	grid.arrange(grobs=gl, ncol=1, clip=TRUE, as.table = FALSE)	
	if(!is.null(export)){dev.off()}
	}

plot2Dsfs<-function(popnames=mysambar$populations,mycolours=as.vector(unique(inds$popcol)),ndecimals=3,export=NULL)
	{
	# this function generates pairwise 2D-SFS plots
	# this function expects mac columns in snp datasets, produced by 'getfoldedsfs'-function
	#
	# which pairwise comparisons?
	combitable					<- combn(popnames,m=2)
	combicoltable				<- combn(mycolours,m=2)
	multilocusweirfstvector		<- vector()
	npops						<- length(popnames)
	sfslist						<<- list()
	sfscolours					<<- list()
	sfsbreaks					<<- list()
	sfscombitable				<<- combitable
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		# cat(i,sep="\n")
		pop1		<- combitable[1,i]
		pop2		<- combitable[2,i]
		mac1		<- snps[snps$filter,paste("mac",pop1,sep="_")]
		mac2		<- snps[snps$filter,paste("mac",pop2,sep="_")]
		mymatrix	<- table(mac1,mac2)
		mymatrix	<- mymatrix/(sum(mymatrix))*100
		if(nrow(mymatrix)>1&ncol(mymatrix)>1)
			{
			# as colour we are going to use a blend of the two population colours:
			mycol1		<- combicoltable[1,i]
			mycol2		<- combicoltable[2,i]
			mycolfunc3 	<- colorRampPalette(c(mycol1,mycol2))
			mycol		<- mycolfunc3(3)[2]
			# define colour scale
			mycolfunc1 	<- colorRampPalette(c("grey85",mycol))
			myBreaks1	<- seq(0,0.99,0.01)
			myCol1		<- c(mycolfunc1(length(myBreaks1)-1))
			mycolfunc2 	<- colorRampPalette(c(mycol,"black"))
			mymax		<- ceiling(max(mymatrix))
			myBreaks2	<- seq(1,mymax,1)
			myCol2		<- c(mycolfunc2(length(myBreaks2)-1))
			# combine:
			myBreaks	<<- c(myBreaks1,myBreaks2)
			myColours	<<- c(myCol1,mycol,myCol2)
			# create plot:
			if(!is.null(export))
				{
				myprefix	<- paste("SFS.2D",pop1,pop2,sep="_")
				if(export=="eps"){postscript(paste(myprefix,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf(paste(myprefix,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png(paste(myprefix,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile(paste(myprefix,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
				}
			heatmap.2(mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=0,srtCol=90,key=FALSE)
			myylab	<- paste("# allele copies in",pop1,sep=" ")
			myxlab	<- paste("# allele copies in",pop2,sep=" ")
			mtext(myylab, side = 4, line = 1, cex = 2)
			mtext(myxlab, side = 1, line = 3.5, cex = 2)
			mtext(paste(pop1,"vs",pop2,sep=" "), side = 3, line = 1, cex = 2.5)
			if(!is.null(export)){dev.off()}
			sfslist[[i]]	<<- mymatrix
			names(sfslist)[i]<<- paste(pop1,"vs",pop2,sep=" ")
			sfscolours[[i]]	<<- myColours
			sfsbreaks[[i]]	<<- myBreaks
			}else{
			mypoppair<-paste(pop1,"_",pop2,sep="")
			cat(paste("SFS vector of length 1 for pairwise population comparison:",mypoppair,sep=" "),sep="\n")
			cat("Outputting a table rather than a plot.",sep="\n")
			write.table(mymatrix,paste("SFS.2D",mypoppair,"txt",sep="."),quote=FALSE,row.names=TRUE,col.names=TRUE)
			}
		}
	}

wattersonplot<-function(export=NULL,do_expected=FALSE)
	{
	if(!"pop_ninds"%in%colnames(inds))
		{
		mynind			<- as.data.frame(table(inds$pop[inds$filter]))
		inds$pop_ninds	<- NA
		for (i in c(1:nrow(inds)))
			{
			mypop				<- inds$pop[i]
			mypop2				<- which(mynind$Var1==mypop)
			inds$pop_ninds[i]	<- mynind$Freq[mypop2]
			}
		}
	if(!is.null(export))
		{
		if(export=="pdf"){pdf("Watterson.numbers.pdf",height=6,width=6)}
		}
	par(cex.lab=1.5,cex.lab=1.5)
	plot(inds$pop_ninds,inds$nsegsites1,col=inds$popcol,pch=16,cex=1.5,xlab="# individuals",ylab="# segregating sites")
	legend("bottomright",legend=mysambar$populations,fill=mysambar$mycolours,bty='n',cex=1.25)
	#
	# expected S, based on harmonic (unfortunately results don't add up, so I don't include it):
	if(do_expected)
		{
		mymax 	<- max(inds$pop_ninds,na.rm=TRUE)+5
		myrange	<- c(1:mymax)
		myexp	<- vector()
		for(j in myrange)
			{
			myexp[j]	<- sum(1/c(1:(myrange[j]*2))) 
			}
		mypi	<- mean(inds$genomepi,na.rm=TRUE)
		expS	<- mypi*myexp
		}
	if(!is.null(export)){dev.off()}
	if(!"S"%in%colnames(inds))
		{
		cat("No column called 'S' in inds dataframe. Not generating 'Watterson.proportions' plot.",sep="\n")
		cat("The 'S' column is generated by calcdiversity() function if an input is provided to nsites argument.",sep="\n")
		}else{
		inds$harmonic			<<- NA
		for(j in c(1:nrow(inds)))
			{
			inds$harmonic[j]	<<- sum(1/c(1:(inds$pop_ninds[j]*2)))
			}
		if(!"genomepi_pop"%in%colnames(inds))
			{
			mynind					<- as.data.frame(table(inds$genomepi[inds$filter]))
			inds$genomepi_pop	<<- NA
			for (i in c(1:nrow(inds)))
				{
				mypop				<- inds$pop[i]
				mypivector		<- inds$genomepi[inds$pop==mypop]
				inds$genomepi_pop[i]	<<- mean(mypivector,na.rm=TRUE)
				}
			}
		if(!is.null(export))
			{
			if(export=="pdf"){pdf("Watterson.proportions.pdf",height=6,width=6)}
			}
		par(cex.lab=1.5,cex.lab=1.5)
		plot(inds$pop_ninds,inds$S,col=inds$popcol,pch=16,cex=1.5,xlab="# individuals",ylab="Proportion segregating sites")
		legend("bottomright",legend=mysambar$populations,fill=mysambar$mycolours,bty='n',cex=1.25)
		if(do_expected)
			{
			lines(myrange,expS)
			}
		if(!is.null(export)){dev.off()}
		}	
	}	
	
# Plot output from PLINK:
LD_plot<-function(export=NULL,doboxplot=TRUE,plotmeansonly=FALSE,popnames=mysambar$populations,maxr2filter=TRUE,inverse=FALSE,xrange=c(0,1000000),stepsize=100000,cols=NULL,myxmax=1,xloc=0.6,yloc=0.9,legendsize=2.5,symboltype=c(17,20,18,15))
	{
	# This function expects to find inputfiles files generated by plink R2 command called after the names of the populations.
	setwd(mysambar$inputfilesdir)
	npops				<- length(popnames)
	if(is.null(cols))
		{
		cols	<- mysambar$mycolours[1:npops]
		}
	# set distance bins and their labels (midpoints):
	br					<- seq(xrange[1],xrange[2],stepsize)
	mids				<- vector() 
	for(i in c(1:length(br)-1))
		{
  		mids[i]			<- sum(br[i],br[i+1])/2
		}
	# read data from plink output (ld files created by plink R2 command) and divide into distance bins:
	mylist				<- list()
	for (i in c(1:npops))
		{
		mylist[[i]]				<- read.table(paste(popnames[i],"ld",sep="."),header=TRUE)
		colnames(mylist[[i]])	<- c("CHR_A","BP_A","SNP_A","CHR_B","BP_B","SNP_B","R2")  	# not really necessary, but just in case spaces in input files causes problems
		mylist[[i]]$dist		<- (mylist[[i]]$BP_B-mylist[[i]]$BP_A)
		mylist[[i]]$below1		<- ifelse(!(mylist[[i]]$R2==1&maxr2filter==TRUE),TRUE,FALSE)
		mylist[[i]]$distclass	<- cut(mylist[[i]]$dist,breaks=br,labels=mids) 
		mylist[[i]]$pop			<- as.factor(popnames[i])
		}
	names(mylist)				<- popnames
	mylist						<<- mylist
	# 
	for (i in c(1:length(popnames)))
		{
		popdata		<- mylist[[i]]
		myyaxt		<- ifelse(i==1,'s','n')
		boxplot(popdata$R2~popdata$distclass,outline=FALSE,col=cols[i],ylim=c(0,1),xaxt='n',yaxt=myyaxt)
		axis(side=1,labels=mids/100000,at=mids)
		axis(side=1)
		mtext(side=3,popnames[i],line=0,cex=2)
		}
	# plot:
	if(doboxplot)
		{
		cat("LD.boxplot",sep="\n")
		setwd(mysambar$diversitydir)
		graphics.off()
		if(!is.null(export))
			{
			stepsize2	<- stepsize/1000
			if(export=="eps"){postscript(paste("LD.boxplot",paste(stepsize2,"K",sep=""),"eps",sep="."),family=mysambar$myfont,width=8,height=8)}
			if(export=="pdf"){pdf(paste("LD.boxplot",paste(stepsize2,"K",sep=""),"pdf",sep="."),family=mysambar$myfont,width=8,height=8)}
			if(export=="png"){png(paste("LD.boxplot",paste(stepsize2,"K",sep=""),"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile(paste("LD.boxplot",paste(stepsize2,"K",sep=""),"wmf",sep="."),family=mysambar$myfont,width=8,height=8)}
			}
		par(mar=c(6,5,1,1),cex.axis=1.5,cex.main=2.5)
		x		<- do.call(rbind,mylist)
		mybins	<- as.vector(unique(x$distclass))
		nclass	<- length(mybins)-1
		myloc	<- c(1:(nclass*(npops+1)-1))
		myloc2	<- myloc[myloc%%(npops+1)!=0]	
		#boxplot(x$R2~x$pop*x$distclass,outline=FALSE,col=mysambar$mycolours[1:3],ylim=c(0,1),xaxt='n',at=myloc2,las=1)
		#legend("topright",popnames,fill=mysambar$mycolours[1:3],bty='n',cex=2)
		boxplot(x$R2~x$pop*x$distclass,outline=FALSE,col=mysambar$mycolours[1:npops],ylim=c(0,1),xaxt='n',at=myloc2,las=1)
		legend("topright",popnames,fill=mysambar$mycolours[1:npops],bty='n',cex=2)
		# add means:
		mymeans <- aggregate(R2 ~ pop*distclass, x, mean)
		points(myloc2,mymeans$R2,pch=16,col="white",cex=1)
		# add xaxis:
		labelloc1<- round(mean(1:npops))
		labelloc2<- seq(labelloc1,nclass*(npops+1),(npops+1)) 
		axis(side=1,at=labelloc2,label=mids/100000,las=2)
		mtext(side=1,"Physical distance (100 kB)",line=4.5,cex=2.5)
		mtext(side=2,"LD (r2)",line=3,cex=2.5)
		if(!is.null(export)){dev.off()}
		}
	#
	if(plotmeansonly)
		{
		# calculate mean per dataclass:
		r2matrix				<<- matrix(nrow=(length(popnames)+1),ncol=(length(br)-1))
		r2matrix[1,]			<<- mids
		for(i in c(1:length(br)-1))
			{ 
			temp				<- mids[i]
			for (j in c(1:npops))
				{
				#cat(j,sep="\n")
				#cat((names(mylist)[j]),sep="\n")
				r2matrix[j+1,i]	<<- ifelse(inverse,1/(mean(mylist[[j]]$R2[mylist[[j]]$distclass==temp],na.rm=TRUE)),mean(mylist[[j]]$R2[mylist[[j]]$distclass==temp],na.rm=TRUE))
				}
			}
		# Plot means only:
		setwd(mysambar$diversitydir)
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("LDmean.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("LDmean.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("LDmean.png",family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile("LDmean.wmf",family=mysambar$myfont,width=10,height=10)}
			}
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		xaxismax			<<- myxmax*xrange[2]
		yaxismax			<<- max(r2matrix[2:length(popnames),],na.rm=TRUE)
		plottitle			<- ifelse(inverse,"1/(mean R2)","mean R2")
		#plot(r2matrix[1,],r2matrix[2,],pch=symboltype[1],col=cols[1],main="LD vs physical distance",xaxt="n",xlab="Physical distance (100 kb)",ylab=plottitle,cex=2.5,ylim=c(0,yaxismax),xlim=c(0,xaxismax),bty="n")
		plot(r2matrix[1,],r2matrix[2,],pch=16,col=cols[1],main="LD vs physical distance",xaxt="n",xlab="Physical distance (100 kb)",ylab=plottitle,cex=2.5,ylim=c(0,yaxismax),xlim=c(0,xaxismax),bty="n")
		axis(side=1,at=seq(0,xaxismax,100000),labels=(seq(0,xaxismax,100000)/100000),lty=1,las=1)
		for (i in c(2:length(popnames)))
			{
			#if(length(popnames)<=4)
			#	{
			#	points(r2matrix[1,],r2matrix[i+1,],pch=symboltype[i],col=cols[i],cex=2.5,xlim=c(0,xaxismax))
			#	}else{
				points(r2matrix[1,],r2matrix[i+1,],pch=16,col=cols[i],cex=2.5,xlim=c(0,xaxismax))
			#	}
			}
		#if(length(popnames)<=4)
		#	{
		#	legend(x=xloc*xaxismax,y=yloc*yaxismax,legend=popnames,pch=symboltype,fill=cols,cex=legendsize,bty="n")
		#	}else{
			legend(x=xloc*xaxismax,y=yloc*yaxismax,legend=popnames,fill=cols,cex=legendsize,bty="n")
		#	}
		if(!is.null(export)){dev.off()}
		}
	setwd(mysambar$inputdatadir)
	}

LDperchrom<-function(addX=FALSE,popnames=mysambar$populations,export=NULL,maxr2filter=TRUE,cols=as.vector(unique(inds$popcol)))
	{
	# This function expects to find inputfiles subdirectory files generated by plink R2 command called after the names of the populations.
	setwd(mysambar$inputfilesdir)
	# read data from plink output (ld files created by plink R2 command) and add columns: 
	mylist	<- list()
	for (i in c(1:length(popnames)))
		{
		mylist[[i]]				<- read.table(paste(popnames[i],"ld",sep="."),header=TRUE)
		colnames(mylist[[i]])	<- c("CHR_A","BP_A","SNP_A","CHR_B","BP_B","SNP_B","R2")  	# not really necessary, but just in case spaces in input files causes problems
		mylist[[i]]$dist		<- mylist[[i]]$BP_B-mylist[[i]]$BP_A
		mylist[[i]]$below1		<- ifelse(!(mylist[[i]]$R2==1&maxr2filter==TRUE),TRUE,FALSE)
		mylist[[i]]$distclass	<- cut(mylist[[i]]$dist,breaks=br,labels=mids) 
		}
	names(mylist)				<- popnames
	# Calculate LD per chrom:
	mychroms					<- sort(as.numeric(as.vector(unique(snps$chr[as.vector(snps$autosomal)]))))
	if(addX){mychroms			<- c(mychroms,"X")}
	LDmatrix					<<- matrix(ncol=length(popnames),nrow=length(mychroms))
	rownames(LDmatrix)			<<- mychroms
	colnames(LDmatrix)			<<- popnames
	for (i in c(1:length(popnames)))
		{
		for (i in mychroms)
			{
			temp				<- mylist[[j]]$R2[mylist[[j]]$CHR_A==i&mylist[[j]]$below1]
			LDmatrix[i,j]		<<- round(mean(temp,na.rm=TRUE),3)
			}
		}
	setwd(mysambar$diversitydir)
	write.table(LDmatrix,file="LDperchrom.txt",na="NA",row.names=TRUE,col.names=TRUE,sep="\n",quote=FALSE)
	setwd(mysambar$inputdatadir)
	}

# Boxplots of differences in maf between adjacent snps.
# Not entirely sure how this relates to LD. 
multimafdiff<-function(export=FALSE,popnames=mysambar$populations,mymaxdistances=c(500,10000,500000),my_log="",do_boxplot=TRUE,do_scatterplot=TRUE,addoutliers=FALSE)
	{
	if(!"dist" %in% colnames(snps))
		{
		return(cat("ERROR: no column called dist in snps dataframe.",sep="\n"))
		}
	npop	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npop]
	if(do_boxplot)
		{
		if(export){pdf("DeltaMAF_vs_spacing.pdf",width=9,height=npop*3)}
		par(mfrow=c(3,npop),oma=c(2,5,2.5,1),mar=c(4,0.5,0.5,0.5),cex.axis=1.5)
		for (k in c(1:3))
			{
			mydistance	<- mymaxdistances[k]
			mystepsize	<- mydistance/10
			for(p in c(1:npop))
				{
				mypop	<- popnames[p]
				mypopcol<- mycols[p]
				mypopmaf<- snps[,paste("maf",mypop,sep="_")]
				add_y	<- ifelse(p==1,TRUE,FALSE)
				mytitle	<- ifelse(k==1,mypop,"")
				if(k==1)
					{
					mafdiff(mypopmaf,mycol=mypopcol,plottitle=mytitle,addyaxis=add_y,addylabel=FALSE,stepsize=mystepsize,distrange=c(0,mydistance),mylog=my_log,addtosnps=TRUE)
					names(snps)[names(snps)=="mafdiff"]	<<- paste("mafdiff",mypop,sep="_")
					}else{
					mafdiff(mypopmaf,mycol=mypopcol,plottitle=mytitle,addyaxis=add_y,addylabel=FALSE,stepsize=mystepsize,distrange=c(0,mydistance),mylog=my_log,addtosnps=FALSE)
					}
				}
			}
		mtext("SNP spacing (kb)",side=1,cex=2,line=0.5,outer=TRUE)
		mtext(side=2,line=2.5,"MAF difference",cex=2,outer=TRUE)
		if(export){dev.off()}
		}
	snps 	<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	if(do_scatterplot&npop>1)
		{
		if(export)
			{
			n_pair	<- ncol(combitable)
			mywidth	<- ifelse(n_pair==2,10,15)
			myheight<- ifelse(n_pair==2,5,ifelse(n_pair==3,15,ifelse(n_pair>3&n_pair<7,10,ifelse(n_pair>6&n_pair<10,15,20))))
			pdf("DeltaMAF_interpopulation.pdf",height=myheight,width=mywidth)
			}
		par(mfrow=c(1,3),oma=c(0,1.5,0.5,0.5),mar=c(5,6,2.5,2))
		combitable		<<- combn(popnames,m=2)
		for (j in c(1:ncol(combitable)))
			{
			mypop1	<- combitable[1,j]
			mypop2	<- combitable[2,j]
			mylabel	<- paste(mypop1,mypop2,sep="_")
			mydiff1	<- snps[,paste("mafdiff",mypop1,sep="_")]
			mydiff2	<- snps[,paste("mafdiff",mypop2,sep="_")]
			diffmat	<- as.data.frame(cbind(mydiff1,mydiff2))
			colnames(diffmat)	<- c("pop1","pop2")
			if(addoutliers)
				{
				diffmat$out<-snps$rfisherout_pheno
				}
			diffmat	<- as.data.frame(unique(diffmat))
			plot(diffmat$pop2[snps$filter2],diffmat$pop1[snps$filter2],xlim=c(0,1),ylim=c(0,1),pch=16,cex=0.75,las=1,cex.axis=1.5,ylab="",xlab="")
			if(addoutliers)
				{
				outmat<- diffmat[diffmat$out,]
				outmat	<<- outmat
				points(outmat$pop2[2],outmat$pop1[2],col="red",pch=16,cex=2)
				points(outmat$pop2[3],outmat$pop1[3],col="red",cex=2)
				}
			mtext(paste(mypop2,"Delta_MAF",sep=" "),side=1,line=3.5,cex=2.5)
			mtext(paste(mypop1,"Delta_MAF",sep=" "),side=2,line=3.5,cex=2.5)
			}
		if(export){dev.off()}
		
		}
	}

mafdiff<-function(mymaf=snps$maf,stepsize=500,doboxplot=TRUE,distrange=c(0,10000),mycol="grey",addylabel=TRUE,addyaxis=TRUE,plottitle=NULL,mylog="",addtosnps=FALSE)
	{
	if(!"dist" %in% colnames(snps))
		{
		return(cat("ERROR: no column called dist in snps dataframe.",sep="\n"))
		}
	# calculate difference in maf between adjacent snps:
	new_chr			<- (as.vector(snps$chr))!=c(as.vector(snps$chr[2:length(snps$chr)]),as.factor("dummy"))
	new_chr			<- c(TRUE,new_chr[1:(length(new_chr)-1)])
	mymaf1			<- mymaf
	mymaf2			<- c(as.vector(mymaf[2:length(mymaf)]),NA)
	mydiff			<- mymaf2-mymaf1
	mydiff			<- abs(c(NA,mydiff[1:(length(mydiff)-1)]))
	mydiff[new_chr]	<- NA
	# set distance bins and their labels (midpoints):
	br					<- seq(distrange[1],distrange[2],stepsize)
	mids				<- vector() 
	for(i in c(1:length(br)-1))
		{
  		mids[i]			<- sum(br[i],br[i+1])/2
		}	
	mids				<- mids/1000
	mydistclass			<- cut(snps$dist,breaks=br,labels=mids) 
	#meanperdistclass	<<- aggregate(mydiff,list(mydistclass),mean)
	myyaxt				<- ifelse(addyaxis,'s','n')
	if(doboxplot)
		{
		if(mylog=="y")
			{
			boxplot(mydiff[snps$filter2&mydiff!=0]~mydistclass[snps$filter2&mydiff!=0],las=2,col=mycol,ylim=c(0.0001,1),yaxt=myyaxt,log=mylog)
			}else{
			boxplot(mydiff[snps$filter2&!is.na(mydiff)]~mydistclass[snps$filter2&!is.na(mydiff)],las=2,col=mycol,ylim=c(0,1),yaxt=myyaxt,log=mylog)
			}
		if(addylabel)
			{
			mtext(side=2,line=2.5,"MAF difference",cex=2)
			}
		if(!is.null(plottitle))
			{
			mtext(plottitle,side=3,line=0.5,cex=1.5)
			}
		}
	if(addtosnps)
		{
		snps$mafdiff		<<- mydiff
		}
	mydiff	<<- as.data.frame(cbind(mymaf1,mymaf2,mydiff)) 
	}

homorun<-function(export=NULL,sims=FALSE,input=mygenlight,popnames=mysambar$populations,indselection=inds$filter,snpselection=snps$filter,maxrohlength=100,lowmaf=TRUE,colourcode=inds$popcol2)
	{
	# 19032019: I removed simulations because I run into ERROR after changing from line plot to boxplot
	npops	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npops]
	if(!(any(names(snps)=="dist")))
		{
		return(cat("ERROR: snps$dist column missing. This function can only be executed if you know the location of your snps.",sep="\n"))
		}
	nindsperpop			<- as.vector(table(inds$pop[inds$filter]))
	if(any(nindsperpop<5))
		{
		return(cat("Some populations contain less than 5 retained individuals. SambaR will not generate ROH plot.",sep="\n"))
		}
	# First we need to calculate mean spacing:
	if(any(snps$autosomal))
		{
		meanspacing			<- mean(snps$dist[snps$autosomal],na.rm=TRUE)	
		medianspacing		<- median(snps$dist[snps$autosomal],na.rm=TRUE)
		}else{
		meanspacing			<- mean(snps$dist,na.rm=TRUE)	
		medianspacing		<- median(snps$dist,na.rm=TRUE)
		}
	# Now create dataframe in which these values are multiplied with various numbers of snps:
	rohlength			<- c(1:maxrohlength)
	meanbp				<- rohlength*meanspacing
	medianbp			<- rohlength*medianspacing
	roh					<- data.frame(rohlength,meanbp,medianbp)
	# Select snps:
	if(lowmaf==TRUE)
		{
		if(any(snps$autosomal))
			{
			snpselect		<- snps$filter&snps$autosomal&snps$maf<0.1  
			}else{
			snpselect		<- snps$filter&snps$maf<0.1 
			}
		}else{
		if(any(snps&autosomal))
			{
			snpselect		<- snps$filter&snps$autosomal&snps$maf>0.1
			}else{
			snpselect		<- snps$filter&snps$maf>0.1
			}
		}
	mymatrix			<- as.matrix(input[,snpselect])
	if(length(mymatrix[is.na(mymatrix)])/(nrow(mymatrix)*ncol(mymatrix))>0.2)
		{
		return(cat("More than 20 percent missing data points. SambaR will not generate ROH-plot.",sep="\n"))
		}
	# Do the actual calculation:
	for (j in (1:npops))
		{
		mypop			<- popnames[j]
		mycol			<- mycols[j]
		# Select individuals:
		indnr			<- inds$nr[indselection&inds$pop2==popnames[j]] 
		# Now calculate for each selected individual roh-lengths:
		for (i in indnr)
			{ 
			sample				<- mymatrix[inds$nr==i,]
			sample				<- sample[!is.na(sample)]
			# Give minor homozygotes and major homozygotes the same code (0):
			for (k in (1:(length(sample))))
				{
				sample[k]		<-ifelse(sample[k]==1,1,0)
				}
			# Now we are ready to apply the rle-function:
			temp				<- rle(sample)
			temp2				<- cbind(as.data.frame(temp$values),as.data.frame(temp$length))
			colnames(temp2)		<- c("values","length")
			# select runs of homozygosity:
			temp2				<- temp2[temp2$values==0,]
			# Count the occurences of each rohlength:
			results				<- as.data.frame(table(temp2$length))
			colnames(results)	<- c("rohlength","count")
			results$rohlength	<- as.numeric(results$rohlength)
			# What is the frequency?
			results$count		<- as.numeric(results$count)
			results$freq		<- results$count/(sum(results$count))
			results$freqsum		<- cumsum(results$freq)
			results$p		<- ifelse(results$rohlength==1,1,NA)
			for (l in (2:(nrow(results))))
				{
				results$p[l]	<- 1-results$freqsum[l-1]
				}
			results$count		<- NULL
			results$freq		<- NULL
			results$freqsum		<- NULL
			roh					<- merge(x=roh, y=results, by="rohlength", all=TRUE)
			#lines(roh$rohlength[1:125],roh[1:125,ncol(roh)],col=mycol,ann=FALSE,xlim=c(0,100))
			names(roh)[ncol(roh)] 	<- paste0("sample", i)
			} # end of ind loop 
		} # end of population loop 
	# Plot:
	graphics.off()
	if(!is.null(export))
		{
		if(export=="wmf"){win.metafile("ROH.wmf",height=6,width=12)}
		if(export=="pdf"){pdf("ROH.pdf",height=6,width=12)}
		}
	#plot(rohlength,rep(0.5,100),ylim=c(0,1),col="white",ann=FALSE,xlim=c(0,100))
	for(j in c(1:npops))
		{
		mypop	<- popnames[j]
		mycol	<- mycols[j]
		roh2	<- t(roh)
		temp	<- roh2[4:nrow(roh2),]
		my_pops	<- inds$pop2[inds$filter]
		my_inds	<- my_pops==mypop 
		temp2	<- temp[my_inds,]
		addplot	<- ifelse(j==1,FALSE,TRUE)
		myaxt	<- ifelse(j==1,'s','n')
		boxplot(temp2,use.cols=TRUE,col=mycol,outline=FALSE,las=2,add=addplot,xaxt=myaxt,yaxt='n',cex.axis=0.75)
		}
	axis(side=2,cex=1.5,las=1)
	mtext("ROH length (number of snps)",side=1,line=3,cex=2)
	mtext("Probability",side=2,line=2.5,cex=2)
	mtext("Runs of homozygosity",side=3,line=0.5,cex=2)
	legend("topright",legend=popnames,fill=mycols,cex = 1,bty='n')
	if(!is.null(export)){dev.off()}
	}		

# Function to create Mondriaan plot:
multiglPlots<-function(popnames=mysambar$populations,chromosome=1,mycols=as.vector(unique(inds$popcol)),export=NULL)
	{
	setwd(mysambar$diversitydir)
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("ROH.eps",family=mysambar$myfont,width=6,height=8)}
		if(export=="pdf"){pdf("ROH.pdf",family=mysambar$myfont,width=6,height=8)}
		if(export=="png"){png("ROH.png",family=mysambar$myfont,width=540,height=720)}
		if(export=="wmf"){win.metafile("ROH.wmf",family=mysambar$myfont,width=6,height=8)}
		}
	if(any(names(snps) == "chr"))
		{
		par(mfrow=c(length(popnames),1),mai=c(0.05,0.05,0.05,0.05),oma=c(3.5,3.5,2,0))
		for (i in (1:(length(popnames))))
			{ 
			mycol<-c("black",mycols[i],"grey20")
			glPlot(mygenlight[inds$filter&inds$pop2==popnames[i],snps$filter&snps$chr==chromosome],col=mycol,legend=FALSE,main="") 
			mtext(popnames[i],side=2,line=2.5)
			}
		}else{
		print("Snps-dataset should contains a vector called 'chr' with information about the location of the snp")
		}
	mtext("SNP ID",side=1,line=2,outer=TRUE)
	mtext(paste("Chromosome",chromosome,sep=" "),side=3,line=0.3,outer=TRUE,font=2)
	if(!is.null(export)){dev.off()}
	setwd(mysambar$inputdatadir)
	}
   
# End of genetic diversity analyses 
###############################################################################################################





###############################################################################################################
# Population demography analyses

addgeo<-function()
        {
        #Flooding of Doggerland:
        polygon(x=c(6200,6500,6500,6200),y=c(100,100,200000,200000),col="grey",border=NA)
        #Younger Dryas:
        polygon(x=c(11700,12900,12900,11700),y=c(100,100,200000,200000),col="grey40",border=NA)
        #LGM:
        polygon(x=c(16000,31000,31000,16000),y=c(100,100,200000,200000),col="grey20",border=NA)
        }

addlabels<-function(yaxis=TRUE)
        {
		axis(1, at=c(0,100,1000,10000,100000),labels=c(0,0.1,1,10,100),las=1)
		if(yaxis)
                {
                axis(2, at=c(0,1000,2000,3000,4000,5000,10000,20000,30000,40000,50000),labels=c(0,1,2,3,4,5,10,20,30,40,50),las=1)
                }
        }

# The next function depends on addgeo and addlabels
# It expects to find within the Demography directory files outputted by the Stairway_plot executable, one for each of your population.
# These files should have as prefix the name of your population (as defined in the populations vector) and as suffix: '.final.summary'. 

run_plotstairway<-function(mu_rate="2.5*10^-8",Gtime="20",x_range=c(100,100000),exporttype="pdf",pop_names=mysambar$populations,my_colours=mysambar$mycolours,my_suffix=NULL,add_glacials=FALSE)
	{
	setwd(mysambar$demographydir)
	if(is.null(my_suffix))
		{
		my_suffix	<- "final.summary" 
		}
	for (i in c(1:length(pop_names)))
		{
		# read data:
		mypop		<- pop_names[i]
		myfile		<- paste(mypop,my_suffix,sep=".")
		if(!file.exists(myfile))
			{
			cat(paste("ERROR: SambaR couldn't find the file ",myfile,". It expects to find this file within the directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")
			cat("The file names should be your population name (as currently defined in SambaR) and the suffix defined by the my_suffix flag, seperated by a period (.).",sep="\n")
			cat("If my_suffix is set to NULL (default), SambaR expects the suffix to be 'final.summary'.",sep="\n")
			cat("By default, SambaR expects to find input files for all these populations:",sep="\n")
			cat(mysambar$populations,sep="\n")
			cat("By default, it assigns the following colours:",sep="\n")
			cat(mysambar$mycolours[1:length(pop_names)],sep="\n")
			return(cat("You can exclude one or more populations by defining the desired populations and colours with the 'pop_names' and 'my_colours' flags.",sep="\n"))
			}
		}
	plotstairway(logscale="",u_rate=mu_rate,gen_time=Gtime,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="x",u_rate=mu_rate,gen_time=Gtime,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="y",u_rate=mu_rate,gen_time=Gtime,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="xy",u_rate=mu_rate,gen_time=Gtime,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	}
	
plotstairway<-function(u_rate="2.5*10^-8",gen_time="20",mysuffix=NULL,logscale="xy",popnames=mysambar$populations,export=NULL,addglacials=FALSE,mycolours=mysambar$mycolours,xrange=NULL)
	{
	# Note: u_rate and gen_time are just used as label. They don't affect the plot itself. 
	# This function expects to find inputfiles subdirectory output from stairwayplot software:	
	setwd(mysambar$demographydir)
	if(is.null(mysuffix))
		{
		mysuffix	<- "final.summary" 
		}
	mylist			<<- list()
	mymaxall		<- 0
	myminall		<- 100000
	for (i in c(1:length(popnames)))
		{
		# read data:
		mypop		<- popnames[i]
		myfile		<- paste(mypop,mysuffix,sep=".")
		#cat(myfile,sep="\n")
		if(!file.exists(myfile))
			{
			cat(paste("ERROR: SambaR couldn't find the file ",myfile,". It expects to find this file within the directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")
			cat("Replace or rename your files.",sep="\n")
			cat("The file names should be your popname (as currently defined in SambaR) followed by the suffix defined by the mysuffix flag.",sep="\n")
			return(cat("If mysuffix is set to NULL (default), SambaR expects the suffix to be 'final.summary'.",sep="\n"))
			}
		mylist[[i]] <<- read.table(paste(mypop,mysuffix,sep="."),header=TRUE)
		mymax		<- max(mylist[[i]]$Ne_97.5.)
		mymaxall	<- ifelse(mymax>mymaxall,mymax,mymaxall)
		mymin		<- min(mylist[[i]]$Ne_2.5.)
		myminall	<- ifelse(mymin<myminall,mymin,myminall)
		}
	npops		<- length(popnames)
	# linear scale or log scale?
	if(logscale=="y"|logscale=="")
        	{
			if(!is.null(xrange))
				{
				cat(paste("Using",xrange[1],"and",xrange[2],"as minimum and maximum values for the x axis.",sep=" "),sep="\n")
				myxaxis	<- xrange 				
				}else{
				cat("No range of x-axis defined for non-logarithmic x-axis.",sep="\n")
				cat("Defaults to xmin = 500 and xmax = 35000.",sep="\n")
				cat("Use xrange flag (i.e. xrange=c(500,35000)) to adjust.",sep="\n")
				myxaxis	<- c(500,35000)
				}
			}else{
        	if(!is.null(xrange))
				{
				cat(paste("Using",xrange[1],"and",xrange[2],"as minimum and maximum values for the x axis.",sep=" "),sep="\n")
				myxaxis	<- xrange 				
				}else{
				cat("No range of x-axis defined for logarithmic x-axis.",sep="\n")
				cat("Defaults to xmin = 500 and xmax = 35000.",sep="\n")
				cat("Use xrange flag (i.e. xrange=c(500,35000)) to adjust.",sep="\n")
				myxaxis	<- c(500,35000)
				}
		   	}
	myymax	<- mymaxall
	myymin	<- ifelse((logscale=="x"|logscale==""),0,ifelse(myminall<100,100,myminall))
	#
	# Plot:
	graphics.off()
	if(!is.null(export))
		{
		mywidth		<- npops*5.5
		mywidth2	<- npops*550
		mystring	<- ifelse(logscale=="xy","log_xy",ifelse(logscale=="x","log_x",ifelse(logscale=="y","log_y","linear")))
		if(export=="eps"){postscript(paste("stairwayplot",mystring,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=7)}
		if(export=="pdf"){pdf(paste("stairwayplot",mystring,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=7)}
		if(export=="png"){png(paste("stairwayplot",mystring,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=720)}
		if(export=="wmf"){win.metafile(paste("stairwayplot",mystring,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=7)}
		}
	par(mfrow=c(1,length(popnames)),cex.axis=2.5,cex.lab=2,oma=c(2,6,2,2),mar=c(4,1,4,0))
	for (i in c(1:length(popnames)))
		{
		# first create plot outline:
		plot(mylist[[1]]$year,mylist[[1]]$Ne_97.5,type="l",log=logscale,xlab="",ylab="Ne (1k individuals)",las=1,yaxt="n",xaxt="n",col="white",main=NULL,xlim=myxaxis,ylim=c(myymin,myymax))
		mypop		<- popnames[i]
		if(i==1)
			{
			mtext("Time (kya)",side=1,cex=2.5,outer=TRUE)
			mtext("Ne (1k individuals)",2,line=4,cex=2.5)
			#mtext("Historic effective population sizes",cex=1.25,side=3,line=-1,outer=TRUE)
			mtext(paste("Generation time =",gen_time,"years; Mutation rate =",u_rate,"(per site per generation)",sep=" "),line=-2,outer=TRUE,cex=1.5)
			#addlabels()
			if(logscale=="y"|logscale=="xy")
				{
				#axis(2, at=c(0,1000,2000,3000,4000,5000,10000,20000,30000,40000,50000),labels=c(0,1,2,3,4,5,10,20,30,40,50),las=1)
				axis(2, at=c(0,500,1000,2500,5000,10000,25000,50000),labels=c(0,0.5,1,2.5,5,10,25,50),las=1)
				}else{
				ystep	<- ifelse(myymax>20000,ifelse(myxaxis[2]>50000,25000,10000),5000)
				xlabels	<- seq(0,myymax,ystep)
				axis(2,at=xlabels,labels=xlabels/1000,las=1)
				}
			}
		#addlabels(yaxis=FALSE)
		if(logscale=="y"|logscale=="")
        	{
			xstep	<- ifelse(myxaxis[2]>20000,ifelse(myxaxis[2]>50000,25000,10000),5000)
			xlabels	<- seq(0,myxaxis[2],xstep)
			axis(1,at=xlabels,labels=xlabels/1000)
			}else{
			axis(1, at=c(0,100,1000,10000,100000),labels=c(0,0.1,1,10,100),las=1)
			}
		if(addglacials)
			{
			addgeo()
			}
		# now add data:
		polygon(x=c(mylist[[i]]$year,rev(mylist[[i]]$year)),y=c(mylist[[i]]$Ne_2.5,rev(mylist[[i]]$Ne_97.5)),col=mycolours[i],border=NA) 
		points(mylist[[i]]$year,mylist[[i]]$Ne_median,type="l",lwd=1)
		points(mylist[[i]]$year,mylist[[i]]$Ne_87.5,type="l",lty=3,lwd=1)
		points(mylist[[i]]$year,mylist[[i]]$Ne_12.5,type="l",lty=3,lwd=1)
		mtext(mypop,side=3,line=-2.5,cex=2)
		}
	if(!is.null(export))
		{
		dev.off()
		cat(paste("A file called 'stairwayplot.",mystring,"' has been exported to a the 'Demography' directory.",sep=""),sep="\n")
		}
	setwd(mysambar$inputdatadir)
	}
	
# End of population demography analyses 
###############################################################################################################

	
	


###############################################################################################################
# Selection analyses

# Another not explored option, for phased data I suppose: R package rEHH
selectionanalyses<-function(export=NULL,do_meta=TRUE,do_pairwise=FALSE,do_pheno=FALSE,add_bayescan=FALSE,phenolabels=c("pheno1","pheno2"),do_outflank=TRUE,do_fsthet=FALSE,bayescan_mapfile=NULL,silent=TRUE)
	{
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	# check whether bayescan output files are provided if needed:
	setwd(mysambar$inputfilesdir)
	mybayefiles <- list.files(pattern = "\\.bayescanout.fst.txt$")
	if(length(mybayefiles)<1&add_bayescan)
		{
		cat("ERROR: the inputfiles directory does not contain files with the extension 'bayescanout.fst'.",sep="\n")
		return(cat("Either set the flag 'add_bayescan' to FALSE or place bayescan output files in the inputfiles directory (see Sambar manual for more details).",sep="\n"))
		}
	setwd(mysambar$selectiondir)
	if(!silent){cat("run_locusWCfst",sep="\n")}
	run_locusWCfst(export="pdf")	# in case calcdistance() hasn't been executed yet.
	if(do_meta)
		{
		cat("Executing selection analyses for the metapopulation.",sep="\n")
		cat("Running PCadapt...",sep="\n")
		setwd(mysambar$inputfilesdir)
		if(!file.exists("metapop.filter2.letter.ped"))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="metapop.filter2.letter",geno_nr=FALSE,do_all=FALSE)
			}
		runPCadapt(my_dataset="metapop")
		if(do_outflank)
			{
			cat("Running OutFLANK...",sep="\n")
			runOutflank(my_dataset="metapop")
			}
		if(do_fsthet)
			{
			cat("Running fsthet...",sep="\n")
			runfsthet(export=TRUE,dataset="metapop",reps=10,fstmethod="betahat",doanalysis=TRUE)
			}
		cat("Generating Fdist plot...",sep="\n")
		Fdist_plot(my_dataset="metapop",showlegend=TRUE,showlabels=FALSE,exporttype="pdf",axislabels=TRUE,add_borders=FALSE,add_outliers=TRUE,dothin=TRUE)
		Fdist_plot(my_dataset="metapop",showlegend=FALSE,showlabels=FALSE,exporttype="pdf",axislabels=TRUE,add_borders=FALSE,add_outliers=FALSE,dothin=TRUE)
		# plot_scanlog(doexport="pdf",addGWDS=FALSE,addPCadapt=TRUE,add_outflank=do_outflank,addbayescan=add_bayescan,mydataset="metapop",outflankq=FALSE,markoutpheno=FALSE)
		cat("Plotting -log of locus specific p-values outputted by the selection scan(s)...",sep="\n")
		plot_scanlog(doexport="pdf",mydataset="metapop",outflankq=TRUE,markoutpheno=FALSE)
		cat("2D-plots...",sep="\n")
		multiplotp(doexport="pdf",add_numbers=FALSE,my_dataset="metapop")
		cat("Creating Venn diagram...",sep="\n")
		plot_venn(my_dataset="metapop")
		cat("Creating piecharts of minor allele frequencies...",sep="\n")
		multipiemaf(my_dataset="metapop",do_export=TRUE)
		cat("Writing outliers to bed files...",sep="\n")
		writebed(my_dataset="metapop")
		}
	if(do_pairwise)
		{
		cat("Executing selection analyses for all pairwise population comparisons.",sep="\n")
		run_pairwise(dopheno=FALSE,allpairwise=TRUE,addbayescan=add_bayescan,dooutflank=do_outflank,dofsthet=do_fsthet)						
		cat("Plotting -log p values...",sep="\n")
		multi_plot_scanlog(allpairwise=TRUE,do_export=export,outflank_q=FALSE)
		cat("Creating histograms...",sep="\n")
		gwdshisto_multi(doexport=TRUE,allpairwise=TRUE)	
		cat("Creating He-Fst scatterplots...",sep="\n")
		pheno_Fdist_plot(doexport=export,allpairwise=TRUE,mylabels=phenolabels)
		}
	if(do_pheno)
		{
		if(is.null(inds$type))
			{
			return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
			}
		cat("Calculating minor allele frequencies for pheno...",sep="\n")
		pheno_maf(indthreshold=inds$filter)
		cat("Executing selection analyses for pheno1 against pheno2.",sep="\n")
		run_pairwise(dopheno=TRUE,addbayescan=add_bayescan,dooutflank=do_outflank,dofsthet=do_fsthet,bayescanmapfile=bayescan_mapfile)						
		cat("Plotting -log p values...",sep="\n")
		multi_plot_scanlog(allpairwise=FALSE,do_export=export,outflank_q=FALSE)
		cat("2D-plots...",sep="\n")
		multiplotp(doexport="pdf",add_numbers=FALSE,my_dataset="pheno")
		cat("Creating Manhattan plots...",sep="\n")
		pheno_manhattan(doexport=export,myphenolabels=phenolabels)								
		cat("Creating histograms...",sep="\n")
		gwdshisto_multi(doexport=TRUE,allpairwise=FALSE)		
		gwdshisto()	# histogram for pheno1 vs pheno2
		cat("Creating He-Fst scatterplots...",sep="\n")	
		pheno_Fdist_plot(doexport=export,allpairwise=FALSE,mylabels=phenolabels)
		cat("Creating piecharts of minor allele frequencies...",sep="\n")
		multipiemaf(my_dataset="pheno",do_export=TRUE)
		cat("Note that outliers for pooled data (pheno1 vs pheno2) is meaningful if (and only if) populations within both groups are isolated from each other (i.e. no gene flow).",sep="\n")
		cat("Independency of populations can be inferred from output of calcdistance() and calcdiversity() function.",sep="\n")
		}
	setwd(mysambar$inputdatadir)
	# makebayenvinput()
	}

run_pairwise<-function(dopheno=FALSE,do_analysis=TRUE,allpairwise=FALSE,pheno_labels=NULL,mylabels=NULL,popnames=mysambar$populations,addbayescan=FALSE,dooutflank=TRUE,dofsthet=FALSE,bayescanmapfile=NULL)
	{
	if(is.null(inds$type)&!allpairwise)
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	# find all pairwise comparisons between type1 and type2:
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type1		<- type1[order(type1)]
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		type2		<- type2[order(type2)]
		allcombi	<- t(expand.grid(type1,type2))
		}
	## pairwise comparisons:
	ncombi		<- ncol(allcombi)
	for(my_i in c(1:ncombi))
		{
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		my_pair		<- paste(my_pops[1],my_pops[2],sep="_")
		cat(my_pair,sep="\n")
		indselect	<- inds$filter&(inds$pop==allcombi[1,my_i]|inds$pop==allcombi[2,my_i])
		combiname	<- paste(my_pair,"filter2.letter",sep=".")
		cat("Running genome wide differentiation scan...",sep="\n")
		gwdsfisher(my_dataset=my_pair)
		cat("Running PCadapt...",sep="\n")
		setwd(mysambar$inputfilesdir)
		if(!file.exists(paste(combiname,"ped",sep=".")))
			{
			exportdata(indsfilter=indselect,snpsfilter=snps$filter2,export_name=combiname,geno_nr=FALSE,do_all=FALSE)
			}
		runPCadapt(K=2,popnames=c(mypop_1,mypop_2),my_dataset=my_pair)
		if(dooutflank)
			{
			cat("Running OutFLANK...",sep="\n")
			runOutflank(indselection=indselect,my_dataset=my_pair)
			}
		if(addbayescan)
			{
			cat("Obtaining Bayescan results...",sep="\n")
			getbayescan(my_dataset=my_pair,inputmapfile=bayescanmapfile)
			}
		if(dofsthet)
			{
			cat("Running fsthet...",sep="\n")
			runfsthet(export=TRUE,dataset=my_pair,reps=10,fstmethod="betahat",doanalysis=TRUE)
			}
		cat("Creating Venn diagram...",sep="\n")
		plot_venn(my_dataset=my_pair)
		cat("2D-plots...",sep="\n")
		multiplotp(doexport="pdf",add_numbers=FALSE,my_dataset=my_pair)
		cat("Writing outliers to bed files...",sep="\n")
		writebed(my_dataset=my_pair)
		}
	## pooled comparison:
	if(dopheno)
		{
		cat("pheno1_pheno2 (pooled data)",sep="\n")
		locusWCfst(my_dataset="pheno",do_plot=FALSE)
		cat("Running genome wide differentiation scan...",sep="\n")
		gwdsfisher(my_dataset="pheno")
		cat("Running PCadapt...",sep="\n")
		setwd(mysambar$inputfilesdir)
		if(!file.exists("pheno.filter2.letter.ped"))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="pheno.filter2.letter",geno_nr=FALSE,do_all=FALSE,do_pheno=TRUE)
			}
		# Here there are two options: run PCadapt with K = 2 (because two phenotypes) or with K equalling number of populations. 
		runPCadapt(K=2,popnames=mysambar$populations,my_dataset="pheno")	# K equalling 2
		# runPCadapt(popnames=mysambar$populations,my_dataset="pheno")		# K equalling number of populations
		if(dooutflank)
			{
			cat("Running OutFLANK...",sep="\n")
			runOutflank(indselection=indselect,my_dataset="pheno",popcolumn=inds$type)
			}
		if(addbayescan)
			{
			cat("Obtaining Bayescan results...",sep="\n")
			getbayescan(my_dataset="pheno",inputmapfile=bayescanmapfile)
			}
		if(dofsthet)
			{
			cat("Running fsthet...",sep="\n")
			runfsthet(export=TRUE,dataset="pheno",reps=10,fstmethod="betahat",doanalysis=TRUE,phenonames=pheno_labels)
			}
		cat("Creating Venn diagram...",sep="\n")
		plot_venn(my_dataset="pheno")
		vennlogfiles <- list.files(pattern = "\\.log$")
		unlink(vennlogfiles)
		cat("Writing outliers to bed files...",sep="\n")
		writebed(my_dataset="pheno")
		}
	}

multipiemaf<-function(my_dataset="pheno",do_export=TRUE)
	{
	mytests		<- colnames(snps)[grep(paste("logp",my_dataset,sep="_"),colnames(snps))]
	mytests		<- gsub(paste("logp",my_dataset,sep="_"),"",mytests)
	scancols	<- c("blue","darkgreen","red","darkorchid4","orange")
	myscans		<- c("rfisher","PCadapt","Bayescan","Fsthet","OutFLANK")
	for(mytest in mytests)
		{
		cat(mytest,sep="\n")
		scancol	<- scancols[myscans==mytest] 
		piemaf(export=do_export,popnames=mysambar$populations,mycol=scancol,myscan=mytest,mydataset=my_dataset)
		}
	}
	
piemaf<-function(export=FALSE,popnames=mysambar$populations,mycol="blue",myscan="rfisher",mydataset="pheno")
	{
	if(myscan=="OutFLANK")
		{
		mycolumn<- unlist(snps[,paste(myscan,"_",mydataset,sep="")])
		}else{
		mycolumn<- unlist(snps[,paste(myscan,"out_",mydataset,sep="")])
		}
	myloci	<- as.vector(snps$name[mycolumn])	
	if(length(myloci)==0)
		{
		return(cat("No outliers. Skipping piecharts.",sep="\n"))
		}
	nloci	<- length(myloci)
	if(nloci>200)
		{
		cat("More than 200 outlier loci. Sambar will plot first 200 outlier only.",sep="\n")
		myloci	<- myloci[1:200]
		nloci	<- 200
		}
	npops	<- length(popnames)
	if(export)
		{
		plotname<-	paste("piechart.mafperpop",myscan,mydataset,"pdf",sep=".")
		pdf(plotname,height=npops*2+3,width=nloci*2+4)
		}
	layout(matrix(c(1:(npops*nloci)),npops,nloci,byrow=FALSE))
	par(mar=c(0.5,1,0.5,1),oma=c(2,30,24,2))
	for(k in c(1:nloci))
		{
		mylocus	<- myloci[k] 
		#cat(mylocus,sep="\n")
		for (j in c(1:npops))
			{
			mypop		<- popnames[j]
			nind		<- nrow(inds[inds$filter&inds$pop==mypop,])
			popmiss		<- snps[snps$name==mylocus,paste("miss",mypop,sep="_")]
			if(popmiss<1)		
				{
				popmaf		<- snps[snps$name==mylocus,paste("maf",mypop,sep="_")]
				nallelles	<- round((2*nind)*(1-popmiss))
				popminor	<<- round(nallelles*popmaf)
				popmajor	<<- nallelles-popminor
				pie(c(popminor,popmajor),labels=NA,main=NA,col=c("grey50",mycol),border=NA)
				}else{
				# if no data available for population:
				pie(c(1,0),labels=NA,main=NA,col=c("white","white"),border="grey50")
				}
			if(j==1)
				{
				mtext(side=3,mylocus,las=2,cex=2,line=-0.5)
				}
			if(k==1)
				{
				mtext(side=2,mypop,cex=3.5,las=1,line=0.5)
				}
			}
		}
	if(export){dev.off()}
	}
	
runfsthet<-function(export=FALSE,dataset=NULL,reps=10,fstmethod="betahat",doanalysis=TRUE,phenonames=NULL)
	{
	# dataset should be NULL, pop1_pop2, or meta.
	#
	# 4 options for fstmethod:
	# - For Wright's Fst: fst, FST, Fst
	# - For a variance-based Fst (beta): var, VAR, Var
	# - For Cockerham and Weir's Theta: theta, Theta, THETA	# no shark fin, mostly negative values
	# - For Beta-hat (LOSITAN): betahat, Betahat, BETAHAT	# shark fin
	#
	if(doanalysis)
		{
		setwd(mysambar$inputdatadir)
		genepopfile 	<- list.files(pattern = "genepop")
		if(length(genepopfile)==0)
			{
			cat("ERROR: No file with extension 'genepop' found in the directory:",sep="\n")
			cat(getwd(),sep="\n")
			return(cat("The fsthet software needs a genepop file as input. Operation halted.",sep="\n"))
			}
		if(length(genepopfile)>1)
			{	
			cat("WARNING: SambaR found multiple files with the string 'genepop' in the directory:",sep="\n")
			cat(getwd(),sep="\n")
			return(cat("Only keep the file which should be used as input and try again.",sep="\n"))
			}
		gpop			<- my.read.genepop(genepopfile)
		gpop2			<- gpop[order(gpop$ind.names),]
		if(any(inds$name!=gpop2$ind.names))
			{
			return(cat("ERROR: order of sample names in genepop file does not correspond with order in inds dataframe.",sep="\n"))
			}
		if(!is.null(dataset))
			{
			if(dataset=="pheno")
				{
				if(!"type"%in%colnames(inds))
					{
					return(cat("Dataset set to 'pheno' but no column 'inds$type'. Define the column inds$type and try again. See SambaR manual for more details.",sep="\n"))
					}
				if(is.null(phenonames))
					{
					mytypes		<- c("pheno1","pheno2")
					}else{
					mytypes		<- phenonames
					}
				mylabel			<- "pheno"
				cat(paste("Starting fsthet analyses for comparison between ",mytypes[1]," and ",mytypes[2],".",sep=""),sep="\n")
				gpop2$popinfo	<- as.character(inds$type)
				gpop3			<- gpop2[inds$filter,]
				}else{
				if(dataset=="metapop")
					{
					cat("SambaR will run fsthet on entire dataset (i.e. metapop: all populations combined).",sep="\n")
					gpop2$popinfo	<- inds$pop	
					gpop3			<- gpop2
					mylabel			<- "metapop"
					}else{
					mypop1			<- strsplit(dataset, "[_]")[[1]][1]
					mypop2			<- strsplit(dataset, "[_]")[[1]][2]
					mylabel			<- dataset
					cat(paste("Starting fsthet analyses for comparison between ",mypop1," and ",mypop2,".",sep=""),sep="\n")
					gpop2$popinfo	<- as.character(inds$pop)	# fsthet crashes if popinfo column consists of factors
					gpop3			<- gpop2[inds$filter&(inds$pop==mypop1|inds$pop==mypop2),]
					}
				}
			}else{
			cat("No dataset defined. SambaR will run fsthet on entire dataset (i.e. metapop: all populations combined).",sep="\n")
			gpop2$popinfo	<- as.character(inds$pop)	# fsthet crashes if popinfo column consists of factors	
			gpop3			<- gpop2
			mylabel			<- "metapop"
			}
		setwd(mysambar$selectiondir)
		nind	<- nrow(gpop3)
		cat(paste("Input dataset contains",nind,"individuals which passed filter settings as defined with the filterdata() function.",sep=" "),sep="\n")
		cat(paste("The number of bootstrap replicates (defined with the 'reps' argument) is set to ",reps,". Default is 10.",sep=""),sep="\n")
		cat("Starting 'fsthet' analysis now. This analysis may take a while.",sep="\n")
		if(export)
			{
			plotname		<- paste("fsthet",fstmethod,mylabel,"pdf",sep=".")
			pdf(plotname)
			}
		gpop3				<<- gpop3
		fsthetout			<<- fhetboot(gpop3,fst.choice=fstmethod,alpha=0.05,nreps=reps)
		if(export)
			{
			dev.off()
			cat(paste("A file called '",plotname,"' has been written to the directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")	
			}
		fsthetout$locus		<<- substring(fsthetout$Locus, 2)
		cat("Output of fsthet software is stored in a dataframe called 'fsthetout'.",sep="\n")
		}else{
		if(!is.null(dataset))
			{
			if(dataset=="pheno")
				{
				mytypes			<- unique(inds$type)
				mylabel			<- "pheno"
				}else{
				mylabel			<- dataset
				}
			}else{
			mylabel			<- "metapop"
			}
		}
	#
	# remove snps which occur on same position in genome:
	setwd(mysambar$inputdatadir)
	if(file.exists("removedloci.txt"))
		{
		removed			<- read.table("removedloci.txt",header=TRUE)
		fsthetout$bool	<- fsthetout$locus%in%removed$name
		fsthetout		<- fsthetout[!fsthetout$bool,]
		}
	setwd(mysambar$selectiondir)
	#
	# add results to snps dataframe:
	snpstemp	<- snps[order(snps$name),]
	fsttemp		<- fsthetout[order(fsthetout$locus),]
	if(any(snpstemp$name!=fsttemp$locus))
		{
		return(cat("ERROR: order of sample names in genepop file does not correspond with order in inds dataframe.",sep="\n"))
		}
	snpstemp$fsthetlogp	<- NULL
	snpstemp$fsthetout	<- NULL
	snpstemp$fsthetlogp	<- -log10(fsttemp$P.value)
	outliers			<- fsttemp$P.value<(0.05/nrow(fsttemp))
	snpstemp$fsthetout	<- outliers
	noutliers			<- length(outliers[outliers])
	cat(paste("Found ",noutliers," outlier(s).",sep=""),sep="\n")
	names(snpstemp)[names(snpstemp) == "fsthetlogp"] 	<- paste("fsthetlogp",mylabel,sep = "_")
	names(snpstemp)[names(snpstemp) == "fsthetout"] <- paste("fsthetout",mylabel,sep = "_")
	#
	# reorder:
	snps				<<- snpstemp[order(snpstemp$chr,as.numeric(snpstemp$pos)),]
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: after reordering, column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	cat("Columns 'fsthetlogp' and 'fsthetout' have been added to the snps dataframe.",sep="\n")
	}
		
plot_diagram<-function(export=NULL,mycol="grey80")
	{
	#install.packages('diagram')
	#library('diagram')
	my_text_size 		<- 1.5
	segment_size		<- 0.08
	width_height_ratio	<- 2.5
	xvector				<- c(rep(0.75,3),rep(0.25,2))
	yvector				<- c(0.125,0.375,0.75,0.25,0.75)
	pos					<- cbind(xvector,yvector)
	my_label			<- c("founder_2\n(Barff)", "founder_1\n(Busen)", "both founders\n(Busen & Barff)","source\n(Norway)","source\n(Norway)")
	# plot:
	graphics.off()	
	if(!is.null(export))
		{
		if(export=="pdf"){pdf("Approach.diagram.pdf",onefile=FALSE)}
		if(export=="emf"){emf("Approach.diagram.emf")}
		}
	openplotmat()
	plot(pos,xlim=c(0,1),ylim=c(0,1),type='n',xaxt='n',yaxt='n',ann=FALSE,bty='n')
	straightarrow (from = pos[1, ], to = pos[4, ],arr.pos=1)
	straightarrow (from = pos[2, ], to = pos[4, ],arr.pos=1)
	straightarrow (from = pos[3, ], to = pos[5, ],arr.pos=1)
	for(i in c(1:length(my_label)))
		{
		textrect(mid = pos[i,], shadow.size = 0, radx = segment_size*width_height_ratio, rady = segment_size, lab = my_label[i], cex = my_text_size, box.col = mycol)
		}
	text(x=0.5,y=0.9,labels="pooled approach",cex=1.5,font=2)
	text(x=0.5,y=0.5,labels="pairwise approach",cex=1.5,font=2)
	if(!is.null(export)){dev.off()}
	}

pheno_Fdist_plot<-function(doexport=NULL,allpairwise=FALSE,popnames=mysambar$populations,addoutliers=TRUE,mylabels=NULL)
	{
	popsubset		<- as.vector(which(table(inds$pop[inds$filter])==0))
	if(length(popsubset)>0)
		{
		popnames		<- popnames[-(popsubset)]
		}
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		ncombi		<- ncol(allcombi)
		ntiles		<- ncombi
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type&inds$filter]))
		type2		<- as.vector(unique(inds$pop[(!inds$type)&inds$filter]))
		allcombi	<- t(expand.grid(type1,type2))		
		ncombi		<- ncol(allcombi)
		ntiles		<- ncombi+1
		# don't add pheno in this case (because already incorporated below)
		}
	#
	graphics.off()
	if(!is.null(doexport))
		{
		plotname	<- ifelse(allpairwise,"Fdist_outliers_allpairwise","Fdist_outliers_pheno")
		if(doexport=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=(ncombi+1)*4,height=5)}
		if(doexport=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=(ncombi+1)*4,height=5)}
		if(doexport=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=(ncombi+1)*400,height=500)}
		if(doexport=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=(ncombi+1)*4,height=5)}
		}
	par(mfrow=c(1,ntiles),oma=c(5,6,1,1),mar=c(1,1,1,1),cex.axis=2.5,cex.lab=3,cex.main=3.5)	
	if(!allpairwise)
		{
		#cat("pheno",sep="\n")
		Fdist_plot(my_dataset="pheno",axislabels=FALSE,my_labels=mylabels,add_outliers=addoutliers,add_borders=TRUE)
		}
	for(my_i in c(1:ncombi))
		{
		#cat(my_i,sep="\n")
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		my_pair		<- paste(my_pops[1],my_pops[2],sep="_")
		#cat(my_pair,sep="\n")
		if(!paste("WeirHe",my_pair,sep="_")%in%colnames(snps))
			{
			cat(paste("WARNING: snps dataframe does not contain a column with Weir He scores for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}else{
			y_ax	<- ifelse(allpairwise&my_i==1,'s','n')
			if(addoutliers)
				{
				Fdist_plot(my_dataset=my_pair,axislabels=FALSE,y_axis=y_ax,add_outliers=TRUE,add_borders=TRUE)
				}else{
				Fdist_plot(my_dataset=my_pair,axislabels=FALSE,y_axis=y_ax,add_outliers=FALSE,add_borders=TRUE)
				}
			}
		}
	mtext("Weir & Cockerham Fst", side = 2, cex = 2, line = 3,outer=TRUE)
	mtext("Weir & Cockerham He", side = 1, cex = 2, line = 3,outer=TRUE)
	if(!is.null(doexport)){dev.off()}
	}

pheno_manhattan<-function(doexport=NULL,allpairwise=FALSE,popnames=mysambar$populations,myphenolabels=c("pheno1","pheno2"))
	{
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		}
	ncombi		<- ncol(allcombi)
	#
	graphics.off()
	if(!is.null(doexport))
		{
		if(doexport=="eps"){postscript("Manhattan_gwds.pheno.eps",family=mysambar$myfont,width=14,height=(ncombi+1)*2.5)}
		if(doexport=="pdf"){pdf("Manhattan_gwds.pheno.pdf",family=mysambar$myfont,width=14,height=(ncombi+1)*2.5)}
		if(doexport=="png"){png("Manhattan_gwds.pheno.png",family=mysambar$myfont,width=1200,height=(ncombi+1)*250)}
		if(doexport=="wmf"){win.metafile("Manhattan_gwds.pheno.wmf",family=mysambar$myfont,width=14,height=(ncombi+1)*2.5)}
		}
	par(mfrow=c((ncombi+1),1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,1.5),cex.axis=2,cex.lab=2.5)
	gwdsmanhattan(my_dataset="pheno",my_labels=myphenolabels,myxaxis='n')
	for(my_i in c(1:ncombi))
		{
		my_xaxis	<- ifelse(my_i==ncombi,'s','n')
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		my_pair		<- paste(my_pops[1],my_pops[2],sep="_")
		if(paste("rfisherlogp",my_pair,sep="_")%in%colnames(snps))
			{
			gwdsmanhattan(my_dataset=my_pair,myxaxis=my_xaxis)
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}
		}
	mtext("Fisher exact test score",side=2,line=0.5,cex=2.5,outer=TRUE)
	mtext("SNP index",side=1,line=4,cex=2.5,outer=TRUE)
	if(!is.null(doexport))
		{
		dev.off()	
		cat("Manhattan plot exported to the Selection subdirectory.",sep="\n")
		}
	}	

# GWDS (Fisher test)
# This function is not as fast as plink. If you have millions of snps, probs better to use plink.
# comparison of output:
# my R function:	0.1374497 0.0000000 0.3262634 0.5235213	1.9187528
# plink:			0.1374247 0.0000000 0.3262843 0.5235732	1.9186842 		
# odds ratios are different though.	
	
gwdsfisher<-function(my_dataset="pheno",pheno=inds$type)
	{
	# This function expects as input for my_dataset either the string 'pheno' or strings defining two populations separated by underscore (e.g. 'pop1_pop2') 
	if(my_dataset=="pheno")
		{
		popfilter	<- rep(TRUE,nrow(inds))
		}else{
		pop_1		<- unlist(strsplit(my_dataset, split="_"))[1]
		pop_2		<- unlist(strsplit(my_dataset, split="_"))[2]
		popfilter	<- inds$pop==pop_1|inds$pop==pop_2
		}
	# For phenotype 1:
	# number of minor alleles per locus:
	if(my_dataset=="pheno")
		{
		indfilter		<- inds$filter&pheno&popfilter
		}else{
		indfilter		<- inds$filter&popfilter
		}
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for inds$pheno==TRUE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor1			<- as.vector(glSum(mygenlight[indfilter,]))
	major1			<- nonmisscount-minor1
	# For phenotype 2:
	if(my_dataset=="pheno")
		{
		indfilter		<- inds$filter&(!pheno)&popfilter
		}else{
		indfilter		<- inds$filter&popfilter
		}
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for inds$pheno==FALSE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor2			<- as.vector(glSum(mygenlight[indfilter,]))
	major2			<- nonmisscount-minor2	
	#
	snps$rfisherlogp	<<-	NULL
	snps$rfisherout		<<- NULL
	macmatrix			<- rbind(major1,minor1,major2,minor2)
	plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(1,2,3,4),i],2,2,byrow=TRUE)})
	rfisherp			<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
	snps$rfisherlogp	<<- -log(rfisherp)
	snps$rfisherlogp[snps$rfisherlogp<0.0001]	<<- 0	# 10-11-2019: to avoid negative or infinitely small values
	#
	cat("Testing which loci are outliers using Bonferroni correction...",sep="\n")
	# we apply the bonferroni correction and assume that the distribution of the logp values fit an exponential distribution
	mymean				<- mean(snps$rfisherlogp[snps$filter2])	
	myrate				<- 1/mymean
	mybonf				<- 1-(0.05/(nrow(snps[snps$filter2,])))
	myvalue				<- qexp(mybonf,myrate)
	snps$rfisherout		<<-	snps$rfisherlogp>myvalue
	noutliers			<- nrow(snps[snps$rfisherout,])
	cat(paste("Found",noutliers,"outlier loci.",sep=" "),sep="\n")
	# rename columns:
	names(snps)[names(snps) == "rfisherlogp"] 	<<- paste("rfisherlogp",my_dataset,sep = "_")
	names(snps)[names(snps) == "rfisherOR"] 	<<- paste("rfisherOR",my_dataset,sep = "_")
	names(snps)[names(snps) == "rfisherout"] 	<<- paste("rfisherout",my_dataset,sep = "_")
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

gwdshisto_multi<-function(doexport=FALSE,allpairwise=FALSE,popnames=mysambar$populations)
	{
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		ncombi		<- ncol(allcombi)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		ncombi		<- ncol(allcombi)+1
		}
	for(k in c(1:ncombi))
		{
		graphics.off()
		if(k==ncombi&!allpairwise)
			{
			my_dataset	<- "pheno"
			mypop_1		<- "pheno1"
			mypop_2		<- "pheno2"
			}else{
			mypop_1		<- allcombi[1,k]
			mypop_2		<- allcombi[2,k]
			my_pops		<- c(mypop_1,mypop_2)
			my_pops		<- my_pops[order(my_pops)]
			my_dataset	<- paste(my_pops[1],my_pops[2],sep="_")
			}
		#cat(my_dataset,sep="\n")
		if(paste("rfisherlogp",my_dataset,sep="_")%in%colnames(snps))
			{
			mylogp		<- snps[,paste("rfisherlogp",my_dataset,sep="_")]
			if(length(table(mylogp))==1)
				{
				cat(paste("WARNING: no variation in fisher test logp values for population pair ",mypop_1," and ",mypop_2,". Omitting histogram.",sep=""),sep="\n")
				}else{
				if(doexport){pdf(paste("GWDS.histo",my_dataset,"pdf",sep="."),width=10,height=6)}
				par(oma=c(2.5,3,0,0))
				gwdshisto(myinput=mylogp,myxaxt='s')
				mtext(my_dataset,side=3,line=-1,cex=1.5)
				mtext("Frequency",side=2,line=4,cex=2)
				mtext("-log(pvalue)",side=1,line=2.5,cex=2)
				if(doexport){dev.off()}
				}
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}
		}
	}	
		
gwdshisto<-function(myinput=snps$rfisherlogp_pheno,nbreaks=100,myxaxt='s')
	{
	mylogscores	<- myinput[snps$filter2]	
	if(length(table(mylogscores))==1)
		{
		cat(paste("WARNING: no variation in fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
		}		
	nloci		<- length(mylogscores)
	hist(mylogscores,freq=FALSE,breaks=nbreaks,col="grey",las=1,main="",xlab="",ylab="",cex.axis=1.5,xaxt=myxaxt)
	mycurve		<- rexp(n=nloci,rate=1/mean(mylogscores))
	mydensity	<- density(mycurve)
	lines(mydensity$x,mydensity$y,col="red",lwd=2)
	}

# first execute gwdsfisher 
gwdsmanhattan<-function(my_dataset="pheno",exporttype=NULL,mycolours=c("black","red","orange"),mycex=1,mycexout=1.5,my_labels=NULL,myxaxis='s',addpairwiseout=TRUE,addlab=FALSE)
	{
	#if(any(nchar(my_labels)>6))
	#	{
	#	my_labels<-substr(my_labels,1,6)
	#	}
	# rather than black we can also use: mycolours=c("#99CCFF","red","orange")
	# input vectors:
	mylogp				<- snps[,paste("rfisherlogp",my_dataset,sep="_")]
	myfisherout			<- snps[,paste("rfisherout",my_dataset,sep="_")]
	# bonferroni threshold:
	mymean				<- mean(mylogp[snps$filter2])	
	myrate				<- 1/mymean
	mybonf				<- 1-(0.05/(nrow(snps[snps$filter2,])))
	myvalue				<- qexp(mybonf,myrate)
	# find maximum logp value for all comparisons (pooled and pairwise):
	mylogpdf			<- snps[, grep('^rfisherlogp', names(snps))] 
	mymax				<- 1.1*max(mylogpdf)
	# define plot colours:
	myfishercol			<- mycolours[as.factor(myfisherout)]
	#outvectors			<- names(snps)[grepl("rfisherout",names(snps))]
	myoutdf				<- snps[, grep('^rfisherout', names(snps))]
	myoutallvec			<- apply(myoutdf, 1,any)
	myoutother			<- myoutallvec&(!myfisherout)
	# plot:
	snpnumber			<- c(1:nrow(snps))
	if(!is.null(exporttype))
		{
		pdf("Manhattan.pdf",width=15,height=5)
		par(oma=c(0,1,0,1.5),cex.axis=1.5)
		}
	plot(snpnumber[snps$filter2],mylogp[snps$filter2],col=mycolours[1],cex=mycex,ylim=c(0,mymax),pch=16,ylab="",xlab="",main="",xaxt=myxaxis,las=1)
	if(addpairwiseout)
		{
		points(snpnumber[myoutother&snps$filter2],mylogp[myoutother&snps$filter2],col=mycolours[3],cex=mycexout,pch=16)
		}
	points(snpnumber[myfisherout&snps$filter2],mylogp[myfisherout&snps$filter2],col=mycolours[2],cex=mycexout,pch=16)
	segments(x0=0,y0=myvalue,x1=nrow(snps),y1=myvalue,lty=2,lwd=2)
	if(my_dataset=="pheno")
		{
		if(!is.null(my_labels))
			{
			mtext(paste(my_labels[1],"vs",my_labels[2],sep=" "),side=4,cex=1.25,line=1.5)
			}else{
			mtext("typeA vs typeB",side=4,cex=1.25,line=1.5)
			}
		}else{
		pop_1		<- unlist(strsplit(my_dataset, split="_"))[1]
		pop_2		<- unlist(strsplit(my_dataset, split="_"))[2]
		mtext(paste(pop_1,"vs",pop_2,sep=" "),side=4,cex=1.25,line=1.5)
		}
	if(addlab)
		{
		mtext("SNP index",side=1,cex=2,line=3)
		mtext("-ln(p)",side=2,cex=2,line=3)
		}
	if(!is.null(exporttype)){dev.off()}
	}

runPCadapt<-function(K=NULL,myalpha=0.05,popnames=mysambar$populations,my_dataset="metapop",currentdir=FALSE,do_plot=FALSE,mycorrection="holm")
	{
	cat("PCadapt will be run using 3 methods for multiple testing correction: Bonferroni, Benjamini-Hochberg, and Holm.",sep="\n")
	cat(paste("The",mycorrection,"method will eventually be used."),sep="\n")
	cat("To use another correction method, change the input to the mycorrection flag.",sep="\n")
	#
	if(is.null(K))
		{
		npops		<- length(popnames)
		cat("WARNING: K not defined. Assuming K equals length of input vector to popnames flag (default input vector is mysambar$populations).",sep="\n")
		}else{
		npops		<- K
		cat(paste("Using predefined K of ",npops,".",sep=""),sep="\n")
		}
	if(!currentdir){setwd(mysambar$inputfilesdir)}
	myinput		<- paste(my_dataset,"filter2.letter.ped",sep=".")
	x			<- read.pcadapt(myinput,type="ped")
	z			<- pcadapt(x,K=npops)
	# optional graphs (not insightful for main conclusion):
	# plot(z,option="qqplot",threshold=0.1)
	# hist(z$pvalues,xlab="p-values",main=NULL,breaks=50)
	# plot(z,option="stat.distribution")
	# we do both bonferroni_correction and Bennjamini-Hochberg (BH) correction:
	for (my_k in c(1:3))
		{
		if(my_k==1){padj 	<- p.adjust(z$pvalues,method="bonferroni")}
		if(my_k==2){padj	<- p.adjust(z$pvalues,method="BH")}		
		if(my_k==3){padj	<- p.adjust(z$pvalues,method="holm")}	
		myoutliers 		<- which(padj<myalpha)
		pcadaptlogp		<- -log(padj) 
		pcadaptlogp		<<- pcadaptlogp
		noutliers		<- length(myoutliers)
		## store outliers (TRUE/FALSE) in snps dataset:
		# remove previous results, if present
		if(!is.null(snps$PCadaptoutlier))
			{
			snps$PCadaptoutlier	<<- NULL
			}
		#outtemp		<- snps[snps$filter2,]
		myinput2		<- paste(my_dataset,"filter2.letter.map",sep=".")
		mymapfile		<- read.table(myinput2)
		mymapfile$V1	<- NULL
		mymapfile$V3	<- NULL
		mymapfile$V4	<- NULL
		mymapfile$PCadaptoutlier<- TRUE
		colnames(mymapfile)[1]	<- "name"
		outtemp2		<- mymapfile[myoutliers,]
		outtemp3 		<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
		#outtemp4		<- outtemp3[order(as.numeric(outtemp3$chr),as.numeric(outtemp3$pos)),]
		outtemp4		<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
		outtemp4$PCadaptoutlier[is.na(outtemp4$PCadaptoutlier)]<-FALSE
		# just to check:
		# mymapfile		<<- mymapfile
		# outtemp2		<<- outtemp2
		# outtemp3		<<- outtemp3
		# outtemp4		<<- outtemp4
		if(any(outtemp4$name!=snps$name))
			{
			cat("ERROR: something went wrong whilst reordering the data. Contact developer of SambaR.",sep="\n")
			}
		snps			<<- outtemp4
		# change column name:
		if(my_k==1)
			{
			if(mycorrection=="bonferroni")
				{
				mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptout_bonf",my_dataset,sep="_")
				}
			cat(paste("PCadapt detected",noutliers,"outlier loci using the Bonferroni method correction for multiple testing.",sep=" "),sep="\n")
			}
		if(my_k==2)
			{
			if(mycorrection=="BH")
				{
				mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptout_BH",my_dataset,sep="_")
				}
			cat(paste("PCadapt detected",noutliers,"outlier loci using the Benjamini-Hochberg procedure correction for multiple testing.",sep=" "),sep="\n")
			}
		if(my_k==3)
			{
			if(mycorrection=="holm")
				{
				mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptout_holm",my_dataset,sep="_")
				}
			cat(paste("PCadapt detected",noutliers,"outlier loci using the holm correction for multiple testing.",sep=" "),sep="\n")
			}
		names(snps)[names(snps) == "PCadaptoutlier"] <<- mycolumnname
		cat(paste("Outliers are marked as TRUE in the",mycolumnname,"column in the snps dataframe.",sep=" "),sep="\n")
		## store pcadapt -logp scores in snps dataset:
		if(!is.null(snps$PCadaptlogp))
			{
			snps$PCadaptlogp			<<- NULL
			}
		snps$PCadaptlogp				<<- NA
		pcadaptlogp						<<- pcadaptlogp
		snps$PCadaptlogp[snps$filter2]	<<- pcadaptlogp		# 27-09-2019: snps$filter2 or snps$filter?
		# change column name:
		if(my_k==1)
			{
			if(mycorrection=="bonferroni")
				{
				mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptlogp_bonf",my_dataset,sep="_")
				}
			}
		if(my_k==2)
			{
			if(mycorrection=="BH")
				{
				mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptlogp_BH",my_dataset,sep="_")
				}
			}
		if(my_k==3)
			{
			if(mycorrection=="holm")
				{
				mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptlogp_holm",my_dataset,sep="_")
				}
			}
		names(snps)[names(snps) == "PCadaptlogp"] <<- mycolumnname
		snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
		cat(paste("PCadapt -log(p) values are stored in the",mycolumnname,"column in the snps dataframe.",sep=" "),sep="\n")
		}
	if(!currentdir){setwd(mysambar$selectiondir)}
	if(do_plot)
		{
		pdf(paste("PCadapt",my_dataset,"pdf"),width=18,height=9)
		par(mfrow=c(2,1))
		plot(snps$PCadaptlogp_BH_pheno,ylab="",cex.lab=2,cex.axis=1.5,pch=16)
		mtext("Benjamini-Hochberg pvalues",side=2,line=2.5,cex=2)
		points(c(1:nrow(snps))[snps$PCadaptout_BH_pheno],snps$PCadaptlogp_BH_pheno[snps$PCadaptout_BH_pheno],col="blue",pch=16,cex=1.5)
		points(c(1:nrow(snps))[snps$PCadaptout_holm_pheno],snps$PCadaptlogp_BH_pheno[snps$PCadaptout_holm_pheno],col="darkgreen",pch=16,cex=1.5)	
		points(c(1:nrow(snps))[snps$PCadaptout_bonf_pheno],snps$PCadaptlogp_BH_pheno[snps$PCadaptout_bonf_pheno],col="red",cex=1.5,pch=16)
		legend("topleft",legend=c("Bonferroni outliers","holm outliers","Benjamini-Hochberg outliers"),fill=c("red","darkgreen","blue"),bty='n',cex=1.5)
		plot(snps$PCadaptlogp_pheno,ylab="",cex.lab=2,cex.axis=1.5,pch=16)
		mtext("Bonferroni pvalues",side=2,line=2.5,cex=2)
		points(c(1:nrow(snps))[snps$PCadaptout_BH_pheno],snps$PCadaptlogp_pheno[snps$PCadaptout_BH_pheno],col="blue",pch=16,cex=1.5)
		points(c(1:nrow(snps))[snps$PCadaptout_holm_pheno],snps$PCadaptlogp_pheno[snps$PCadaptout_holm_pheno],col="darkgreen",pch=16,cex=1.5)	
		points(c(1:nrow(snps))[snps$PCadaptout_bonf_pheno],snps$PCadaptlogp_pheno[snps$PCadaptout_bonf_pheno],col="red",cex=1.5,pch=16)
		plot(snps$PCadaptlogp_pheno,ylab="",cex.lab=2,cex.axis=1.5,pch=16)
		dev.off()
		}
	}
	
runOutflank<-function(indselection=inds$filter,export=TRUE,my_dataset="metapop",popcolumn=inds$pop2,myloci=snps$name,q_value=FALSE,domerge=TRUE)
	{
	# Optionally fst distribution plots will be exported.
	mymatrix					<- as.matrix(mygenlight[indselection,])
	mymatrix[is.na(mymatrix)] 	<- 9
	outflankinput				<- MakeDiploidFSTMat(SNPmat=mymatrix,locusNames=myloci,popNames=popcolumn[indselection])
	#
	## Calibrating the null distribution of fst-values.
	# To do so we need a pruned dataset.
	# According to the manual you have to remove the loci for which Fst estimates differs strongly from FstNoCorr estimate.
	# We assume that less than 5 percent are outliers:
	mymean				<- mean(outflankinput$FSTNoCorr,na.rm=TRUE)
	myrate				<- 1/mymean
	myvalue				<- qexp(0.95,myrate)
	prunevector			<- outflankinput$FSTNoCorr<myvalue&!is.na(outflankinput$FSTNoCorr)&is.finite(outflankinput$FSTNoCorr)
	# 12-10-2019: I used the above settings for the simulations, but this might be incorrect to do it this way.
	# Because in the function below OutFLANK trims 5 percent of top values and 5 percent of bottom values, so it is double. 
	nrsamples			<- length(inds$pop2[indselection])
	npops				<- length(as.vector(unique(inds$pop2[indselection])))
	# NumberOfSamples is number of populations:
	out_trim 			<- OutFLANK(FstDataFrame=outflankinput[prunevector,],NumberOfSamples=npops,qthreshold=0.05,Hmin = 0.1)
	if(export)
		{
		if(file.exists("OutFlankplots"))
			{
			setwd(file.path(mysambar$selectiondir,"OutFlankplots"))
			}else{
			dir.create(file.path(mysambar$selectiondir,"OutFlankplots"))
			setwd(file.path(mysambar$selectiondir,"OutFlankplots"))
			}
		pdf(paste("Outflank.fstdistribution",my_dataset,"pdf",sep="."))
		OutFLANKResultsPlotter(out_trim)
		dev.off()
		pdf(paste("Outflank.pvalues.righttail",my_dataset,"pdf",sep="."))
		hist(out_trim$results$pvaluesRightTail,main="",xlab="pvalues right tail",ylab="Frequency")
		dev.off()
		setwd(mysambar$selectiondir)
		}
	#
	## So now we have estimated neutral mean FST and df using the pruned dataset (snps$filter).
	# So now we can go back and calculate P-values and q-values for all loci.
	P1 <- pOutlierFinderChiSqNoCorr(outflankinput,Fstbar = out_trim$FSTNoCorrbar,dfInferred = out_trim$dfInferred, qthreshold = 0.05, Hmin=0.1)
	#
	## Outliers?
	tempname				<- paste("OutFLANK",my_dataset,sep="_")
	tempname2				<- paste("OutFLANKlogp",my_dataset,sep="_")
	tempname3				<- paste("OutFLANKlogq",my_dataset,sep="_")
	P1$negativelogp			<- -log(P1$pvalues)
	P1$negativelogq			<- -log(P1$qvalues)
	if(!q_value)
		{
		cat("Using holm corrected p-values rather than q-values (default) to score outliers.",sep="\n")
		P1$pvalues_holm		<- p.adjust(P1$pvalues,method="holm") 
		P1$OutlierFlag		<- P1$pvalues_holm<0.05
		P1$negativelogp		<- -log(P1$pvalues_holm)
		}
	P1$OutlierFlag[is.na(P1$OutlierFlag)]	<- FALSE
	noutliers				<- nrow(P1[P1$OutlierFlag&snps$filter2&!is.na(P1$OutlierFlag),])
	#P1						<<- P1
	cat(paste("OutFLANK detected",noutliers,"outlier loci.",sep=" "),sep="\n")
	if(export)
		{
		setwd(file.path(mysambar$selectiondir,"OutFlankplots"))
		pdf(paste("Outflank.outliers",my_dataset,"pdf",sep="."))
		plot(P1$He[snps$filter2],P1$FST[snps$filter2],pch=19,cex=0.5,col="#99CCFF",xlab="He",ylab="Fst")
		points(P1$He[P1$OutlierFlag],P1$FST[P1$OutlierFlag],pch=19,col="#336633")
		dev.off()			
		setwd(mysambar$selectiondir)
		}
	if(tempname %in% colnames(snps))
		{
		snps[,tempname]	<<- NULL
		}
	if(tempname2 %in% colnames(snps))
		{
		snps[,tempname2]	<<- NULL
		}
	if(tempname3 %in% colnames(snps))
		{
		snps[,tempname3]	<<- NULL
		}
	outtemp2		<- P1[,c("LocusName","OutlierFlag","negativelogp","negativelogq")]
	if(domerge)
		{
		# Merging keeps on returning errors (more rows than expected), so by default I choose for the more time consuming alternative option.
		colnames(outtemp2)<- c("name",tempname,tempname2,tempname3)
		outtemp3 		<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
		#outtemp4		<- outtemp3[order(as.numeric(outtemp3$chr),as.numeric(outtemp3$pos)),]
		outtemp4		<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
		#outtemp4		<- outtemp3[order(outtemp3$chr,outtemp3$pos),]
		if(any(!colnames(as.matrix(mygenlight))==outtemp4$genlightname))
			{	
			outtemp2	<<- outtemp2
			outtemp3	<<- outtemp3
			outtemp4	<<- outtemp4
			return(cat("ERROR: after reordering column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		snps			<<- outtemp4
		}else{
		cat("Adding results to the snps dataframe using a slow method. This will take a while...")
		snps$OutFLANK		<<- NA
		snps$OutFLANKlogp	<<- NA
		snps$OutFLANKlogq	<<- NA
		for(i in c(1:nrow(outtemp2)))
			{
			if(i%%5000==0){cat(i,sep="\n")}
			mylocus			<- outtemp2$LocusName[i]
			if(mylocus%in%snps$name)
				{
				snps$OutFLANK[snps$name==mylocus]		<<- outtemp2$OutlierFlag[i]
				snps$OutFLANKlogp[snps$name==mylocus]	<<- outtemp2$negativelogp[i]
				snps$OutFLANKlogq[snps$name==mylocus]	<<- outtemp2$negativelogq[i]
				}
			}
		colnames(snps)[which(colnames(snps)=="OutFLANK")]		<<- paste("OutFLANK",my_dataset,sep="_")
		colnames(snps)[which(colnames(snps)=="OutFLANKlogq")]	<<- paste("OutFLANKlogp",my_dataset,sep="_")
		colnames(snps)[which(colnames(snps)=="OutFLANKlogp")]	<<- paste("OutFLANKlogq",my_dataset,sep="_")
		}
	cat(paste("Outliers, if present, are marked as TRUE in the",tempname,"column in the snps dataframe.",sep=" "),sep="\n")
	cat("Negative log of the pvalues and qvalues are saved as well.",sep="\n")
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

multi_plot_scanlog<-function(popnames=mysambar$populations,allpairwise=FALSE,do_export=NULL,outflank_q=TRUE)
	{
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		plot_scanlog(doexport=do_export,outflankq=outflank_q,mydataset="pheno")
		}
	#allcombitemp	<<- allcombi
	ncombi		<- ncol(allcombi)	
	for(my_i in c(1:ncombi))
		{
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		my_data_set	<- paste(my_pops[1],my_pops[2],sep="_")
		if(paste("rfisherlogp",my_data_set,sep="_")%in%colnames(snps))
			{
			#cat(my_data_set,sep="\n")
			plot_scanlog(doexport=do_export,outflankq=outflank_q,mydataset=my_data_set)
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}
		}
	}

plot_scanlog<-function(doexport=NULL,outflankq=TRUE,mydataset=NULL,markoutpheno=TRUE)
	{
	if(is.null(mydataset))
		{
		return(cat("ERROR: Specify an input dataset!",sep="\n"))
		}
	# This function plots negative logs of pvalues of GWDS and PCadapt, and qvalues of OutFLANK and optionally Bayescan
	snpcolnames		<- names(snps)
	alloci			<- c(1:nrow(snps))
	# GWDS:
	mycolumn		<- paste("rfisherout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		myGWDSlog		<- snps[,paste("rfisherlogp",mydataset,sep="_")]
		myGWDSout		<- snps[,paste("rfisherout",mydataset,sep="_")]
		}else{
		myGWDSlog		<- rep(NA,nrow(snps))
		myGWDSout		<- rep(NA,nrow(snps))
		}
	# PCadapt:
	mycolumn		<- paste("PCadaptout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		myPCadaptlog	<- snps[,paste("PCadaptlogp",mydataset,sep="_")]
		myPCadaptout	<- snps[,paste("PCadaptout",mydataset,sep="_")]
		}else{
		myPCadaptlog	<- rep(NA,nrow(snps))
		myPCadaptout	<- rep(NA,nrow(snps))
		}
	# OutFLANK:
	mycolumn		<- paste("OutFLANK",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)	
		{
		if(outflankq)
			{
			myOutFLANKlog	<- snps[,paste("OutFLANKlogq",mydataset,sep="_")]
			}else{
			myOutFLANKlog	<- snps[,paste("OutFLANKlogp",mydataset,sep="_")]
			}
		myOutFLANKout	<- snps[,paste("OutFLANK",mydataset,sep="_")]
		}else{
		myOutFLANKlog	<- rep(NA,nrow(snps))
		myOutFLANKout	<- rep(NA,nrow(snps))
		}
	# Bayescan:
	mycolumn		<- paste("bayescanout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)	
		{
		myBayescanlog	<- snps[,paste("bayescanlogq",mydataset,sep="_")]
		myBayescanout	<- snps[,paste("bayescanout",mydataset,sep="_")]
		}else{
		myBayescanlog	<- rep(NA,nrow(snps))
		myBayescanout	<- rep(NA,nrow(snps))
		}
	# fsthet:
	mycolumn		<- paste("fsthetout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)	
		{
		myfsthetlog		<- snps[,paste("fsthetlogp",mydataset,sep="_")]
		myfsthetout		<- snps[,paste("fsthetout",mydataset,sep="_")]
		}else{
		myfsthetlog		<- rep(NA,nrow(snps))
		myfsthetout		<- rep(NA,nrow(snps))
		}
	mylogvaluesdf		<- as.data.frame(cbind(myBayescanlog,myfsthetlog,myGWDSlog,myOutFLANKlog,myPCadaptlog))
	colnames(mylogvaluesdf)	<- c("Bayescan","Fsthet","GWDS","OutFLANK","PCadapt")
	myoutdf				<- as.data.frame(cbind(myBayescanout,myfsthetout,myGWDSout,myOutFLANKout,myPCadaptout))
	colnames(myoutdf)	<- c("Bayescan","Fsthet","GWDS","OutFLANK","PCadapt")
	myoutdf				<<- myoutdf
	mylogvaluesdf		<<- mylogvaluesdf
	#
	mytests				<- as.vector(which(colSums(is.na(myoutdf))<nrow(myoutdf)))
	mytestnames			<- colnames(myoutdf)[mytests]
	myoutdf				<- myoutdf[,colSums(is.na(myoutdf))<nrow(myoutdf)]
	myoutdf				<- as.data.frame(myoutdf)
	colnames(myoutdf)	<- mytestnames
	mylogvaluesdf			<- mylogvaluesdf[,colSums(is.na(mylogvaluesdf))<nrow(mylogvaluesdf)]
	mylogvaluesdf			<- as.data.frame(mylogvaluesdf)
	colnames(mylogvaluesdf)	<- mytestnames
	#	
	graphics.off()	
	ntiles				<- ncol(myoutdf)
	if(!is.null(doexport))
		{
		outputfile		<- paste("Selectionscan.logpvalues",mydataset,sep=".")
		if(doexport=="pdf"){pdf(paste(outputfile,"pdf",sep="."),height=ntiles*2+3,width=14)}
		if(doexport=="png"){png(paste(outputfile,"png",sep="."),height=500,width=700)}
		}
	par(mfrow=c(ntiles,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
	for(j in c(1:ntiles))
		{
		mylogvalues	<- mylogvaluesdf[,j]
		myoutliers	<- myoutdf[,j]
		myymax		<- max(mylogvalues[is.finite(mylogvalues)],na.rm=TRUE)
		myymax		<- ifelse(myymax<1,1,myymax)
		myylim		<- c(0,myymax)
		myxaxt		<- ifelse(j==ntiles,'s','n')
		plot(alloci,mylogvalues,xaxt=myxaxt,ylab="",pch=16,ylim=myylim,las=1)
		if(markoutpheno)
			{
			rfisheroutliers	<- snps[,paste("rfisherout",mydataset,sep="_")]
			gwdsoutnr		<- which(rfisheroutliers)
			abline(v=gwdsoutnr,col="grey")
			}
		if(length(myoutliers[myoutliers])>0)
			{
			points(alloci[myoutliers],mylogvalues[myoutliers],col="red",pch=16)
			}
		mylabel		<- mytestnames[j]
		mtext(mylabel,side=4,line=1.5,cex=1.75)
		mtext("-log(test statistic)",side=2,line=0.5,cex=2.5,outer=TRUE)
		mtext("SNP index",side=1,line=4,cex=2.5,outer=TRUE)
		}
	if(!is.null(doexport))
		{
		dev.off()
		cat(paste("A file called",outputfile,"has been exported.",sep=" "),sep="\n")
		}
	}

writebed<-function(my_dataset="pheno")
	{
	if(paste("bayescanout",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("bayescanout",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("Bayescanoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	if(paste("PCadaptout",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("PCadaptout",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("PCadaptoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	if(paste("OutFlank",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("OutFlank",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("OutFlankoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	if(paste("rfisherout",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("rfisherout",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("GWDSoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	cat("BED-files with outliers have been written to the selection subdirectory",sep="\n")
	}

# this function can not be in exportsambarfiles(), because at that stage pheno has not been defined yet. 	
createbayescaninput<-function(allpairwise=FALSE)
	{
	if(is.null(inds$type)&!allpairwise)
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		}
	ncombi			<- ncol(allcombi)
	for(my_i in c(1:ncombi))
		{
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		mypop_1		<- my_pops[1]
		mypop_2		<- my_pops[2]
		indselect	<- inds$filter&(inds$pop==mypop_1|inds$pop==mypop_2)
		combiname	<- paste(combinames[my_i],"filter2.letter",sep=".")
		exportdata(indsfilter=indselect,snpsfilter=snps$filter2,export_name=combiname,geno_nr=FALSE,do_all=FALSE)
		}
	if(!allpairwise)
		{
		cat("pheno1_pheno2 (pooled data)",sep="\n")
		exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="pheno.filter2.letter",geno_nr=FALSE,do_all=FALSE,do_pheno=TRUE)
		}
	}	

getbayescan<-function(FDR=0.01,export=NULL,my_dataset="Busen_Norway",use_merge=TRUE,inputmapfile=NULL)
	{
	cat(paste("False discovery rate is set to:",FDR,sep=" "),sep="\n")
	setwd(mysambar$inputfilesdir)
	if(is.null(inputmapfile))
		{
		mapfile	<- paste(my_dataset,"filter2.letter.map",sep=".")
		}else{
		mapfile	<- inputmapfile
		}
	if(!file.exists(mapfile))
		{
		return(cat(paste("ERROR: the inputfiles directory does not contain a file called ",mapfile,".",sep=""),sep="\n"))
		}else{
		y		<- read.table(mapfile)	# mapfile used when converting ped/map to geste/bayescan.
		}
	myloci		<- y$V2
	# import bayescan results: 
	bayescanfile		<- paste(my_dataset,"bayescanout.fst.txt",sep=".")
	if(!file.exists(bayescanfile))
		{
		return(cat(paste("ERROR: the inputfiles directory does not contain a file called ",bayescanfile,".",sep=""),sep="\n"))
		}else{
		x		<- read.table(bayescanfile) 
		bayescan_data	<<- x
		}
	if(nrow(x)!=nrow(y))
		{
		cat(paste("ERROR: Number of rows in '",mapfile,"' file does not correspond with number of rows in '",bayescanfile,"'.",sep=""),sep="\n") 
		cat("From which PED and MAP file did you convert your data to the Bayescan input file?",sep="\n") 
		return(cat("Store the MAP file in the inputfiles directory, and rerun the getbayescan function by full name of the MAP file to the 'inputmapfile'.",sep="\n"))
		}
	x$name			<- myloci
	x$bayescanout	<- x$qval<FDR
	noutliers		<- length(which(x$bayescanout))
	x$bayescanlogq	<- -log(x$qval)
	# add to snps dataframe:
	if(!use_merge)
		{
		# Not using merge (i.e. this for loop) returns NA values for non-outliers for bayescanlogq, so not an option really.
		outtemp2			<- x[x$bayescanout,c("name","bayescanout","bayescanlogq")]
		snps$bayescanout	<<- FALSE
		snps$bayescanlogq	<<- NA
		for(j in 1:nrow(outtemp2))
			{
			mylocus	<- as.vector(outtemp2$name[j])
			mylogq	<- as.vector(outtemp2$bayescanlogq[j])
			#cat(mylocus,sep="\n")
			snps$bayescanout[snps$name==mylocus]	<<- TRUE
			snps$bayescanlogq[snps$name==mylocus]	<<- mylogq
			}
		}else{
		# Rather than for loop, we could also use merge function, which is faster:
		if(!is.null(snps$bayescanout))
			{
			snps$bayescanout	<<- NULL
			}
		if(!is.null(snps$bayescanlogq))
			{
			snps$bayescanlogq	<<- NULL
			}
		outtemp2	<- x[,c("name","alpha","bayescanout","bayescanlogq")]
		names(outtemp2)[which(names(outtemp2)=="alpha")]<- "bayescanalpha"
		outtemp3 	<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
		outtemp4	<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
		outtemp4$bayescanout[is.na(outtemp4$bayescanout)]	<- FALSE
		if(any(!colnames(as.matrix(mygenlight))==outtemp4$genlightname))
			{	
			outtemp3	<<- outtemp3
			outtemp4	<<- outtemp4
			return(cat("ERROR: after reordering column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		snps		<<- outtemp4
		}
	# export pdf:
	setwd(mysambar$selectiondir)
	if(!is.null(export))
		{
		plotname	<- paste("Bayescanplot",my_dataset,sep="_")
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."))}
		}
	par(cex.lab=2,cex.axis=2)
	plot(-log10(x$qval),x$fst,xlab="-log10(qvalue)",ylab="",pch=16)
	points(-log10(x$qval)[x$qval<FDR],x$fst[x$qval<FDR],col="red",pch=16)
	abline(v=-log10(FDR),lty=2)	
	mtext(side=2,"Fst",cex=2,line=2.5)
	mtext(side=3,my_dataset,cex=2,line=0.5)
	if(!is.null(export)){dev.off()}
	#
	if(!is.null(export))
		{
		plotname	<- paste("Bayescanplot2",my_dataset,sep="_")
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."))}
		}
	par(cex.lab=2,cex.axis=2)
	plot(x$alpha,-log10(x$qval),xlab="alpha",ylab="",pch=16)
	points(x$alpha[x$qval<FDR],-log10(x$qval)[x$qval<FDR],col="red",pch=16)
	abline(h=-log10(FDR),lty=2)	
	mtext(side=2,"-log10(qvalue)",cex=2,line=2.5)
	mtext(side=3,my_dataset,cex=2,line=0.5)
	if(!is.null(export)){dev.off()}
	#	
	# rename:
	tempname	<- paste("bayescanout",my_dataset,sep="_")
	tempname2	<- paste("bayescanlogq",my_dataset,sep="_")
	tempname3	<- paste("bayescanalpha",my_dataset,sep="_")
	names(snps)[names(snps) == "bayescanout"] <<- tempname
	names(snps)[names(snps) == "bayescanlogq"] <<- tempname2
	names(snps)[names(snps) == "bayescanalpha"] <<- tempname3
	snps 		<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	cat(paste("A FDR of ",FDR," results in ",noutliers," outliers.",sep=""),sep="\n")
	cat("Columns 'bayescanout_dataset','bayescanlogq_dataset' and 'bayescanalpha_dataset' have been added to the snps dataframe.",sep="\n")
	if(!is.null(export))
		{
		cat("Plots have been exported to the selection directory.",sep="\n")
		}
	}

# 15-11-2019: currently applicable to reindeer dataset only		
exp_nout<-function(export="pdf")
	{
	setwd(mysambar$selectiondir)
	nloci	<- nrow(snps[snps$filter2,])
	spec	<- seq(1,0.999,-0.0001)			# specificity
	nout	<- (1-spec)*nloci				# number of outliers
	#
	testspec		<- c(0.9998,0.99995,1,0.9996)	# Bayescan, GWDS, OutFLANK, PCadapt
	Barff_Norway	<- c(0,7,0,35)
	Busen_Norway	<- c(12,0,0,16)
	pheno			<- c(13,3,0,25)
	#
	if(!is.null(export))
		{
		if(export=="pdf"){pdf("Expected_falsepositives.pdf",height=8,width=8)}
		}
	par(mar=c(5,5.5,3,1.5))
	plot(spec*100,nout,type='l',lwd=1.5,xlab="",ylab="",cex.axis=2,las=1)
	points(testspec*100,Barff_Norway,col=c("red","blue","yellow","darkgreen"),pch=16,cex=2)
	points(testspec*100,Busen_Norway,col=c("red","blue","yellow","darkgreen"),pch=16,cex=2)
	points(testspec*100,pheno,col=c("red","blue","yellow","darkgreen"),pch=16,cex=2)
	mtext(side=1,"Specificity (%)",cex=2.5,line=3)
	mtext(side=2,"Number of outlier SNPs",cex=2.5,line=3.5)
	mtext(side=3,paste(nloci,"SNPs",sep=" "),line=0.5,cex=2.5)
	legend("topright",legend=c("Bayescan","GWDS","OutFLANK","PCadapt"),fill=c("red","blue","yellow","darkgreen"),bty='n',cex=2)
	if(!is.null(export)){dev.off()}
	}

# 15-11-2019: currently applicable to reindeer dataset only	
multioverlap<-function(doexport=NULL,add_numbers=FALSE)
	{
	if(!is.null(doexport))
		{
		if(doexport=="pdf"){pdf("Overlap.approaches.pdf",width=12,height=4)}
		}
	par(mfrow=c(1,3),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	plotpoverlap(mycomparison=1,mylog="",addnumbers=add_numbers)
	plotpoverlap(mycomparison=2,mylog="",addnumbers=add_numbers)
	plotpoverlap(mycomparison=3,mylog="",addnumbers=add_numbers)
	if(!is.null(doexport)){dev.off()}
	}		

# 15-11-2019: currently applicable to reindeer dataset only	
plotpoverlap<-function(mycomparison=1,mylog="",mycex=1,addnumbers=FALSE)
	{
	if(mycomparison==1)
		{
		mylog1	<- snps$rfisherlogp_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "Founder vs Source"
		mylog2	<- snps$rfisherlogp_Busen_Norway
		myout2	<- snps$rfisherout_Busen_Norway
		mytest2	<- "Busen vs Norway"
		mymin1	<- 46
		mymin2	<- 53
		mylim	<-c(0,105)
		}
	if(mycomparison==2)
		{
		mylog1	<- snps$rfisherlogp_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "Founder vs Source"
		mylog2	<- snps$rfisherlogp_Barff_Norway
		myout2	<- snps$rfisherout_Barff_Norway
		mytest2	<- "Barff vs Norway"
		mymin1	<- 46
		mymin2	<- 45
		mylim	<-c(0,105)
		}
	if(mycomparison==3)
		{
		mylog1	<- snps$rfisherlogp_Busen_Norway
		myout1	<- snps$rfisherout_Busen_Norway
		mytest1	<- "Busen vs Norway"
		mylog2	<- snps$rfisherlogp_Barff_Norway
		myout2	<- snps$rfisherout_Barff_Norway
		mytest2	<- "Barff vs Norway"
		mymin1	<- 45
		mymin2	<- 53
		mylim	<-c(0,80)
		}
	#mylim<-c(min(c(mylog1,mylog2)),max(c(mylog1,mylog2)))
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,log=mylog,yaxt='n',xlim=mylim,ylim=mylim)
	points(mylog1[snps$rfisherout_pheno],mylog2[snps$rfisherout_pheno],cex=mycex,col="red",pch=16)
	mtext(mytest1,side=1,cex=1.5,line=3)
	if(mylog=="y")
		{
		axis(side=2,at=format(axTicks(2),scientific=FALSE),format(axTicks(2),scientific=FALSE),las=1)
		mtext(mytest2,side=2,cex=1.5,line=4.5)
		}else{
		axis(side=2,las=1)
		mtext(mytest2,side=2,cex=1.5,line=3)
		}
	#mymin1	<- min(mylog1[myout1])
	#mymin2	<- min(mylog2[myout2])
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- 0
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- nrow(snps)-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
			if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}

multiplotp<-function(doexport=NULL,add_numbers=FALSE,my_dataset="pheno",silent=TRUE)
	{
	logp 		<- snps[,grep(paste("logp",my_dataset,sep="_"),colnames(snps))]
	if(is.null(dim(logp)))
		{
		return(cat("Executed one selection scan (not multiple selection scans). Skipping 2D plots.",sep="\n"))
		}
	logp		<- logp[,order(colnames(logp))]
	mytests		<- colnames(logp)
	mytests		<- gsub(paste("logp",my_dataset,sep="_"),"",mytests)	
	combitable	<- combn(mytests,m=2)
	ncombi		<- ncol(combitable)
	if(!is.null(doexport))
		{
		plotname<-paste("Selectionscan.logpvalues.2D",my_dataset,"pdf",sep=".")
		if(doexport=="pdf"){pdf(plotname,width=ncombi*4+1,height=4)}
		}
	par(mfrow=c(1,ncombi),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	for(j in c(1:ncombi))
		{
		test_1	<- combitable[1,j]
		test_2	<- combitable[2,j]
		if(!silent){cat(paste(test_1," vs ",test_2,sep=""),sep="\n")}
		plotpvalues(test1=test_1,test2=test_2,mydataset=my_dataset,mylog="",mycex=1,addnumbers=FALSE)
		}
	if(!is.null(doexport)){dev.off()}
	}	
	
plotpvalues<-function(test1="rfisher",test2="PCadapt",mydataset="pheno",mylog="",mycex=1,addnumbers=FALSE)
	{
	mylog1	<- snps[,paste(paste(test1,"logp",sep=""),mydataset,sep="_")]
	mylog1[mylog1<0.01]	<- 0.01
	if(mylog=="x"|mylog=="xy")
		{
		mylog1[mylog1<0.01]	<- 0.01
		}
	if(test1=="OutFLANK")
		{
		myout1	<- snps[,paste(test1,mydataset,sep="_")]
		}else{
		myout1	<- snps[,paste(paste(test1,"out",sep=""),mydataset,sep="_")]
		}
	mytest1	<- ifelse(test1=="rfisher","GWDS",test1)
	#
	mylog2	<- snps[,paste(paste(test2,"logp",sep=""),mydataset,sep="_")]
	if(mylog=="y"|mylog=="xy")
		{
		mylog2[mylog2<0.01]	<- 0.01
		}
	if(test2=="OutFLANK")
		{
		myout2	<- snps[,paste(test2,mydataset,sep="_")]
		}else{
		myout2	<- snps[,paste(paste(test2,"out",sep=""),mydataset,sep="_")]
		}
	mytest2	<- ifelse(test2=="rfisher","GWDS",test2)
	#
	mymin1	<- ifelse(any(myout1),min(mylog1[myout1]),NA)
	mymin2	<- ifelse(any(myout2),min(mylog2[myout2]),NA)
	xmin	<- ifelse(mylog=="x"|mylog=="xy",0.01,0)
	xmax	<- max(mylog1[is.finite(mylog1)&!is.na(mylog1)])
	xmax	<- ifelse(xmax<1,1,xmax)
	ymin	<- ifelse(mylog=="x"|mylog=="xy",0.01,0)
	ymax	<- max(mylog2[is.finite(mylog2)&!is.na(mylog2)])
	ymax	<- ifelse(ymax<1,1,ymax)
	mytemp<<-c(xmin,xmax,ymin,ymax)
	#
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,log=mylog,yaxt='n',xlim=c(xmin,xmax),ylim=c(ymin,ymax))
	points(mylog1[myout1],mylog2[myout1],cex=mycex,col="red",pch=16)
	points(mylog1[myout2],mylog2[myout2],cex=mycex,col="red",pch=16)
	mtext(mytest1,side=1,cex=1.5,line=3.5)
	if(mylog=="y")
		{
		axis(side=2,at=format(axTicks(2),scientific=FALSE),format(axTicks(2),scientific=FALSE),las=1)
		mtext(mytest2,side=2,cex=1.5,line=4.5)
		}else{
		axis(side=2,las=1)
		mtext(mytest2,side=2,cex=1.5,line=3.5)
		}
	# add thresholds:
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- 1000-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
		if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}	

# depreciated on 14-11-2019:	
multiplotp_old<-function(doexport=NULL,add_numbers=TRUE)
	{
	if(!is.null(doexport))
		{
		if(doexport=="pdf"){pdf("Testlogvalues.2D.pdf",width=12,height=4)}
		}
	par(mfrow=c(1,3),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	plotpvalues(mycomparison=1,mylog="",addnumbers=add_numbers)
	plotpvalues(mycomparison=2,mylog="y",addnumbers=add_numbers)
	plotpvalues(mycomparison=3,mylog="y",addnumbers=add_numbers)
	if(!is.null(doexport)){dev.off()}
	}
	
# depreciated on 14-11-2019:	
plotpvalues_old<-function(mycomparison=1,mylog="",mycex=1,addnumbers=FALSE)
	{
	if(mycomparison==1)
		{
		mylog1	<- snps$rfisherlogp_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "GWDS"
		myxlim	<- c(0,100)
		mylog2	<- snps$bayescanlogq_pheno
		myout2	<- snps$bayescanout_pheno
		mytest2	<- "Bayescan"
		myylim	<- c(0,10) 
		}
	if(mycomparison==2)
		{
		mylog1	<- snps$rfisherlogp_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "GWDS"
		myxlim	<- c(0,100)
		mylog2	<- snps$PCadaptlogp_pheno
		myout2	<- snps$PCadaptout_pheno
		mytest2	<- "PCadapt"
		myylim	<- c(0.01,100)
		}
	if(mycomparison==3)
		{
		mylog1	<- snps$bayescanlogq_pheno
		myout1	<- snps$bayescanout_pheno
		mytest1	<- "Bayescan"
		myxlim	<- c(0,10)
		mylog2	<- snps$PCadaptlogp_pheno
		myout2	<- snps$PCadaptout_pheno
		mytest2	<- "PCadapt"
		myylim	<- c(0.01,100)
		}
	mylog1[mylog1<0.01]	<- 0.01
	mylog2[mylog2<0.01]	<- 0.01
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,log=mylog,yaxt='n',ylim=myylim,xlim=myxlim)
	points(mylog1[snps$rfisherout_pheno],mylog2[snps$rfisherout_pheno],cex=mycex,col="red",pch=16)
	mtext(mytest1,side=1,cex=1.5,line=3)
	if(mylog=="y")
		{
		axis(side=2,at=format(axTicks(2),scientific=FALSE),format(axTicks(2),scientific=FALSE),las=1)
		mtext(mytest2,side=2,cex=1.5,line=4.5)
		}else{
		axis(side=2,las=1)
		mtext(mytest2,side=2,cex=1.5,line=3)
		}
	if(mycomparison==1|mycomparison==2)
		{
		mymin1	<- 46
		}else{
		mymin1	<- min(mylog1[myout1])
		}
	mymin2	<- min(mylog2[myout2])
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- 1000-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
		if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}

plot_venn<-function(my_dataset="Busen_Norway",export=TRUE,mysmall=1)
	{
	#cat(my_dataset,sep="\n")
	snpcolnames		<- names(snps)
	# GWDS:
	mycolumn		<- paste("rfisherout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		gwdsout		<- snps$name[outfilter]
		}else{
		gwdsout		<- snps$name[FALSE]
		}
	# PCadapt:
	mycolumn		<- paste("PCadaptout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		pcadaptout	<- snps$name[outfilter]	
		}else{
		pcadaptout	<- snps$name[FALSE]
		}
	# OutFLANK:
	mycolumn		<- paste("OutFLANK",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		outflankout	<- snps$name[outfilter]
		}else{
		outflankout	<- snps$name[FALSE]
		}
	# bayescan:
	mycolumn		<- paste("bayescanout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		bayescanout	<- snps$name[outfilter]
		}else{
		bayescanout	<- snps$name[FALSE]
		}
	# Fsthet:
	mycolumn		<- paste("fsthetout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		fsthetout	<- snps$name[outfilter]
		}else{
		fsthetout	<- snps$name[FALSE]
		}
	# plot:
	if(length(bayescanout)>1|length(gwdsout)>1|length(pcadaptout)>1|length(outflankout)>1|length(fsthetout)>1)
		{
		if(export){pdf(paste("venn",my_dataset,"pdf",sep="."),height=6,width=8)}
		baye		<- paste("bayescanout",my_dataset,sep="_")
		fsthet		<- paste("fsthetout",my_dataset,sep="_")
		outfla		<- paste("OutFLANK",my_dataset,sep="_")
		if(outfla%in%snpcolnames)
		{
		if((baye%in%snpcolnames)&(fsthet%in%snpcolnames))
			{
			if(my_dataset!="metapop")
				{
				v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen","orange","darkorchid4"),col=c("darkred","blue","darkgreen","orange","darkorchid4"),margin=0.1)
				}else{
				v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout,OutFLANK=outflankout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen","orange","darkorchid4"),col=c("darkred","darkgreen","orange","darkorchid4"),margin=0.1)
				}
			grid.newpage()
			grid.draw(v1)
			}
		if((baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
			{
			#venn(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
			if(my_dataset!="metapop")
				{
				v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen","orange"),col=c("darkred","blue","darkgreen","orange"),margin=0.1)
				}else{
				v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen","orange"),col=c("darkred","darkgreen","orange"),margin=0.1)
				}
			grid.newpage()
			grid.draw(v1)
			}
		if((!baye%in%snpcolnames)&(fsthet%in%snpcolnames))
			{
			if(my_dataset!="metapop")
				{
				v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen","orange","darkorchid4"),col=c("blue","darkgreen","orange","darkorchid4"),margin=0.1)
				}else{
				v1 <- venn.diagram(list(PCadapt=pcadaptout,OutFLANK=outflankout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen","orange","darkorchid4"),col=c("darkgreen","orange","darkorchid4"),margin=0.1)
				}
			grid.newpage()
			grid.draw(v1)
			}
		if((!baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
			{
			#venn(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
			if(my_dataset!="metapop")
				{
				v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen","orange"),col=c("blue","darkgreen","orange"),margin=0.1)
				}else{
				v1 <- venn.diagram(list(PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen","orange"),col=c("darkgreen","orange"),margin=0.1)
				}
			grid.newpage()
			grid.draw(v1)
			}
		}else{	# IF NOT OUTFLANK
				if((baye%in%snpcolnames)&(fsthet%in%snpcolnames))
			{
			if(my_dataset!="metapop")
				{
				v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen","darkorchid4"),col=c("darkred","blue","darkgreen","darkorchid4"),margin=0.1)
				}else{
				v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen","darkorchid4"),col=c("darkred","darkgreen","darkorchid4"),margin=0.1)
				}
			grid.newpage()
			grid.draw(v1)
			}
		if((baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
			{
			#venn(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
			if(my_dataset!="metapop")
				{
				v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen"),col=c("darkred","blue","darkgreen"),margin=0.1)
				}else{
				v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen"),col=c("darkred","darkgreen"),margin=0.1)
				}
			grid.newpage()
			grid.draw(v1)
			}
		if((!baye%in%snpcolnames)&(fsthet%in%snpcolnames))
			{
			if(my_dataset!="metapop")
				{
				v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen","darkorchid4"),col=c("blue","darkgreen","darkorchid4"),margin=0.1)
				}else{
				v1 <- venn.diagram(list(PCadapt=pcadaptout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen","darkorchid4"),col=c("darkgreen","darkorchid4"),margin=0.1)
				}
			grid.newpage()
			grid.draw(v1)
			}
		if((!baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
			{
			#venn(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
			if(my_dataset!="metapop")
				{
				v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen"),col=c("blue","darkgreen"),margin=0.1)
				}else{
				v1 <- venn.diagram(list(PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen"),col=c("darkgreen"),margin=0.1)
				}
			grid.newpage()
			grid.draw(v1)
			}
		}
		if(export){dev.off()}
		vennlogfiles <- list.files(pattern = "\\.log$")
		unlink(vennlogfiles)
		}else{
		return(cat("ERROR: expected input missing when generating Venn diagram. Contact developer of SambaR.",sep="\n"))
		}
	}

# Create input for bayenv:
makebayenvinput<-function(popnames=mysambar$populations,type=FALSE)
	{
	# execute analysis:
	if(type)
		{
		if(length(popnames)!=length(unique(inds$type3)))
			{
			cat("Length of popnames does not correspond to expected number of population names")
			}
		}
	bayenvinput			<<- matrix(ncol=(length(popnames)),nrow=2*nrow(snps[snps$filter&snps$minorcount>0,]))
	for (i in (1:length(popnames)))
		{
		if(type)
			{
			tempgenlight<- mygenlight[inds$filter&inds$type3==popnames[i],snps$filter&snps$minorcount>0]
			}else{
			tempgenlight<- mygenlight[inds$filter&inds$pop2==popnames[i],snps$filter&snps$minorcount>0]
			}
		misscount		<- glNA(tempgenlight,alleleAsUnit=FALSE)
		nonmissallelecount 	<- 2*(nInd(tempgenlight)-misscount)
		minorcount		<- as.vector(glSum(tempgenlight))
		majorcount		<- nonmissallelecount-minorcount	
		z 			<- c(rbind(minorcount,majorcount))
		bayenvinput[,i]		<<- z 
		colnames(bayenvinput)	<<- popnames
		}
	# Export:
	write.table(bayenvinput,"Bayenvinput.metapop.txt",col.names=FALSE,row.names=FALSE,sep="\t")
	}	
	
# Sliding window Fst:
# Depends on package 'zoo'
windowfst<-function(chrom=1,width=50,step=2,popnames=mysambar$populations,selectcombi=NULL,snpselection=snps$filter2,mycolours=as.vector(unique(inds$popcol)),yrange=c(0,0.4),yby=0.1,xrange=c(0,160000000),xby=25,addlegend=FALSE,xaxislabels=TRUE,region=NULL,mylwd=1.5,addchrom=TRUE,legendcex=1)
	{
	# region is a two element vector to highlight area in between
	xrange				<- xrange/1000000
	selection			<- snps$chr==chrom&snpselection
	combitable			<<- combn(popnames,m=2)
	combicoltable		<<- combn(mycolours,m=2)
	if(!is.null(selectcombi))
		{	
		combitable		<<- as.matrix(combitable[,selectcombi])
		combicoltable	<<- as.matrix(combicoltable[,selectcombi])
		}
	combicolours		<<- rep(NA,ncol(combitable))
	combivector			<<- paste(combitable[1,],combitable[2,],sep="_")
	winmidpoint			<- rollapply(snps$pos[selection],width,mean,by=step,na.rm=TRUE)
	windowoutput		<<- as.data.frame(matrix(NA,nrow=length(winmidpoint),ncol=ncol(combitable)+1))
	colnames(windowoutput)	<<- c(combivector,"pos")
	windowoutput$pos	<<- winmidpoint
	for (i in (1:(ncol(combitable))))
		{
		combiname		<- paste(combitable[1,i],combitable[2,i],sep="_")	
		fstvalues		<- snps[selection,names(snps) == paste("WeirFst",combiname,sep = "_")]	
		# Sliding window:		
		fstmean 		<- rollapply(fstvalues,width,mean,by=step,na.rm=TRUE)
		#fstsd 			<- rollapply(fstvalues,width,sd,by=step,na.rm=TRUE)
		windowoutput[names(windowoutput) == combivector[i]] <<- fstmean
		}
	# Plot:
	# plot first line:
	# as colour we are going to use a blend of the two population colours:
	mycol1			<- combicoltable[1,1]
	mycol2			<- combicoltable[2,1]
	mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
	mycol			<- mycolfunc3(3)[2]
	combicolours[1]	<<- mycol
	if(xaxislabels)
		{
		plot(windowoutput$pos/1000000,windowoutput[,1],type="l",ylim=yrange,yaxt='n',xaxt='n',ann=FALSE,xlim=xrange,col=mycol,lwd=mylwd)
		axis(2, at=seq((yrange[1]+yby/2),yrange[2],by=yby),las=1)
		axis(1, at=seq((xrange[1]),xrange[2],by=xby),las=1)
		}else{
		plot(windowoutput$pos/1000000,windowoutput[,1],type="l",ylim=yrange,yaxt='n',xaxt='n',ann=FALSE,xlim=xrange,col=mycol,lwd=mylwd)
		axis(2, at=seq((yrange[1]+yby/2),yrange[2],by=yby),las=1)
		}
	if(!is.null(region))
		{
		rect(xleft=region[1],ybottom=-1,xright=region[2],ytop=1,col="grey",border=NA)
		lines(windowoutput$pos/1000000,windowoutput[,1],col=mycol,lwd=mylwd)
		}
	if(addchrom)
		{
		mtext(chrom,3,line=-1,cex=0.75)
		}
	# plot optional extra lines:
	if(ncol(combitable)>1)
		{
		for (z in (2:(ncol(combitable))))
			{
			# as colour we are going to use a blend of the two population colours:
			mycol1		<- combicoltable[1,z]
			mycol2		<- combicoltable[2,z]
			mycolfunc3 	<- colorRampPalette(c(mycol1,mycol2))
			mycol		<- mycolfunc3(3)[2]
			combicolours[z]	<<- mycol
			lines(windowoutput$pos/1000000,windowoutput[,z],type="l",col=mycol,lwd=mylwd)
			title((paste("chromosome",chrom, sep = " ")),line = 1)
			}
		}
	if(addlegend){legend("topleft",y=0.2,combivector,fill=combicolours,cex=legendcex,bty="n")}
	}

# depends on function windowfst()	
plotwindowfst<-function(mycomparisons=NULL,popnames=mysambar$populations,ntiles=18,mychroms=NULL,windowsize=50,export=NULL,addX=TRUE,myyrange=c(0.025,0.225),my_lwd=1.5)
	{
	setwd(mysambar$selectiondir)
	# run windowfst function recursively:
	if(is.null(mycomparisons))
		{
		mycomparisons=seq(1:ncol(combn(popnames,m=2)))
		}
	if(is.null(mychroms))
		{
		mychroms<-sort(as.numeric(as.vector(unique(snps$chr[as.vector(snps$autosomal)]))))
		}
	nchroms		<- length(mychroms)
	ntabs		<- ceiling(nchroms/ntiles)
	for (n in c(1:ntabs))
		{ 
		if(!is.null(export))
			{
			if(export=="eps"){postscript(paste("Window_Fst",(paste(windowsize,"snpsperwindow",sep="")),n,"eps",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="pdf"){pdf(paste("Window_Fst",(paste(windowsize,"snpsperwindow",sep="")),n,"pdf",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="png"){png(paste("Window_Fst",(paste(windowsize,"snpsperwindow",sep="")),n,"png",sep="."),family=mysambar$myfont,width=540,height=720)}
			if(export=="wmf"){win.metafile(paste("Window_Fst",(paste(windowsize,"snpsperwindow",sep="")),n,"wmf",sep="."),family=mysambar$myfont,width=6,height=8)}
			}
		layout(matrix(c(c(c(1:(ntiles/2)),ntiles+1),c((ntiles/2+1):(ntiles+1))),nrow=(ntiles/2+1),ncol=2,byrow=FALSE))
		#layout(matrix(c(1:ntiles),(ntiles/2),2,byrow=FALSE))
		par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,2,2))
		if(n<ntabs)
			{
			chromset	<- mychroms[((n-1)*ntiles+1):(ntiles*n)]
			}else{
			chromset	<- mychroms[((n-1)*ntiles+1):length(mychroms)]
			}
		for (chromname in chromset)
			{
			if(chromname%%(ntiles/2)==0)
				{
				windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
				}else{
				if(mychroms[nchroms]==chromname&&addX==FALSE)
					{
					windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
					}else{
					windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=FALSE,mylwd=my_lwd)
					}
				}
			}
		if(addX&n==ntabs)
			{
			windowfst(chrom="X",selectcombi=mycomparisons,width=windowsize,yrange=c(0.025,0.225),yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
			}
		mtext("Weir & Cockerham Fst", side=2, line=1, outer=TRUE,cex=1.5)
		mtext("Position along chromosome (Mb)", side=1, line=-3.5, outer=TRUE,cex=1.25)
		# addlegend:
		if(n==ntabs)
			{
			nempty	<- ifelse(addX,(ntabs*ntiles-length(mychroms)-1+1),(ntabs*ntiles-length(mychroms)+1))
			for(mycounter in c(1:(nempty)+1))
				{
				plot(1,type ="n",axes=FALSE,xlab="",ylab="")	
				}
			}else{
			plot(1,type= "n",axes=FALSE,xlab="",ylab="")
			}
		legend(x="bottom",legend=combivector,horiz=T,fill=combicolours,cex=1.25,bty="n")
		if(!is.null(export)){dev.off()}
		}
	setwd(mysambar$inputdatadir)
	}	
	
# depends on function windowfst()
peakvalley<-function(myxby=5,my_lwd=2,mychrom=25,myregion=NULL,mywidth=20,add_legend=TRUE,export=FALSE,excludeoutliers=FALSE)
	{
	# myregion is vector which start and end in kB
	mypositions	<- snps$pos[snps$rfisherout_pheno]/1000000
	setwd(mysambar$selectiondir)
	if(export&excludeoutliers){pdf(paste("Peakvalley",(paste("chrom",mychrom,sep="")),(paste(mywidth,"snpsperwindow.excludingoutliers",sep="")),"pdf",sep="."),width=12,height=7)}
	if(export&(!excludeoutliers)){pdf(paste("Peakvalley",(paste("chrom",mychrom,sep="")),(paste(mywidth,"snpsperwindow.withoutliers",sep="")),"pdf",sep="."),width=12,height=7)}
	par(mfrow=c(2,1),mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,4,2),cex.axis=1.5)
	if(excludeoutliers)
		{
		mysnpselection	<- snps$filter2&(!snps$rfisherout_pheno)
		}else{
		mysnpselection	<- snps$filter2
		}
	windowfst(chrom=mychrom,width=mywidth,snpselection=mysnpselection,addlegend=add_legend,xrange=c(0,40000000),selectcombi=c(2,3),yrange=c(0,0.25),xby=myxby,xaxislabels=FALSE,addchrom=FALSE,mylwd=my_lwd,region=myregion)	
	abline(v=mypositions,lty=2)
	windowfst(chrom=mychrom,width=mywidth,snpselection=mysnpselection,addlegend=add_legend,xrange=c(0,40000000),selectcombi=1,yrange=c(0,0.3),xby=myxby,addchrom=FALSE,mylwd=my_lwd,region=myregion)
	abline(v=mypositions,lty=2)
	mtext("Position along chromosome (Mb)",side=1,line=2.5,outer=TRUE,cex=2)
	mtext("WC Fst",side=2,line=1.25,outer=TRUE,cex=2)
	mtext(paste("Chromosome",mychrom,sep=" "),side=3,line=0.5,outer=TRUE,cex=2)
	if(export){dev.off()}
	setwd(mysambar$inputdatadir)
	}

# plot location of genes on scaffold/contig/chromosome:	
multiplotscaffold<-function(my_bed=NULL,doexport=FALSE,background_pop=NULL,x_range=NULL,y_loc=c(0.4,0.65))
	{
	if(is.null(my_bed))
		{
		return(cat("Input file to my_bed argument is missing.",sep="\n"))
		}
	mygenes				<- read.table(my_bed,header=FALSE)
	colnames(mygenes)	<- c("chr","startbp","endbp","feature")
	mygenes				<<- mygenes
	for(mycontig in mygenes$chr)
		{
		plotscaffold(export=doexport,scaffold=mycontig,backgroundpop=background_pop,mybed=my_bed,xrange=NULL,yloc=y_loc)
		}
	}
	
plotscaffold<-function(export=FALSE,scaffold="scaffold1947_size412474",backgroundpop=NULL,mybed=NULL,popnames=mysambar$populations,xrange=NULL,yloc=c(0.4,0.65))
	{
	setwd(mysambar$selectiondir)
	npop	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npop]
	if(!is.null(backgroundpop))
		{
		otherpops	<- popnames[popnames!=backgroundpop]
		othercols	<- mycols[popnames!=backgroundpop]
		backgroundcol<- mycols[popnames==backgroundpop]
		mycols		<- c(backgroundcol,othercols)
		popnames	<- c(backgroundpop,otherpops)
		}
	plotname<- paste("MAF",scaffold,"pdf",sep=".")
	if(is.null(xrange)){xrange=c(min(snps$pos[snps$chr==scaffold]),max(snps$pos[snps$chr==scaffold]))}
	xrange	<- xrange/1000
	xrange	<<- xrange
	if(export)
		{
		pdf(plotname,width=10,height=5)
		}
	par(mar=c(5,5,1,1))
	for(p in c(1:npop))
		{
		mypop	<- popnames[p]
		mycol	<- mycols[p]
		mypopmaf<- snps[,paste("maf",mypop,sep="_")]
		if(p==1)
			{
			plot(snps$pos[snps$chr==scaffold]/1000,mypopmaf[snps$chr==scaffold],type='l',col="white",ylim=c(0,1),xlim=xrange,lwd=1,ylab="MAF",xlab="Position (kb)",pch=16,las=1,cex.axis=1.5,cex.lab=2)
			mycol2<-adjustcolor(mycol,alpha.f = 0.3) 
			polygon(c(snps$pos[snps$chr==scaffold]/1000,rev(snps$pos[snps$chr==scaffold]/1000)),c(rep(0,length(mypopmaf[snps$chr==scaffold])),rev(mypopmaf[snps$chr==scaffold])),col=mycol2,border=NA)
			points(snps$pos[snps$chr==scaffold]/1000,mypopmaf[snps$chr==scaffold],col=mycol,pch=16)
			points(snps$pos[snps$chr==scaffold&snps$rfisherout_pheno]/1000,mypopmaf[snps$chr==scaffold&snps$rfisherout_pheno]+0.025,col="black",pch=8,cex=1.25)
			}else{
			points(snps$pos[snps$chr==scaffold]/1000,mypopmaf[snps$chr==scaffold],col=mycol,lwd=1.5,pch=16,type='b')
			}
		}
	mtext(side=3,scaffold,line=-1.5,cex=1.5)	
	legend("topright",legend=popnames,fill=mycols,cex=1.5,bty='n')
	if(!is.null(mybed))
		{
		mygenes				<- read.table(mybed,header=FALSE,sep="\t")
		colnames(mygenes)	<- c("chr","startbp","endbp","feature")
		mygenes				<- mygenes[mygenes$chr==scaffold,]
		mygenes$overlap		<- 1000000
		if((nrow(mygenes))>1)
			{
			for(j in c(2:nrow(mygenes))){mygenes$overlap[j]<-mygenes$startbp[j]-mygenes$startbp[j-1]}
			}
		mygenes$overlap2	<-ifelse((abs(mygenes$overlap))<5000,FALSE,TRUE)
		if(any(mygenes$overlap2))
			{
			text(mygenes$feature[mygenes$overlap2],x=mygenes$startbp[mygenes$overlap2]/1000,y=yloc[1],srt=90,adj=0)
			if(any(!mygenes$overlap2))
				{
				text(mygenes$feature[!mygenes$overlap2],x=mygenes$startbp[!mygenes$overlap2]/1000,y=yloc[2],srt=90,adj=0)
				}
			}
		}
	if(export){dev.off()}
	}

	
# End of selection analyses 
###############################################################################################################







###############################################################################################################
# Association analysis

# depends on locusWCfst:
assocfisher<-function(pheno="sex",export=NULL,mylabels=c("male","female"))
	{
	setwd(mysambar$selectiondir)
	# pheno should be name of column in inds dataframe
	if(!pheno%in%colnames(inds))
		{
		return(cat("ERROR: input to pheno (default is 'sex') should be the name of a column in the inds dataframe.",sep="\n"))
		}
	mypheno		<- inds[,pheno]
	mylevels	<- unique(mypheno[!is.na(mypheno)])
	if(length(mylevels)!=2)
		{
		return(cat("ERROR: pheno should contain 2 levels. Not more, not less.",sep="\n"))
		}
	phenobool	<- ifelse(mypheno==mylevels[1],TRUE,FALSE)
	#
	cat("Extracting minor allele frequencies...",sep="\n")
	snps$maf_assoc1 	<<- glMean(mygenlight[inds$filter&phenobool,])
	snps$maf_assoc2 	<<- glMean(mygenlight[inds$filter&!phenobool,])
	#
	cat("Calculation locus specific He and Fst...",sep="\n")
	locusWCfst(my_dataset="assoc1_assoc2",mycol="grey",do_plot=TRUE)
	#
	cat("Executing Fisher exact tests...",sep="\n")
	# For phenotype 1:
	indfilter	<- inds$filter&phenobool
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for pheno==TRUE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor1			<- as.vector(glSum(mygenlight[indfilter,]))
	major1			<- nonmisscount-minor1
	# For phenotype 2:
	indfilter		<- inds$filter&!phenobool
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for pheno==FALSE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor2			<- as.vector(glSum(mygenlight[indfilter,]))
	major2			<- nonmisscount-minor2	
	#
	snps$assoclogp		<<-	NULL
	snps$assocout		<<- NULL
	macmatrix			<- rbind(major1,minor1,major2,minor2)
	plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(1,2,3,4),i],2,2,byrow=TRUE)})
	rfisherp			<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
	snps$assoclogp		<<- -log(rfisherp)
	snps$assoclogp[snps$assoclogp<0.0001]	<<- 0	# 10-11-2019: to avoid negative or infinitely small values
	#
	cat("Testing which loci are outliers using Bonferroni correction...",sep="\n")
	# we apply the bonferroni correction and assume that the distribution of the logp values fit an exponential distribution
	mymean				<- mean(snps$assoclogp[snps$filter2])	
	myrate				<- 1/mymean
	mybonf				<- 1-(0.05/(nrow(snps[snps$filter2,])))
	myvalue				<- qexp(mybonf,myrate)
	snps$assocout		<<-	snps$assoclogp>myvalue
	noutliers			<- nrow(snps[snps$assocout,])
	cat(paste("Found",noutliers,"outlier loci.",sep=" "),sep="\n")
	# rename columns:
	names(snps)[names(snps) == "assoclogp"] 	<<- paste("rfisherlogp","assoc1","assoc2",sep = "_")
	names(snps)[names(snps) == "assocout"] 		<<- paste("rfisherout","assoc1","assoc2",sep = "_")
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	cat("Creating Fdist plot...",sep="\n")
	Fdist_plot(my_dataset="assoc1_assoc2",showlabels=TRUE,exporttype=export,axislabels=TRUE,add_borders=TRUE,add_outliers=TRUE,y_axis='s',x_axis='s',my_labels=mylabels,dothin=TRUE,silent=TRUE)
	}	

# End of association analyses 	
###############################################################################################################








###############################################################################################################
# Data management and generally used functions

do_heatmap<-function(export_type=NULL,nbins=NULL,mymatrix=nei,my_inds=inds,my_snps=snps,my_col="orange",exportname="mymatrix",mytitle=NULL,addlegend=TRUE,myBreaks=NULL,addlab=TRUE)
		{
		mymatrix[lower.tri(mymatrix, diag = FALSE)]<-NA
		# create colours:
		if(is.null(myBreaks))
			{
			floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
			ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
			mymin		<- floor_dec(min(mymatrix,na.rm=TRUE),1)
			mymax		<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
			binsize		<- ifelse(is.null(nbins),(mymax-mymin)/10,(mymax-mymin)/nbins)
			myBreaks	<- seq(mymin,mymax,binsize)
			}
		mycolfunc 	<- colorRampPalette(c("white",my_col))
		myColours	<- c(mycolfunc(length(myBreaks)-1))
		myinds		<- my_inds$nr[my_inds$filter]
		mypopcols	<- my_inds$popcol[my_inds$filter]
		# plot:
		graphics.off()
		if(!is.null(export_type))
			{
			if(export_type=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export_type=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export_type=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			if(export_type=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
			}
		if(addlab)
			{
			heatpos	<- heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=my_inds$nr[my_inds$filter],labCol=my_inds$nr[my_inds$filter],key=FALSE,Rowv=NA,
			Colv=NA,scale="none",RowSideColors=mypopcols,ColSideColors=mypopcols,col=myColours,breaks=myBreaks,dendrogram="none",trace="none")
			mtext("sample nr", side = 1, cex = 2, line = 3.5)
			mtext("sample nr", side = 4, cex = 2, line = 0.5)
			}else{
			heatpos	<- heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=NA,labCol=NA,key=FALSE,Rowv=NA,
			Colv=NA,scale="none",RowSideColors=mypopcols,ColSideColors=mypopcols,col=myColours,breaks=myBreaks,dendrogram="none",trace="none")
			}
		if(!is.null(mytitle)){mtext(mytitle, side = 3, line = 1, cex = 3)}
		# legend:
		if(addlegend)
			{
			mylimits	<- paste("[",heatpos$colorTable$low,",",heatpos$colorTable$high,")",sep="")
			legend(x=0.1,y=0.35,legend=mylimits,fill=myColours,bty='n',cex=2.5)
			}
		if(!is.null(export_type)){dev.off()}
		}	

genlight2DNAbin<-function(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,exportname="filtereddata.diploid.fa",quiet=FALSE) 
	{
  	cat("Converting from genlight to DNAbin format...",sep="\n")
	# Input should be a genlight object
	x				<- as.matrix(input[indsfilter,snpsfilter]) 
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
	genot2			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
	# We create vectors of minor and major alleles (should match with the columns of the x-matrix):
	minor		<- in_snps$minor[snpsfilter]
	major		<- in_snps$major[snpsfilter]
	# We first convert to diploid genotype score matrix:
	for (j in c(1:ncol(x))) 
		{
    	maj			<- major[j]
    	min			<- minor[j]
    	g			<- x[,j]
     	g[is.na(g)]	<- paste("N")  				
    	g[g==0]		<- paste(maj,maj,sep="") 			 
    	g[g==1]		<- paste(min,maj,sep="") 		
    	g[g==2]		<- paste(min,min,sep="") 		
    	genot[,j]	<- g
		}
	# Next we convert to diploid sequences:
	for (j in c(1:ncol(x))) 
		{
		g					<- genot[,j]
		g[g=="11"] 			<- "A"
        g[g=="22"]  		<- "C"
		g[g=="33"]			<- "G"
		g[g=="44"]  		<- "T"
		g[g=="12"|g=="21"] 	<- "M"
       	g[g=="13"|g=="31"]	<- "R"
		g[g=="14"|g=="41"] 	<- "W"
        g[g=="23"|g=="32"]  <- "S"
		g[g=="24"|g=="42"]	<- "Y"
		g[g=="34"|g=="43"]  <- "K"
		genot2[,j]			<- g
		}
	mydnabin			<<- as.DNAbin(genot2)
	rownames(mydnabin)	<<- in_inds$name[indsfilter]
	mysambar$mydnabin	<<- mydnabin
	if(export)
		{
		exportname2		<- paste(mysambar$inputfilesdir,exportname,sep="/")
		cat(file=exportname2,paste(paste0(">",rownames(mydnabin)),sapply(mydnabin, paste, collapse=""), sep="\n"), sep="\n")
		if(!quiet)
			{
			cat(paste("Fasta file has been written to", exportname, sep =" "),sep="\n")
			}
		}
	}	

genlight2structure<-function(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,exportname=NULL,quiet=FALSE,popasfirstcolumn=TRUE) 
	{
  	cat("Converting from genlight to structure format...",sep="\n")
	# Input should be a genlight object
	x				<- as.matrix(input[indsfilter,snpsfilter]) 
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x)*2)
	# We create vectors of minor and major alleles (should match with the columns of the x-matrix):
	minor		<- in_snps$minor[snpsfilter]
	major		<- in_snps$major[snpsfilter]
	for (j in c(1:ncol(x))) 
		{
    	maj					<- major[j]
    	min					<- minor[j]
    	g					<- x[,j]
    	allele1				<- rep(NA,nrow(x))
		allele2				<- rep(NA,nrow(x))
		allele1[is.na(g)]	<- -9
		allele2[is.na(g)]	<- -9
	   	allele1[g==0]		<- maj
		allele2[g==0]		<- maj			 
    	allele1[g==1]		<- maj
		allele2[g==1]		<- min	
    	allele1[g==2]		<- min 
		allele2[g==2]		<- min 		
    	genot[,j*2-1]		<- allele1
		genot[,j*2]			<- allele2
		}
  	if(popasfirstcolumn)
		{
		strufile		<- cbind(pop=(in_inds$pop2[indsfilter]),sample=indNames(input[indsfilter,]),as.data.frame(genot))
		}else{
		strufile		<- cbind(sample=indNames(input[indsfilter,]),pop=(in_inds$pop2[indsfilter]),as.data.frame(genot))
		}
	# add column names:
	lociname1		<- snps$name[snps$filter]
	lociname1		<- paste(lociname1,"1",sep="_")
	lociname2		<- snps$name[snps$filter]
	lociname2		<- paste(lociname2,"2",sep="_")
	locnames		<- c(rbind(lociname1,lociname2))
	if(popasfirstcolumn)
		{
		colnames(strufile)	<- c("pop","sample",locnames)
		}else{
		colnames(strufile)	<- c("sample","pop",locnames)
		}
	mysambar$mystructure <<- strufile
	if(!quiet)
		{
		cat("Structure format has been saved in mysambar$mystructure.",sep="\n")
		}
	if(!is.null(exportname))
		{
		# Export:
		cat("Exporting structure file...",sep="\n")
		exportname2		<- paste(exportname,"stru",sep = ".")
		exportname3		<- paste(mysambar$inputfilesdir,exportname2,sep="/")
		write.table(strufile,file=exportname3,sep="\t",row.names=FALSE,col.names=TRUE,quote=FALSE)
		if(!quiet)
			{
			cat(paste("Structure file has been written to", exportname3, sep =" "),sep="\n")
			}
		}
	}	
	
# Export to ped and map
genlight2ped<-function(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,exportname="filtered.data",pheno=NULL,genonumber=TRUE,quiet=FALSE) 
	{
  	# Input should be a genlight object
	# We are going to convert this genlight object input file into a matrix with 0,1,2 or NA-values:
	x				<- as.matrix(input[indsfilter,snpsfilter]) 
  	# Now we are ready to create our PED-file, starting with an empty matrix:
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
  	rownames(genot)	<- rownames(x)
  	colnames(genot)	<- colnames(x)
	# We create vectors of minor and major alleles (should match with the columns of the x-matrix):
	if(genonumber)
		{
		minor		<- in_snps$minor[snpsfilter]
		major		<- in_snps$major[snpsfilter]
		missing		<- as.character(0)
		}else{
		minor		<- in_snps$minor2[snpsfilter]
		major		<- in_snps$major2[snpsfilter]
		missing		<- as.character(0)
		}
	if(any(minor=="NA"))
		{
		return(cat("ERROR: NA's in snps$minor column.",sep="\n"))
		}
	if(any(major=="NA"))
		{
		return(cat("ERROR: NA's in snps$major column.",sep="\n"))
		}
	for (j in c(1:ncol(genot))) 
		{
    	g			<- x[,j]
    	maj			<- as.character(major[j])
    	min			<- as.character(minor[j])
    	g[is.na(g)]	<- paste(missing,missing,sep=" ")  				
    	g[g==0]		<- paste(maj,maj,sep=" ") 			 
    	g[g==1]		<- paste(min,maj,sep=" ") 		
    	g[g==2]		<- paste(min,min,sep=" ") 		
    	genot[,j]	<- g
  		}
  	pedfiledata<-as.data.frame(genot)
	# Include additional information to pedfile:
	if (is.null(pheno))	
		{
		pedfile		<-cbind(FID=(in_inds$pop2[indsfilter]),IID=indNames(input[indsfilter,]),PAT=0,MAT=0,SEX=0,PHENOTYPE=-9,pedfiledata)
		}else{
		pedfile		<-cbind(FID=(in_inds$pop2[indsfilter]),IID=indNames(input[indsfilter,]),PAT=0,MAT=0,SEX=0,PHENOTYPE=pheno[indsfilter],pedfiledata)
		}
	pedfile		<<- pedfile
	# Next create the MAP-file:
	# if(any(names(snps) == "chr"))
	#{
	if(is.factor(in_snps$name))
		{
		locus_names	<- in_snps$name
		}else{
		locus_names	<- as.character.factor(in_snps$name)
		}
	mapfile		<- data.frame("chr"=(as.vector(in_snps$chr[snpsfilter])),"name"=locus_names[snpsfilter],"gd"=0,"pos"=in_snps$pos[snpsfilter])
	# Finally, export the files:
	write.table(pedfile,file=paste(exportname,"ped",sep = "."),sep="\t",na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	write.table(mapfile,file=paste(exportname,"map",sep = "."),sep="\t",na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	if(!quiet)
		{
		path1<- paste(getwd(),exportname,sep="/")
		cat(paste("PED and MAP files have been written to", path1, sep =" "),sep="\n")
		}
	}

# this function exports PED and MAP files for all populations separately and for all pops combined:
# depends on function 'genlight2ped':
exportdata<-function(indsfilter=inds$filter,snpsfilter=snps$filter,popnames=mysambar$populations,export_name="filter1",geno_nr=TRUE,quiet2=FALSE,do_all=TRUE,do_pheno=FALSE)
	{ 
	if(do_all)
		{
		exportnametemp	<- paste("metapop",export_name,sep=".")
		}else{
		exportnametemp	<- export_name
		}
	genlighttemp		<- mygenlight[indsfilter,snpsfilter]
	snpstemp			<- snps[snpsfilter,]
	indstemp			<- inds[indsfilter,]
	if(do_pheno)
		{
		indstemp$pop2	<- indstemp$type
		}
	genlight2ped(genonumber=geno_nr,exportname=exportnametemp,input=genlighttemp,in_snps=snpstemp,in_inds=indstemp,snpsfilter=rep(TRUE,nrow(snpstemp)),indsfilter=rep(TRUE,nrow(indstemp)),quiet=quiet2)
	if(do_all)
		{
		for (mypop in popnames)
			{
			genlighttemp	<- mygenlight[inds$pop2==mypop&indsfilter,snpsfilter]
			snpstemp		<- snps[snpsfilter,]
			indstemp		<- inds[inds$pop2==mypop&indsfilter,]
			exportnametemp	<- paste(mypop,export_name,sep=".")
			genlight2ped(genonumber=geno_nr,exportname=exportnametemp,input=genlighttemp,in_snps=snpstemp,in_inds=indstemp,snpsfilter=rep(TRUE,nrow(snpstemp)),indsfilter=rep(TRUE,nrow(indstemp)),quiet=quiet2)
			}
		}
	}

# Export to Immanc format:
genlight2immanc<-function(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,exportname="Bayesassinput.immanc.txt",quiet=FALSE) 
	{
  	# Input should be a genlight object
	x				<- as.matrix(input[indsfilter,snpsfilter]) 	
	# indicate whether allele1 and allele2 are major (1) or minor allele (2):
	g1				<- x 	# first allele
	g1[g1==0]		<- 1
	g2				<- x	# second allele
	g2[g2==1]		<- 2
	g2[g2==0]		<- 1
	allele1			<- as.vector(unlist(g1))
	allele2			<- as.vector(unlist(g2))
	# create dataframe:
	mysnps			<- snps$name[snpsfilter]
	nsnps			<- length(mysnps)
	myinds			<- inds[indsfilter,c("name","pop2")]
	ninds			<- nrow(myinds)
	mysnps2			<- rep(mysnps,each=ninds)
	myinds2			<- coredata(myinds)[rep(seq(nrow(myinds)),nsnps),]
	myoutput		<<- as.data.frame(cbind(myinds2,mysnps2,allele1,allele2))
	# export:
	write.table(myoutput,exportname,sep="\t",na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	if(!quiet)
		{
		path1	<- paste(getwd(),exportname,sep="/")
		cat(paste("Bayesass input (immanc format) has been written to", path1, sep =" "),sep="\n")
		}
	}

# This function converts everything to 01 and/or 02, regardless of actuall allele.
genlight2genepop<-function(input=mygenlight,snpsfilter=snps$filter,indsfilter=inds$filter,addcomma=FALSE) 
	{
  	# Input should be a genlight object
	g1				<- as.data.frame(input[indsfilter,snpsfilter]) 	
	# indicate whether allele1 and allele2 are major (1) or minor allele (2):
	g1[g1==0]		<- "0101"
	g1[g1==1]		<- "0102"
	g1[g1==2]		<- "0202"
	if(addcomma)
		{
		rownames(g1)<- paste(rownames(g1),",",sep="\t")
		}
	mygenepop		<<- g1
	}

# from inds, snps and mygenlight to sambar list:
backupdata<-function(myprefix=NULL)
	{
	if(is.null(myprefix))
		{
		cat("ERROR: You have to provide a prefix.",sep="\n")
		}else{
		myglobal	<- globalenv()
		mylist		<- mysambar
		mylist$inds	<- inds
		mylist$snps	<- snps
		mylist$genlight	<- mygenlight
		assign(myprefix,mylist,envir=myglobal)
		cat(paste("A back up of your data objects has been stored in a list object called:", myprefix,sep=" "),sep="\n")
		}
	}

# from sambar list to inds, snps and mygenlight:
getdata<-function(myprefix=NULL)
	{
	if(is.null(myprefix))
		{
		cat("ERROR: You have to provide a prefix.",sep="\n")
		}else{
		myglobal	<- globalenv()
		mylist		<- get(myprefix,envir=myglobal)
		inds		<<- mylist$inds
		snps		<<- mylist$snps
		mygenlight	<<- mylist$genlight
		mylist$snps	<- "snps"
		mylist$inds	<- "inds"
		mylist$genlight	<- "genlight"
		mysambar	<<- mylist
		cat("Data has been loaded to inds, snps and mygenlight objects.",sep="\n")
		setwd(mysambar$inputdatadir)
		cat("Working directory has been set to:",sep="\n")
		cat(mysambar$inputdatadir,sep="\n")
		}
	}

# Exlude certain individuals from subsequent analyses:
subset_pop<-function(include_pops=NULL)
	{
	if(is.null(include_pops))
		{
		cat("ERROR: provide an input vector to the 'include_pops' argument. E.g.:",sep="\n")
		cat('popsubset(include_pops=c("popname1","popname2","etc"))',sep="\n")
		return(cat("This input vector should contain the names of the populations you want to select.",sep="\n"))
		}
	cat("Subselecting populations. Note that this function should be executed after the filterdata() function, not before!",sep="\n")
	if(any(!include_pops%in%mysambar$populations))
		{
		return(cat("ERROR: one or more population names not found in existing dataset.",sep="\n"))
		}
	mybool					<- mysambar$populations%in%include_pops
	mysambar$populations	<<- mysambar$populations[mybool]
	mysambar$mycolours		<<- mysambar$mycolours[mybool]	
	mybool2					<- inds$pop%in%include_pops
	inds$filter				<<- inds$filter&mybool2
	#
	# Screen info:
	snpstemp				<- snps[,paste("maf",include_pops,sep="_")]
	mafsum					<- rowSums(snpstemp)
	npoly					<- length(mafsum[mafsum>0])
	nind					<- nrow(inds[inds$filter,])
	cat("Done. Individuals which don't belong to populations defined in the include_pops argument, will be excluded from subsequent analyses.",sep="\n")
	cat(paste("This smaller dataset contains ",nind," retained individuals and ",npoly," polymorphic sites.",sep=""),sep="\n")
	cat("Don't run the filterdata() function, because this will partially undo the changes. To undo the changes, rerun the importdata() function.",sep="\n")
	#table(inds$pop,inds$filter)
	}
	
# create a targetted subset of SNP dataset:
subselectdata<-function(snp_names=NULL,name2=TRUE,name3=FALSE)
	{
	if(is.null(snp_names))
		{
		return(cat("ERROR: no snpnames provided to snp_names argument.",sep="\n"))
		}	
	if(name2)
		{
		myselection		<- snps$name2%in%snp_names
		}else{
		if(name3)
			{
			myselection		<- snps$name3%in%snp_names
			}else{
			myselection		<- snps$name%in%snp_names
			}
		}
	nhits			<- length(myselection[myselection])
	cat(paste("Found",nhits,"snps",sep=" "),sep="\n")
	if(nhits==0)
		{
		return(cat("0 hits. Subsetting aborted.",sep="\n"))
		}
	matrixtemp		<- as.matrix(mygenlight)[,myselection]
	snpstemp		<- snps[myselection,]
	# create sambar list:
	# sambar list:
	inputdatadir		<- getwd()
	inputdatadir		<- paste(inputdatadir,"Subset",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambarsubset			<<- list()
	mysambarsubset[[1]]		<<- mysambar$populations
	mysambarsubset[[2]]		<<- inds
	mysambarsubset[[3]]		<<- snpstemp
	mysambarsubset[[4]]		<<- as.genlight(matrixtemp)
	mysambarsubset[[5]]		<<- inputdatadir
	mysambarsubset[[6]]		<<- sambardir
	mysambarsubset[[7]]		<<- QCdir
	mysambarsubset[[8]]		<<- structuredir
	mysambarsubset[[9]]		<<- divergencedir
	mysambarsubset[[10]]	<<- diversitydir
	mysambarsubset[[11]]	<<- demographydir
	mysambarsubset[[12]]	<<- selectiondir
	mysambarsubset[[13]]	<<- inputfilesdir
	mysambarsubset[[14]]	<<- "sans"
	mysambarsubset[[17]]	<<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20")
	mysambarsubset[[18]]	<<- geomapsdir
	names(mysambarsubset)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	cat("Data subset has been stored in a list object called 'mysambarsubset'.",sep="\n")
	cat("You can load the data by typing: getdata('mysambarsubset').",sep="\n")
	cat("However, before loading make sure to first backup original dataset using the backupdata()-function.",sep="\n")
	cat("Also note: the information in snps and inds data is still based on entire dataset, not on subset.",sep="\n")
	cat("Therefore, after loading run the filterdata(), findstructure(), calcdistance() and calcdiversity() functions again.",sep="\n")
	}	
	
# create a random subset of SNP dataset (subset can be based on snps and/or inds):
subsampledata<-function(nrinds=NULL,nrsnps=NULL,exportprefix=NULL,remove_stats=TRUE,popcolours=NULL)
	{
	if(is.null(nrinds)&is.null(nrsnps))
		{
		return(cat("ERROR: how many individuals (nrinds) and how many loci (nrsnps) should be subsampled?",sep="\n"))
		}
	if(!is.null(nrinds))
		{
		indstemp1	<- inds[inds$filter,]
		indstemp2	<- c(1:nrow(indstemp1))
		indstemp3	<- sample(indstemp2,nrinds,replace = FALSE)
		indstemp3	<- indstemp3[order(indstemp3)]
		indstemp	<- indstemp1[indstemp3,]
		}else{
		indstemp	<- inds
		indstemp3	<- c(1:nrow(indstemp))
		}
	if(!is.null(nrsnps))
		{
		snpstemp1	<- snps[snps$filter,]
		snpstemp2	<- c(1:nrow(snpstemp1))
		snpstemp3	<- sample(snpstemp2,nrsnps,replace = FALSE)
		snpstemp3	<- snpstemp3[order(snpstemp3)]
		snpstemp	<- snpstemp1[snpstemp3,]
		}else{
		snpstemp	<- snps[snps$filter,]
		snpstemp3	<- c(1:nrow(snpstemp))
		}
	#
	# subsample genlight:
	if(!is.null(nrsnps)&(!is.null(nrinds)))
		{
		matrixtemp		<- as.matrix(mygenlight)[inds$filter,snps$filter]
		}
	if(!is.null(nrsnps)&(is.null(nrinds)))
		{
		matrixtemp		<- as.matrix(mygenlight)[,snps$filter]
		}
	if(is.null(nrsnps)&(!is.null(nrinds)))
		{
		matrixtemp		<- as.matrix(mygenlight)[inds$filter,]
		}
	matrixtemp		<- matrixtemp[indstemp3,snpstemp3]
	genlighttemp	<- as.genlight(matrixtemp)
	if(remove_stats)
		{
		indstemp	<- indstemp[,c("name","pop","pop2","nr","popcol","meandepth","name2")]
		snpstemp	<- snpstemp[,c("chr","name","morgan","pos","minor","major","minor2","major2","stackID","stackbp","readpos","sameread","name2","placed","autosomal","dist","dist2","samepos","uniqpos","meandepth","depthfilter","poly")]
		}
	#
	# sambar list:
	setwd(mysambar$inputdatadir)
	inputdatadir		<- getwd()
	inputdatadir		<- paste(inputdatadir,"Subsetdata",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	# store in list called mysambarsubset: 
	mysambarsubset				<<- list()
	populationstemp				<- as.vector(unique(indstemp$pop2))
	mysambarsubset$populations	<<- populationstemp
	mysambarsubset$inds			<<- indstemp
	mysambarsubset$snps			<<- snpstemp
	mysambarsubset$genlight		<<- genlighttemp
	mysambarsubset[[5]]			<<- inputdatadir
	mysambarsubset[[6]]			<<- sambardir
	mysambarsubset[[7]]			<<- QCdir
	mysambarsubset[[8]]			<<- structuredir
	mysambarsubset[[9]]			<<- divergencedir
	mysambarsubset[[10]]		<<- diversitydir
	mysambarsubset[[11]]		<<- demographydir
	mysambarsubset[[12]]		<<- selectiondir
	mysambarsubset[[13]]		<<- inputfilesdir
	mysambarsubset[[14]]		<<- "sans"
	if(is.null(popcolours))
		{
		mysambarsubset[[17]]	<<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20")
		}else{
		mysambarsubset[[17]]	<<- popcolours
		}
	mysambarsubset[[18]]	<<- geomapsdir
	names(mysambarsubset)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	#
	cat("Data subset has been stored in a list object called 'mysambarsubset'.",sep="\n")
	cat("You can load the data by typing: getdata('mysambarsubset').",sep="\n")
	cat("However, before loading make sure to first backup original dataset using the backupdata()-function.",sep="\n")
	#
	# optionally export:
	if(!is.null(exportprefix))
		{
		setwd(inputdatadir)
		genlight2ped(input=genlighttemp,in_snps=snpstemp,in_inds=indstemp,snpsfilter=rep(TRUE,nrow(snpstemp)),indsfilter=rep(TRUE,nrow(indstemp)),exportname=exportprefix) 
		}
	}

#be sure to first back up your data using the backupdata function
dummydata<-function(nind=2,nsnp=4,q=0.15,popname="pop1",popcol="blue",mygeno=NULL,major=1,minor=4,colourvector=c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20"))
	{
	# q = minor allele freq
	# myprobs = probability of occurence of homo_major, hetero, hetero_minor
	myprobs		<- c((1-q)^2,(1-q)*q,(q^2))
	# snps:
	snpnr		<- c(1:nsnp)
	snpname		<- paste("snp",snpnr,sep="")
	snps		<<- as.data.frame(cbind(snpnr,snpname))
	colnames(snps)<<- c("nr","name")
	snps$chr	<<- "dummy_chr1"
	snps$pos	<<- snpnr
	snps$miss	<<- 0
	snps$filter	<<- TRUE
	snps$uniqpos<<- TRUE
	snps$poly	<<- TRUE
	snps$depthfilter	<<- TRUE
	# inds:
	indnr		<- c(1:nind)
	indname		<- paste("ind",indnr,popname,sep="")	
	inds		<<- as.data.frame(cbind(indnr,indname))
	colnames(inds)<<- c("nr","name")
	inds$pop	<<- popname
	inds$pop2	<<- popname
	inds$popcol	<<- popcol
	inds$miss	<<- 0
	inds$filter	<<- TRUE
	# genlight:
	if(!is.null(mygeno))
		{
		mymatrix 					<- matrix(mygeno,nrow=nind,ncol=nsnp,byrow=FALSE)
		}else{
		mymatrix					<- matrix(NA,nrow=nind,ncol=nsnp) 
		for (i in c(1:nrow(mymatrix)))
			{
			mymatrix[i,]				<- sample(c(0,1,2),nsnp,replace=TRUE,prob=myprobs)
			}
		}
	rownames(mymatrix)			<- inds$name
	colnames(mymatrix)			<- snps$name
	mygenlight					<<- as.genlight(mymatrix)
	# add info on minor allele to snps data frame:
	misscount					<- glNA(mygenlight,alleleAsUnit=FALSE)
	snps$nonmissallelecount 	<<- 2*nInd(mygenlight)-misscount
	inds$filter					<<- TRUE
	snps$filter					<<- TRUE
	snp_maf(popnames=popname)
	snps$minor					<<- minor
	snps$major					<<- major
	snps$minor2					<<- c("A","C","G","T")[minor]
	snps$major2					<<- c("A","C","G","T")[major]
	# sambar list:
	inputdatadir		<- getwd()
	inputdatadir		<- paste(inputdatadir,"Dummydata",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambar		<<- list()
	mysambar[[1]]	<<- popname
	mysambar[[5]]	<<- inputdatadir
	mysambar[[6]]	<<- sambardir
	mysambar[[7]]	<<- QCdir
	mysambar[[8]]	<<- structuredir
	mysambar[[9]]	<<- divergencedir
	mysambar[[10]]	<<- diversitydir
	mysambar[[11]]	<<- demographydir
	mysambar[[12]]	<<- selectiondir
	mysambar[[13]]	<<- inputfilesdir
	mysambar[[14]]	<<- "sans"
	mysambar[[17]]	<<- colourvector
	mysambar[[18]]	<<- inputfilesdir
	names(mysambar)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	#
	cat("New inds, snps and genlight objects have been created.",sep="\n")
	}	
	
# Find overlap between two datasets (stored as sambar list objects)	
findoverlap<-function(mylist1=NULL,mylist2=NULL,mycolours=NULL)
	{
	if(is.null(mycolours))
		{
		return(cat("ERROR: You have to provide the colours of all populations to combine, in alphabetical order of population names",sep="\n"))
		}
	ncolours					<- length(mycolours)
	### rename datasets:
	mydataset1.snps				<- mylist1$snps
	mydataset1.inds				<- mylist1$inds
	mydataset1.genlight			<- mylist1$genlight
	mydataset1.populations		<- mylist1$populations
	mydataset2.snps				<- mylist2$snps
	mydataset2.inds				<- mylist2$inds
	mydataset2.genlight			<- mylist2$genlight
	mydataset2.populations		<- mylist2$populations
	#
	if(any(!colnames(as.matrix(mydataset1.genlight))==mydataset1.snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column for dataset1. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mydataset2.genlight))==mydataset2.snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column for dataset2. Contact developer of SambaR.",sep="\n"))
		}
	# combine populations vectors:
	populationscombi		<- as.vector(unique(c(mydataset1.populations,mydataset2.populations)))
	populationscombi		<- populationscombi[order(populationscombi)]
	if(length(populationscombi)!=ncolours)
		{
		return(cat("ERROR: Number of colours does not match overall number of populations in both datasets.",sep="\n"))
		}
	# How many individuals?
	n_ind1						<- nrow(mylist1$inds)
	n_ind2						<- nrow(mylist2$inds)
	n_both						<- n_ind1+n_ind2
	cat(paste("Dataset 1 contains",n_ind1,"individuals.",sep=" "),sep="\n")
	cat(paste("Dataset 2 contains",n_ind2,"individuals.",sep=" "),sep="\n")
	cat(paste("Combined dataset will contain",n_both,"individuals.",sep=" "),sep="\n")
	#
	### find overlapping snps (snps which occur in both datasets)
	snpstemp1				<- mydataset1.snps[mydataset1.snps$uniqpos,c("chr","pos")]
	snpstemp2				<- mydataset2.snps[mydataset2.snps$uniqpos,c("chr","pos")]	
	snpstemp1_name			<- mydataset1.snps[mydataset1.snps$uniqpos,c("chr","pos","name")]
	snpstemp2_name			<- mydataset2.snps[mydataset2.snps$uniqpos,c("chr","pos","name")]	
	chroms					<- as.vector(unique(snpstemp2$chr))
	common					<- list()
	howmany					<- vector()
	for (i in c(1:length(chroms)))
		{ 
		chro				<- chroms[i]
		temp1				<- snpstemp1$pos[snpstemp1$chr==chro]
		temp2				<- snpstemp2$pos[snpstemp2$chr==chro]	
		temp3				<- intersect(temp1,temp2)
		common[[i]]			<- temp3
		howmany[i]			<- length(temp3)
		}
	names(common)			<- chroms
	#sum(howmany)
	#
	### select the overlapping snps:
	mychroms				<- rep(chroms,howmany)
	mypos					<- unlist(common,use.names=FALSE)
	myoverlap				<- cbind(mychroms,mypos)
	myoverlap				<- as.data.frame(myoverlap)
	myoverlap				<<- myoverlap
	n_overlap				<- nrow(myoverlap)
	if(n_overlap>0)
		{
		cat(paste("Found",n_overlap,"snps shared between both datasets.",sep=" "),sep="\n")
		cat("Creating new dataset with shared snps...",sep="\n")
		}else{
		return(cat("The datasets don't have any loci in common. No new output files will be created.",sep="\n"))
		}
	### integrate boolean column (overlap yes or no) into input snp datasets:
	# into the first:
	snps					<- snpstemp1[,c("chr","pos")]
	snps$overlap			<- rep(NA,nrow(snps))
	for (i in c(1:nrow(myoverlap))) 
		{
		mychrom				<- as.vector(myoverlap$mychrom[i])
		mypos				<- as.numeric(as.vector(myoverlap$mypos[i]))
		snps$overlap[snps$chr==mychrom&snps$pos==mypos]<-TRUE	 
		}
	snps$overlap[is.na(snps$overlap)]<-FALSE
	snps$uniq				<- rep(NA,nrow(snps))
	for(j in c(1:nrow(snps)))
		{
		if(j==1)
			{
			snps$uniq[j]	<- TRUE
			}else{
			prevchrom		<- snps$chr[j-1]
			prevpos			<- snps$pos[j-1]
			currentchrom	<- snps$chr[j]
			currentpos		<- snps$pos[j]
			dupli			<- prevchrom==currentchrom&prevpos==currentpos
			snps$uniq[j]	<- ifelse(dupli,FALSE,TRUE)
			}
		}
	mygenlight				<- mydataset1.genlight[,mydataset1.snps$uniqpos]
	temp					<- as.matrix(mygenlight)
	overlap1				<- temp[,snps$overlap&snps$uniq]
	genlightpos1			<- colnames(overlap1) 
	snppos1					<- snpstemp1_name$name[snps$overlap&snps$uniq]
	# into the second:
	snps					<- snpstemp2[,c("chr","pos")]
	colnames(snps)			<- c("chr","pos")
	snps$overlap			<- rep(NA,nrow(snps))
	for (i in c(1:nrow(myoverlap))) 
		{
		mychrom				<- as.vector(myoverlap$mychrom[i])
		mypos				<- as.numeric(as.vector(myoverlap$mypos[i]))
		snps$overlap[snps$chr==mychrom&snps$pos==mypos] <-TRUE	 
		}
	snps$overlap[is.na(snps$overlap)] 	<-FALSE
	snps$uniq				<- rep(NA,nrow(snps))
	for(j in c(1:nrow(snps)))
		{
		if(j==1)
			{
			snps$uniq[j]	<- TRUE
			}else{
			prevchrom		<- snps$chr[j-1]
			prevpos			<- snps$pos[j-1]
			currentchrom	<- snps$chr[j]
			currentpos		<- snps$pos[j]
			dupli			<- prevchrom==currentchrom&prevpos==currentpos
			snps$uniq[j]	<- ifelse(dupli,FALSE,TRUE)
			}
		}
	mygenlight				<- mydataset2.genlight[,mydataset2.snps$uniqpos]
	temp					<- as.matrix(mygenlight)
	overlap2				<- temp[,snps$overlap&snps$uniq]
	genlightpos2			<- colnames(overlap2) 
	snppos2					<- snpstemp2_name$name[snps$overlap&snps$uniq]
	#
	# combine inds datasets:
	inds1					<- mydataset1.inds[,c("name","pop2","popcol")]
	inds2					<- mydataset2.inds[,c("name","pop2","popcol")]	
	indscombi				<- rbind(inds1,inds2)
	indscombi$nr			<- c(1:nrow(indscombi))
	indscombi$name2			<- NA
	if(grepl(".",as.vector(indscombi$name[1])))
		{
		for (i in c(1:nrow(indscombi)))
			{
			indscombi$name2[i]	<- strsplit(as.vector(indscombi$name[i]), "[.]")[[1]][1]
			}
		}else{
		indscombi$name2			<- substr(indscombi$name,start=1,stop=12)
		}
	for (i in c(1:nrow(indscombi))) 
		{
		indscombi$popcol[i]		<- mycolours[which(populationscombi==indscombi$pop2[i])]
		}
	indscombi$pop			<- indscombi$pop2
	#
	# combine genlight objects:
	alloverlap				<- rbind(overlap1,overlap2)
	genlightcombi			<- as.genlight(alloverlap)
	# combine snp datasets:
	snpscombi				<- myoverlap
	colnames(snpscombi)		<- c("chr","pos")
	#
	# add additional columns to snps:
	snpscombi$name			<- paste(snpscombi$chr,snpscombi$pos,sep="_")
	mydataset1.snps$name2	<- paste(mydataset1.snps$chr,mydataset1.snps$pos,sep="_")
	mydataset2.snps$name2	<- paste(mydataset2.snps$chr,mydataset2.snps$pos,sep="_")
	snpstemp1				<- mydataset1.snps[mydataset1.snps$uniqpos,c("name2","minor","major")]
	snpstemp2				<- mydataset2.snps[mydataset2.snps$uniqpos,c("name2","minor","major")]
	colnames(snpstemp1)		<- c("name","minor_data1","major_data1")
	colnames(snpstemp2)		<- c("name","minor_data2","major_data2")
	merged1					<- merge(x = snpscombi, y = snpstemp1, by="name", all.x=TRUE)
	merged2					<- merge(x = merged1, y = snpstemp2, by="name", all.x=TRUE)
	snpscombi				<- merged2
	snpscombi$name			<- as.factor(snpscombi$name)
	snpscombi$uniqpos		<- TRUE			# safe to assume? needed to run filters function later.
	snpscombi$depthfilter	<- TRUE
	snpscombi$poly			<- TRUE
	snpscombi$name_dataset1	<- snppos1
	snpscombi$name_dataset2	<- snppos2
	snpscombi$stackbp_dataset1	<- NA
	snpscombi$stackbp_dataset2	<- NA
	for(j in c(1:nrow(snpscombi)))
		{
		snpscombi$stackbp_dataset1[j]	<- strsplit(as.character(snpscombi$name_dataset1[j]),split='_', fixed=TRUE)[[1]][2]
		snpscombi$stackbp_dataset2[j]	<- strsplit(as.character(snpscombi$name_dataset2[j]),split='_', fixed=TRUE)[[1]][2]
		}
	snpscombi$samestackbp	<- snpscombi$stackbp_dataset1==snpscombi$stackbp_dataset2
	my_overlap				<<- data.frame("snpname1"=snppos1,"genlightname1"=genlightpos1,"snpname2"=snppos2,"genlightname2"=genlightpos2,"pos"=snpscombi$name)
	#
	# now we have to check for each locus whether the datasets had the same minor allele or whether it is reversed:
	snpscombi$minorequal	<- snpscombi$minor_data1==snpscombi$minor_data2
	snpscombi$majorequal	<- snpscombi$major_data1==snpscombi$major_data2
	snpscombi$inversed		<- (snpscombi$major_data1==snpscombi$minor_data2)&(snpscombi$minor_data1==snpscombi$major_data2)
	n_equal	 <- nrow(snpscombi[snpscombi$minorequal&snpscombi$majorequal,])
	n_inverse<- nrow(snpscombi[snpscombi$inversed,])
	cat(paste(n_equal," out of ",n_overlap," SNPs have corresponding minor and major alleles among the two input datasets.",sep=""),sep="\n")
	cat(paste(n_inverse," out of ",n_overlap," SNPs have inversed minor and major alleles.",sep=""),sep="\n")
	# make a correction for inversed mafs in genlight object:
	# inversion is done for individuals of mypops2 (rather than for individuals of mypops1)
	# 03072019: to improve: inversion should be done based on which dataset is bigger. i.e. n_ind1 > nind2
	mypopmatrix 			<- as.matrix(genlightcombi[which(indscombi$pop2 %in% mylist2$populations),])
	otherpopsmatrix 		<- as.matrix(genlightcombi[which(indscombi$pop2 %in% mylist1$populations),])
	for (i in c(1:(ncol(mypopmatrix))))
		{
		if (snpscombi$inversed[i])
			{
			# edit data in genlight object:
			temp				<- mypopmatrix[,i]
			temp[temp==0]		<- 3
			temp[temp==2]		<- 0
			temp[temp==3]		<- 2
			mypopmatrix[,i]		<- temp
			}
		}
	combinedmatrix			<- rbind(mypopmatrix,otherpopsmatrix)
	genlightcombi			<- as.genlight(combinedmatrix)
	genlightcombi@pop		<- as.factor(indscombi$pop2)
	snpscombi$minor			<- snpscombi$minor_data1
	snpscombi$major			<- snpscombi$major_data1
	snpscombi$minor2		<- NA
	snpscombi$major2		<- NA
	for(i in c(1:nrow(snpscombi)))
		{
		snpscombi$minor2[i]		<- c("A","C","G","T")[snpscombi$minor[i]]
		snpscombi$major2[i]		<- c("A","C","G","T")[snpscombi$major[i]]
		}
	#
	# reorder data based on individual names:
	indscombi$name	<- as.character(indscombi$name)
	indscombi		<- indscombi[order(indscombi$name),]
	indscombi$nr	<- c(1:nrow(indscombi))
	# reorder genlight object based on individual names:
	matrixtemp		<- as.matrix(genlightcombi)
	tempnames		<- rownames(matrixtemp)	
	matrixtemp2		<- matrixtemp[order(tempnames),]
	genlightcombi	<- as.genlight(matrixtemp2)
	# 
	# change colnames of genlight matrix:
	matrixtemp			<- as.matrix(genlightcombi)
	colnames(matrixtemp)<- snpscombi$name
	genlightcombi		<- as.genlight(matrixtemp)
	#
	# store objects in new Sambar list object:
	cat("Creating new sambar list and output directories...",sep="\n")
	mysambarcombined				<<- list()
	mysambarcombined$populations	<<- populationscombi
	mysambarcombined$inds			<<- indscombi
	mysambarcombined$snps			<<- snpscombi
	mysambarcombined$genlight		<<- genlightcombi 
	### create SambaR directories:
	cat("Creating output directories...",sep="\n")
	inputdatadir		<- getwd()
	inputdatadir		<- paste(inputdatadir,"Combined_data",sep="/")
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambarcombined[[5]]	<<- inputdatadir
	mysambarcombined[[6]]	<<- sambardir
	mysambarcombined[[7]]	<<- QCdir
	mysambarcombined[[8]]	<<- structuredir
	mysambarcombined[[9]]	<<- divergencedir
	mysambarcombined[[10]]	<<- diversitydir
	mysambarcombined[[11]]	<<- demographydir
	mysambarcombined[[12]]	<<- selectiondir
	mysambarcombined[[13]]	<<- inputfilesdir
	mysambarcombined[[14]]	<<- "sans"
	tempcolours				<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20")
	tempcolours2			<- tempcolours[!tempcolours%in%mycolours]
	mysambarcombined[[17]]	<<- c(mycolours,tempcolours2)
	mysambarcombined[[18]]	<<- geomapsdir
	names(mysambarcombined)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	#
	# combine TajimaD scores:
	taj1	<- read.table(paste(mylist1$diversitydir,"TajimaD.statistics.perpop.txt",sep="/"),header=TRUE)
	taj2	<- read.table(paste(mylist2$diversitydir,"TajimaD.statistics.perpop.txt",sep="/"),header=TRUE)
	tajboth	<- rbind(taj1,taj2)
	tajboth <- tajboth[order(as.character(tajboth$pop)),]
	write.table(tajboth,paste(mysambarcombined$diversitydir,"TajimaD.statistics.perpop_nonsharedsnps.txt",sep="/"),row.names=FALSE,col.names=TRUE,quote=FALSE)
	# combine SFS scores:	
	if(length(mylist1$populations)>1)
		{
		sfs1	<- read.table(paste(mylist1$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=TRUE)
		}else{
		sfs1	<- read.table(paste(mylist1$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=FALSE)
		sfs1	<- as.data.frame(t(sfs1))[2,]
		colnames(sfs1)	<- c("X0.05","X0.15","X0.25","X0.35","X0.45")
		rownames(sfs1)	<- mylist1$populations
		}
	if(length(mylist2$populations)>1)
		{
		sfs2			<- read.table(paste(mylist2$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=TRUE)
		}else{
		sfs2			<- read.table(paste(mylist2$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=FALSE)
		sfs2			<- as.data.frame(t(sfs2))[2,]
		colnames(sfs2)	<- c("X0.05","X0.15","X0.25","X0.35","X0.45")
		rownames(sfs2)	<- mylist2$populations
		}
	sfsboth	<- rbind(sfs1,sfs2)
	my_pops	<- as.vector(c(mylist1$populations,mylist2$populations))
	sfsboth <- sfsboth[order(my_pops),]
	write.table(sfsboth,paste(mysambarcombined$diversitydir,"SFS.binned.percentages_nonsharedsnps.txt",sep="/"),row.names=FALSE,col.names=TRUE,quote=FALSE)
	#
	# Print info on screen:
	cat("Datasets with shared loci have been written to a list object called 'mysambarcombined'.",sep="\n")
	cat("New (still empty) output folders have been created at:",sep="\n")
	cat(inputdatadir,sep="\n")
	cat("To start working with the data, type getdata('mysambarcombined').",sep="\n")
	cat("To see the names of the overlapping snps, type: 'my_overlap'.",sep="\n")
	}

# Add output/results from other programs to inds or snps dataframe:
# The getfrom-input should be a matrix/dataframe with one line per snp/sample.
# This function needs updating, by including 'filterdata()' function in the end 

merger<-function(addtoinds=TRUE,getfrom,idto,idfrom,newdata,removecheck=FALSE)
	{
	if(addtoinds==TRUE)
		{
		getfrom$idcheck	<- getfrom[,idfrom]
		names(getfrom)[names(getfrom) == idfrom] <- idto
		inds 		<<- merge(x = inds, y = getfrom[,c(idto,"idcheck",newdata)], by = idto, all = TRUE)
		if(removecheck)
			{
			inds$idcheck<-NULL
			}
		}else{
		getfrom$idcheck	<- getfrom[,idfrom]
		names(getfrom)[names(getfrom) == idfrom] <- idto
		snps 		<<- merge(x = snps, y = getfrom[,c(idto,newdata)], by = idto, all = TRUE)
		if(removecheck)
			{
			inds$idcheck<-NULL
			}
		}
	}

# Possibly include check:
# check	<-!is.na(inds[,idto]==inds$idcheck)
# if(any(check==FALSE))
#	{
#	print("Something seems to have gone wrong. Compare 'idcheck'-column to original identifier column.")
#	}
 

################### MANAGE PLOTS ###################

# Change colour sets:
# length of colvector should correspond to length of populations vector
editcol<-function(colvector,popnames=mysambar$populations)
	{
	mysambar$mycolours	<<- colvector
	pops<- as.character.factor(unique(inds$pop))
	for (i in (1:(length(popnames))))
		{
		for (j in (1:length(inds$pop)))
			{
			if (inds$pop[j]==pops[i])
				{
				inds$popcol[j] <<- colvector[i]
				}
			}
		}
	}

getfonts<-function(importfonts=FALSE)
	{
	if("extrafont" %in% rownames(installed.packages()) == FALSE) {install.packages("extrafont",repos=myrepos)}					# needed for 'Arial' font type in plots 
	library(extrafont)
	if(importfonts)
		{
		font_import(prompt=FALSE)
		}
	loadfonts(quiet = TRUE)											# load for PDF
	loadfonts(device = "postscript",quiet = TRUE)					# load for eps
	}







######################### RELATEDNESS ###########################

# Needs input file generated by plink -genome (with estimates of pi_hat)
relatedness<-function(infile="plink.genome",popnames=populations)
	{	
	# Read table and add a column to indicate whether individuals are from same population:
	ibd				<- read.table(infile,header=TRUE)
	ibd$samepop		<- ibd$FID1==ibd$FID2
	# Pairwise population comparisons:
	combitable		<- combn(popnames,m=2)
	# Make vector for names of between population comparisons (one way):
	combivector1		<- paste(combitable[1,],combitable[2,],sep="_")	
	# Make vector for names of between population comparisons (the other way):
	combivector2		<- paste(combitable[2,],combitable[1,],sep="_")	
	# Make vector for names of within population comparisons:
	combivector3		<- vector()
	samepopmean			<<- vector()
	diffpopmean1		<<- vector()
	diffpopmean2		<<- vector()
	for (i in (1:length(popnames)))
		{
		combivector3[i]	<- paste(popnames[i],popnames[i],sep="_")
		}
	##### Create an empty list to save results:
	results 		<<- list()
	##### How many relatives does a individual have within it's own population?
	for (i in (1:length(combivector3)))
		{
		# select all rows with pi above 0.1825 and column for samepop is TRUE:
		ibdwithin			<- ibd[ibd$PI_HAT>0.1825&ibd$samepop&ibd$FID1==popnames[i],]
		ibdwithinall		<- ibd[ibd$samepop&ibd$FID1==popnames[i],]
		samepopmean[i]		<<- mean(ibdwithinall$PI_HAT,na.rm=TRUE)
		# select columns with individual names, and sort on alphabetical and numerical order:
		relativeswithin		<- sort(c(ibdwithin$IID1,ibdwithin$IID2))
		# assign(paste("ibdwithin",popnames[i],sep="_"),relativeswithin)
		# If sample occurs more than once, it is listed more than once. To collapse, make a table (which we save):
		results[[i]]		<<- table(relativeswithin)
		}
	##### How many relatives does a sample has within any other populations?
	ibdbetween		<- ibd[ibd$PI_HAT>0.1825&ibd$samepop=="FALSE",]
	ibdbetweenall	<- ibd[ibd$samepop=="FALSE",] 
	# For one direction of pairwise comparisons (how many relatives do individuals in pop A have with pop B?)
	for (i in (1:length(combivector1)))
		{
		diffpopmean1[i]		<<- mean(ibdbetweenall$PI_HAT[ibdbetweenall$FID1==combitable[1,i]&ibdbetweenall$FID2==combitable[2,i]],na.rm=TRUE)
		relativesbetween<-c(ibdbetween$IID1[ibdbetween$FID1==combitable[1,i]&ibdbetween$FID2==combitable[2,i]],ibdbetween$IID2[ibdbetween$FID2==combitable[1,i]&ibdbetween$FID1==combitable[2,i]])
		results[[i+length(combivector3)]]	<<- table(relativesbetween)
		}
	# For the other direction of pairwise comparison (how many relatives do individuals in pop B have with pop A?)
	for (i in (1:length(combivector2)))	
		{
		diffpopmean2[i]		<<- mean(ibdbetweenall$PI_HAT[ibdbetweenall$FID1==combitable[2,i]&ibdbetweenall$FID2==combitable[1,i]],na.rm=TRUE)
		relativesbetween<-c(ibdbetween$IID1[ibdbetween$FID1==combitable[2,i]&ibdbetween$FID2==combitable[1,i]],ibdbetween$IID2[ibdbetween$FID2==combitable[2,i]&ibdbetween$FID1==combitable[1,i]])
		results[[i+length(combivector3)+length(combivector1)]]	<<- table(relativesbetween)
		}
	##### Give names to list elements:
	# This has to be after the last loop, otherwise names are overwritten.
	combivector	<- c(combivector3,combivector1,combivector2)
	list.names	<- as.list(combivector)
	names(results)	<<- list.names
	# The results output table shows for each individual (indicated by nr) how many relatives they have in the other population.   
	}


############################# PLOTS ###############################


# Boxplot sample inbreeding coefficients per population:  
F_boxplot<-function(export=FALSE,exportname="filtereddata",popnames=populations,colourcode=inds$popcol2,yrange=c(0,8))
	{
	if(!(any(names(inds)=="F")))
		{
		print("This function can only be executed if the 'inds'-dataframe contains a column (called 'F') with inbreeding coefficients. This estimates can be generated with PLINK.")
		}
	# Export file?
	if(export==TRUE){win.metafile(paste(exportname,"F.wmf",sep = "."))}
	graphics.off()
	boxplot(inds$F~inds$pop2,na.rm=TRUE,col=unique(colourcode),ylab="Inbreeding coefficient F",xlab="Populations",frame=F)
	if(export==TRUE)
		{
		dev.off()
		path1<- paste(getwd(),exportname,sep="/")
		path2<- paste(path1,"F.wmf",sep = ".")
		print(paste("Plot has been written to", path2, sep=" "))
		}
	}


##### Functions to plot individual heterozygosities:

##### Boxplot:
He_boxplot<-function(export=FALSE,exportname="filtereddata",popnames=populations,colourcode=inds$popcol2,yrange=c(0,8))
	{
	if(!(any(names(inds)=="hetero")))
		{
		print("This function can only be executed if the 'inds'-dataframe contains a column (called 'hetero') with sample heterozygosities. This estimates can be generated with the 'heterozygosities'-function.")
		}
	# Export file?
	if(export==TRUE){win.metafile(paste(exportname,"Heboxplot.wmf",sep = "."))}
	graphics.off()
	boxplot(inds$hetero[inds$filter]~inds$pop2[inds$filter],notch=FALSE,col=unique(colourcode),main=NULL, xlab="Populations",ylab="Sample heterozygosity") 
	if(export==TRUE)
		{
		dev.off()
		path1<- paste(getwd(),exportname,sep="/")
		path2<- paste(path1,"Heboxplot.wmf",sep = ".")
		print(paste("Plot has been written to", path2, sep=" "))
		}
	}


# Ugly plot:
##### Histogram (with optionally distinction between X-chromosome and autosomal chromosomes):
He_histo<-function(export=FALSE,exportname="mygenlight",popnames=populations,colourcode=inds$popcol,yrange=c(0,8))
	{
	# Export file?
	if(export==TRUE){win.metafile(paste(exportname,"indhe.wmf",sep = "."))}
	# Some prep:
	mymax	<- max(inds$hetero)
	if(max(inds$hetero)>0.5)
		{
		breakpoints<-seq(0,mymax+0.05,0.01)
		}else{
		breakpoints<-seq(0,0.5,0.01)
		}
	graphics.off()
	par(mfrow=c(1,length(popnames)),mai=c(0.75,0.75,0.125,0.25),oma=c(1,0,1,0))
	for (i in (1:length(popnames)))
		{
		hist(inds$hetero[inds$pop2==popnames[i]&inds$filter],breaks=breakpoints,col=colourcode[inds$pop2==popnames[i]&inds$filter],lty=0,xlim=c(0,mymax),ylim=yrange,xlab=NULL,ylab="# individuals",main=popnames[i])
		if(length(snps$chr[snps$chr=="X"])>0)
			{
			hist(inds$heteroX[inds$pop2==popnames[i]&inds$filter],breaks=breakpoints,add=T,col=NULL,main=NULL,ylim=yrange,xlab=NULL,ylab=NULL)
			mtext("Individual heterozygosities for autosomal (filled bar) and X-chromosome (open bar)", side = 1, outer = TRUE,line=-1.5)
			}else{
			mtext("Individual heterozygosities", side = 1, outer = TRUE,line=-1.5)
			}
		}
	if(export==TRUE)
		{
		dev.off()
		path1<- paste(getwd(),exportname,sep="/")
		path2<- paste(path1,"indhe.wmf",sep = ".")
		print(paste("Plot has been written to", path2, sep=" "))
		}
	}

cat("SambaR loaded.",sep="\n")



